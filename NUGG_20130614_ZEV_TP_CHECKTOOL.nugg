<?xml version="1.0" encoding="utf-16"?>
<nugget name="20130614_ZEV_TP_CHECKTOOL">
 <TRAN TCODE="ZTCT" PGMNA="ZEV_TP_CHECKTOOL" DYPNO="1000" CINFO="80">
  <tstct SPRSL="E" TCODE="ZTCT" TTEXT="Transport Checking Tool"/>
  <tstcc TCODE="ZTCT"/>
  <tstcp/>
  <rsstcd ST_PROG="X" DEVCLASS="$TMP"/>
 </TRAN>
 <PROG NAME="ZEV_TP_CHECKTOOL" VARCL="X" SUBC="1" CNAM="EDVLS0" CDAT="20130308" UNAM="EVLEESHOUWER" UDAT="20130614" VERN="000168" RMAND="100" RLOAD="N" FIXPT="X" SDATE="20130614" STIME="145039" IDATE="20130614" ITIME="145039" UCCHECK="X">
  <textPool>
   <language SPRAS="E">
    <textElement ID="I" KEY="008" ENTRY="Desktop not found" LENGTH="50 "/>
    <textElement ID="I" KEY="009" ENTRY="Save Transportlist" LENGTH="50 "/>
    <textElement ID="I" KEY="010" ENTRY="Object data retrieved..." LENGTH="50 "/>
    <textElement ID="I" KEY="011" ENTRY="Objects checked" LENGTH="50 "/>
    <textElement ID="I" KEY="012" ENTRY="Desktop not found" LENGTH="50 "/>
    <textElement ID="I" KEY="013" ENTRY="Select a transportlist" LENGTH="50 "/>
    <textElement ID="I" KEY="014" ENTRY="Selecting data..." LENGTH="50 "/>
    <textElement ID="I" KEY="015" ENTRY="RC" LENGTH="50 "/>
    <textElement ID="I" KEY="016" ENTRY="Return Code" LENGTH="50 "/>
    <textElement ID="I" KEY="017" ENTRY="Descript." LENGTH="50 "/>
    <textElement ID="I" KEY="018" ENTRY="Description" LENGTH="50 "/>
    <textElement ID="I" KEY="019" ENTRY="No transports need to be added" LENGTH="50 "/>
    <textElement ID="I" KEY="020" ENTRY="To see the conflicts, doubleclick the warning" LENGTH="50 "/>
    <textElement ID="I" KEY="021" ENTRY="No next conflict found" LENGTH="50 "/>
    <textElement ID="I" KEY="022" ENTRY="records read and added." LENGTH="50 "/>
    <textElement ID="I" KEY="023" ENTRY="records checked (documentation)" LENGTH="50 "/>
    <textElement ID="I" KEY="024" ENTRY="Info" LENGTH="50 "/>
    <textElement ID="I" KEY="025" ENTRY="Clear" LENGTH="50 "/>
    <textElement ID="I" KEY="026" ENTRY="Def." LENGTH="50 "/>
    <textElement ID="I" KEY="027" ENTRY="Information" LENGTH="50 "/>
    <textElement ID="I" KEY="028" ENTRY="General Info" LENGTH="50 "/>
    <textElement ID="I" KEY="029" ENTRY="Error occurred" LENGTH="50 "/>
    <textElement ID="I" KEY="030" ENTRY="Documentation for" LENGTH="50 "/>
    <textElement ID="I" KEY="031" ENTRY="Cancelled by user" LENGTH="50 "/>
    <textElement ID="I" KEY="032" ENTRY="Hints and Tips for" LENGTH="50 "/>
    <textElement ID="I" KEY="033" ENTRY="ERR." LENGTH="50 "/>
    <textElement ID="I" KEY="034" ENTRY="Warn" LENGTH="50 "/>
    <textElement ID="I" KEY="035" ENTRY="The file has been saved" LENGTH="50 "/>
    <textElement ID="I" KEY="036" ENTRY="Cancelled by user" LENGTH="50 "/>
    <textElement ID="I" KEY="037" ENTRY="Yes" LENGTH="50 "/>
    <textElement ID="I" KEY="038" ENTRY="ERROR:" LENGTH="50 "/>
    <textElement ID="I" KEY="039" ENTRY="Runtime Alert" LENGTH="13 "/>
    <textElement ID="I" KEY="041" ENTRY="This will take approx. 5-15 minutes... Continue?" LENGTH="48 "/>
    <textElement ID="I" KEY="042" ENTRY="This has already been done. Do again?" LENGTH="37 "/>
    <textElement ID="I" KEY="043" ENTRY="No" LENGTH="2 "/>
    <textElement ID="I" KEY="047" ENTRY="Sts" LENGTH="3 "/>
    <textElement ID="I" KEY="048" ENTRY="Status" LENGTH="6 "/>
    <textElement ID="I" KEY="049" ENTRY="File uploaded:" LENGTH="14 "/>
    <textElement ID="I" KEY="050" ENTRY="Checking buffer" LENGTH="15 "/>
    <textElement ID="I" KEY="051" ENTRY="DDIC not transported..." LENGTH="26 "/>
    <textElement ID="I" KEY="052" ENTRY="Retrieving Where Used list" LENGTH="26 "/>
    <textElement ID="I" KEY="053" ENTRY="Collecting DDIC Info" LENGTH="20 "/>
    <textElement ID="I" KEY="B10" ENTRY="Selection range / Upload file" LENGTH="29 "/>
    <textElement ID="I" KEY="B21" ENTRY="Selection criteria" LENGTH="18 "/>
    <textElement ID="I" KEY="B22" ENTRY="File upload" LENGTH="14 "/>
    <textElement ID="I" KEY="B30" ENTRY="Transport Track" LENGTH="15 "/>
    <textElement ID="I" KEY="B40" ENTRY="Check options" LENGTH="13 "/>
    <textElement ID="I" KEY="B50" ENTRY="Exclude from check" LENGTH="18 "/>
    <textElement ID="I" KEY="B60" ENTRY="Overview of used Icons" LENGTH="50 "/>
    <textElement ID="I" KEY="C21" ENTRY="User" LENGTH="4 "/>
    <textElement ID="I" KEY="C22" ENTRY="File name" LENGTH="9 "/>
    <textElement ID="I" KEY="C31" ENTRY="Route" LENGTH="5 "/>
    <textElement ID="I" KEY="C32" ENTRY="--&gt;" LENGTH="3 "/>
    <textElement ID="I" KEY="C33" ENTRY="--&gt;" LENGTH="3 "/>
    <textElement ID="I" KEY="C40" ENTRY="Do not select transports already in production" LENGTH="49 "/>
    <textElement ID="I" KEY="C41" ENTRY="Use User specific layout" LENGTH="24 "/>
    <textElement ID="I" KEY="C42" ENTRY="Skip transport buffer check" LENGTH="27 "/>
    <textElement ID="I" KEY="C43" ENTRY="Check table keys" LENGTH="16 "/>
    <textElement ID="I" KEY="C44" ENTRY="Reset `Checked` field" LENGTH="21 "/>
    <textElement ID="I" KEY="C46" ENTRY="Check ON / Check OFF" LENGTH="20 "/>
    <textElement ID="I" KEY="C51" ENTRY="Objects in the range will not be taken into account when checking the" LENGTH="69 "/>
    <textElement ID="I" KEY="C52" ENTRY="transports. Useful to exclude common customizing tables (like SWOTICE for" LENGTH="73 "/>
    <textElement ID="I" KEY="C53" ENTRY="workflow or the tables for Pricing procedures)." LENGTH="47 "/>
    <textElement ID="I" KEY="C61" ENTRY="Show" LENGTH="4 "/>
    <textElement ID="I" KEY="C62" ENTRY="Hide" LENGTH="4 "/>
    <textElement ID="I" KEY="H01" ENTRY="If there is a warning icon in column `Warning`, double-clicking on the icon will display a list of objects that should be checked" LENGTH="132 "/>
    <textElement ID="I" KEY="H02" ENTRY="You can add these conflicts by means of the button &apos;Add Conflicts&apos; in the application toolbar or doubleclicking the warning" LENGTH="132 "/>
    <textElement ID="I" KEY="M01" ENTRY="Select the row to delete" LENGTH="24 "/>
    <textElement ID="I" KEY="M02" ENTRY="Some transports were deleted from the list because" LENGTH="50 "/>
    <textElement ID="I" KEY="M03" ENTRY="they are missing in Acceptance or are already in" LENGTH="48 "/>
    <textElement ID="I" KEY="M04" ENTRY="Production but not marked for re-import." LENGTH="40 "/>
    <textElement ID="I" KEY="M05" ENTRY="Please check the main list." LENGTH="27 "/>
    <textElement ID="I" KEY="M06" ENTRY="No rows selected: No transports will be added" LENGTH="50 "/>
    <textElement ID="I" KEY="M07" ENTRY="No rows selected: Table keys will not be checked" LENGTH="48 "/>
    <textElement ID="I" KEY="M08" ENTRY="ERROR: ERROR_IN_FIELDS" LENGTH="22 "/>
    <textElement ID="I" KEY="M09" ENTRY="Cancelled: Table keys will not be checked" LENGTH="41 "/>
    <textElement ID="I" KEY="M10" ENTRY="Please select records or put the cursor on a row" LENGTH="48 "/>
    <textElement ID="I" KEY="M11" ENTRY="No records selected that can be re-imported" LENGTH="43 "/>
    <textElement ID="I" KEY="M12" ENTRY="Transport not in Transport Buffer" LENGTH="36 "/>
    <textElement ID="I" KEY="M13" ENTRY="No transports found..." LENGTH="22 "/>
    <textElement ID="I" KEY="T01" ENTRY="Selected transports" LENGTH="19 "/>
    <textElement ID="I" KEY="T02" ENTRY="Keys can be checked for the following tables" LENGTH="47 "/>
    <textElement ID="I" KEY="T03" ENTRY="Error Creating ALV Grid" LENGTH="23 "/>
    <textElement ID="I" KEY="T04" ENTRY="No of Records found:" LENGTH="20 "/>
    <textElement ID="I" KEY="T05" ENTRY="Information" LENGTH="11 "/>
    <textElement ID="I" KEY="W01" ENTRY="Newer version in production!" LENGTH="50 "/>
    <textElement ID="I" KEY="W02" ENTRY="No version found to compare" LENGTH="27 "/>
    <textElement ID="I" KEY="W03" ENTRY="Uses object not in list or production" LENGTH="40 "/>
    <textElement ID="I" KEY="W04" ENTRY="All conflicts are dealt with by the list" LENGTH="50 "/>
    <textElement ID="I" KEY="W05" ENTRY="Object missing in List and Production!" LENGTH="38 "/>
    <textElement ID="I" KEY="W11" ENTRY="Overwrites version(s), newer version in list" LENGTH="44 "/>
    <textElement ID="I" KEY="W16" ENTRY="Log couldn&apos;t be read or TP not released" LENGTH="40 "/>
    <textElement ID="I" KEY="W17" ENTRY="Previous transport not transported" LENGTH="40 "/>
    <textElement ID="I" KEY="W18" ENTRY="Marked for re-import to Production" LENGTH="40 "/>
    <textElement ID="I" KEY="W19" ENTRY="Transport not released" LENGTH="40 "/>
    <textElement ID="I" KEY="W20" ENTRY="Release started" LENGTH="40 "/>
    <textElement ID="I" KEY="W21" ENTRY="Couldn&apos;t read log, but object in list" LENGTH="40 "/>
    <textElement ID="I" KEY="W22" ENTRY="Newer version in Acceptance, but in list" LENGTH="40 "/>
    <textElement ID="I" KEY="W23" ENTRY="Newer version in Acceptance" LENGTH="41 "/>
    <textElement ID="R" ENTRY="Transport Checking Tool (Object level)" LENGTH="38 "/>
    <textElement ID="S" KEY="PA_CHD" ENTRY="        Reset &apos;Checked&apos; field" LENGTH="29 "/>
    <textElement ID="S" KEY="PA_CHECK" ENTRY="        Check ON" LENGTH="16 "/>
    <textElement ID="S" KEY="PA_CHKKY" ENTRY="        Check table keys" LENGTH="24 "/>
    <textElement ID="S" KEY="PA_FILE" ENTRY="        File name" LENGTH="17 "/>
    <textElement ID="S" KEY="PA_ICON" ENTRY="        Show" LENGTH="12 "/>
    <textElement ID="S" KEY="PA_NOCHK" ENTRY="        Check OFF" LENGTH="17 "/>
    <textElement ID="S" KEY="PA_NOICN" ENTRY="        Hide" LENGTH="12 "/>
    <textElement ID="S" KEY="PA_PRD" ENTRY="        Production" LENGTH="18 "/>
    <textElement ID="S" KEY="PA_QAS" ENTRY="        Acceptance" LENGTH="18 "/>
    <textElement ID="S" KEY="PA_SEL" ENTRY="        Build transport list" LENGTH="28 "/>
    <textElement ID="S" KEY="PA_STR" ENTRY="        Short Description" LENGTH="25 "/>
    <textElement ID="S" KEY="PA_UPL" ENTRY="        Upload transport list" LENGTH="29 "/>
    <textElement ID="S" KEY="PA_USER" ENTRY="        Use User specific layout" LENGTH="32 "/>
    <textElement ID="S" KEY="SO_DATE" ENTRY="        Date" LENGTH="12 "/>
    <textElement ID="S" KEY="SO_EXOBJ" ENTRY="        Obj. Name" LENGTH="17 "/>
    <textElement ID="S" KEY="SO_KORR" ENTRY="        Request number" LENGTH="22 "/>
    <textElement ID="S" KEY="SO_PROJ" ENTRY="        CTS Project" LENGTH="19 "/>
    <textElement ID="S" KEY="SO_USER" ENTRY="        User Name" LENGTH="17 "/>
   </language>
   <language SPRAS="N">
    <textElement ID="I" KEY="008" ENTRY="Desktop not found" LENGTH="50 "/>
    <textElement ID="I" KEY="009" ENTRY="Save Transportlist" LENGTH="50 "/>
    <textElement ID="I" KEY="010" ENTRY="Object data retrieved..." LENGTH="50 "/>
    <textElement ID="I" KEY="011" ENTRY="Objects checked" LENGTH="50 "/>
    <textElement ID="I" KEY="012" ENTRY="Desktop not found" LENGTH="50 "/>
    <textElement ID="I" KEY="013" ENTRY="Select a transportlist" LENGTH="50 "/>
    <textElement ID="I" KEY="014" ENTRY="Selecting data..." LENGTH="50 "/>
    <textElement ID="I" KEY="015" ENTRY="RC" LENGTH="50 "/>
    <textElement ID="I" KEY="016" ENTRY="Return Code" LENGTH="50 "/>
    <textElement ID="I" KEY="017" ENTRY="Descript." LENGTH="50 "/>
    <textElement ID="I" KEY="018" ENTRY="Description" LENGTH="50 "/>
    <textElement ID="I" KEY="019" ENTRY="No transports need to be added" LENGTH="50 "/>
    <textElement ID="I" KEY="020" ENTRY="To see the conflicts, doubleclick the warning" LENGTH="50 "/>
    <textElement ID="I" KEY="021" ENTRY="No next conflict found" LENGTH="50 "/>
    <textElement ID="I" KEY="022" ENTRY="records read and added." LENGTH="50 "/>
    <textElement ID="I" KEY="023" ENTRY="records checked (documentation)" LENGTH="50 "/>
    <textElement ID="I" KEY="024" ENTRY="Info" LENGTH="50 "/>
    <textElement ID="I" KEY="025" ENTRY="Clear" LENGTH="50 "/>
    <textElement ID="I" KEY="026" ENTRY="Def." LENGTH="50 "/>
    <textElement ID="I" KEY="027" ENTRY="Information" LENGTH="50 "/>
    <textElement ID="I" KEY="028" ENTRY="General Info" LENGTH="50 "/>
    <textElement ID="I" KEY="029" ENTRY="Error occurred" LENGTH="50 "/>
    <textElement ID="I" KEY="030" ENTRY="Documentation for" LENGTH="50 "/>
    <textElement ID="I" KEY="031" ENTRY="Cancelled by user" LENGTH="50 "/>
    <textElement ID="I" KEY="032" ENTRY="Hints and Tips for" LENGTH="50 "/>
    <textElement ID="I" KEY="033" ENTRY="ERR." LENGTH="50 "/>
    <textElement ID="I" KEY="034" ENTRY="Warn" LENGTH="50 "/>
    <textElement ID="I" KEY="035" ENTRY="The file has been saved" LENGTH="50 "/>
    <textElement ID="I" KEY="036" ENTRY="Cancelled by user" LENGTH="50 "/>
    <textElement ID="I" KEY="037" ENTRY="Yes" LENGTH="50 "/>
    <textElement ID="I" KEY="038" ENTRY="ERROR:" LENGTH="50 "/>
    <textElement ID="I" KEY="039" ENTRY="Runtime Alert" LENGTH="13 "/>
    <textElement ID="I" KEY="041" ENTRY="This will take approx. 5-15 minutes... Continue?" LENGTH="48 "/>
    <textElement ID="I" KEY="042" ENTRY="This has already been done. Do again?" LENGTH="37 "/>
    <textElement ID="I" KEY="043" ENTRY="No" LENGTH="2 "/>
    <textElement ID="I" KEY="047" ENTRY="Sts" LENGTH="3 "/>
    <textElement ID="I" KEY="048" ENTRY="Status" LENGTH="6 "/>
    <textElement ID="I" KEY="049" ENTRY="File uploaded:" LENGTH="14 "/>
    <textElement ID="I" KEY="050" ENTRY="Checking buffer" LENGTH="15 "/>
    <textElement ID="I" KEY="051" ENTRY="DDIC not transported..." LENGTH="26 "/>
    <textElement ID="I" KEY="052" ENTRY="Retrieving Where Used list" LENGTH="26 "/>
    <textElement ID="I" KEY="053" ENTRY="Collecting DDIC Info" LENGTH="20 "/>
    <textElement ID="I" KEY="B10" ENTRY="Selection range / Upload file" LENGTH="29 "/>
    <textElement ID="I" KEY="B21" ENTRY="Selection criteria" LENGTH="18 "/>
    <textElement ID="I" KEY="B22" ENTRY="File upload" LENGTH="14 "/>
    <textElement ID="I" KEY="B30" ENTRY="Transport Track" LENGTH="15 "/>
    <textElement ID="I" KEY="B40" ENTRY="Check options" LENGTH="13 "/>
    <textElement ID="I" KEY="B50" ENTRY="Exclude from check" LENGTH="18 "/>
    <textElement ID="I" KEY="B60" ENTRY="Overview of used Icons" LENGTH="50 "/>
    <textElement ID="I" KEY="C21" ENTRY="User" LENGTH="4 "/>
    <textElement ID="I" KEY="C22" ENTRY="File name" LENGTH="9 "/>
    <textElement ID="I" KEY="C31" ENTRY="Route" LENGTH="5 "/>
    <textElement ID="I" KEY="C32" ENTRY="--&gt;" LENGTH="3 "/>
    <textElement ID="I" KEY="C33" ENTRY="--&gt;" LENGTH="3 "/>
    <textElement ID="I" KEY="C40" ENTRY="Do not select transports already in production" LENGTH="49 "/>
    <textElement ID="I" KEY="C41" ENTRY="Use User specific layout" LENGTH="24 "/>
    <textElement ID="I" KEY="C42" ENTRY="Skip transport buffer check" LENGTH="27 "/>
    <textElement ID="I" KEY="C43" ENTRY="Check table keys" LENGTH="16 "/>
    <textElement ID="I" KEY="C44" ENTRY="Reset `Checked` field" LENGTH="21 "/>
    <textElement ID="I" KEY="C46" ENTRY="Check ON / Check OFF" LENGTH="20 "/>
    <textElement ID="I" KEY="C51" ENTRY="Objects in the range will not be taken into account when checking the" LENGTH="69 "/>
    <textElement ID="I" KEY="C52" ENTRY="transports. Useful to exclude common customizing tables (like SWOTICE for" LENGTH="73 "/>
    <textElement ID="I" KEY="C53" ENTRY="workflow or the tables for Pricing procedures)." LENGTH="47 "/>
    <textElement ID="I" KEY="C61" ENTRY="Show" LENGTH="4 "/>
    <textElement ID="I" KEY="C62" ENTRY="Hide" LENGTH="4 "/>
    <textElement ID="I" KEY="H01" ENTRY="If there is a warning icon in column `Warning`, double-clicking on the icon will display a list of objects that should be checked" LENGTH="132 "/>
    <textElement ID="I" KEY="H02" ENTRY="You can add these conflicts by means of the button &apos;Add Conflicts&apos; in the application toolbar or doubleclicking the warning" LENGTH="132 "/>
    <textElement ID="I" KEY="M01" ENTRY="Select the row to delete" LENGTH="24 "/>
    <textElement ID="I" KEY="M02" ENTRY="Some transports were deleted from the list because" LENGTH="50 "/>
    <textElement ID="I" KEY="M03" ENTRY="they are missing in Acceptance or are already in" LENGTH="48 "/>
    <textElement ID="I" KEY="M04" ENTRY="Production but not marked for re-import." LENGTH="40 "/>
    <textElement ID="I" KEY="M05" ENTRY="Please check the main list." LENGTH="27 "/>
    <textElement ID="I" KEY="M06" ENTRY="No rows selected: No transports will be added" LENGTH="50 "/>
    <textElement ID="I" KEY="M07" ENTRY="No rows selected: Table keys will not be checked" LENGTH="48 "/>
    <textElement ID="I" KEY="M08" ENTRY="ERROR: ERROR_IN_FIELDS" LENGTH="22 "/>
    <textElement ID="I" KEY="M09" ENTRY="Cancelled: Table keys will not be checked" LENGTH="41 "/>
    <textElement ID="I" KEY="M10" ENTRY="Please select records or put the cursor on a row" LENGTH="48 "/>
    <textElement ID="I" KEY="M11" ENTRY="No records selected that can be re-imported" LENGTH="43 "/>
    <textElement ID="I" KEY="M12" ENTRY="Transport not in Transport Buffer" LENGTH="36 "/>
    <textElement ID="I" KEY="M13" ENTRY="No transports found..." LENGTH="22 "/>
    <textElement ID="I" KEY="T01" ENTRY="Selected transports" LENGTH="19 "/>
    <textElement ID="I" KEY="T02" ENTRY="Keys can be checked for the following tables" LENGTH="47 "/>
    <textElement ID="I" KEY="T03" ENTRY="Error Creating ALV Grid" LENGTH="23 "/>
    <textElement ID="I" KEY="T04" ENTRY="No of Records found:" LENGTH="20 "/>
    <textElement ID="I" KEY="T05" ENTRY="Information" LENGTH="11 "/>
    <textElement ID="I" KEY="W01" ENTRY="Newer version in production!" LENGTH="50 "/>
    <textElement ID="I" KEY="W02" ENTRY="No version found to compare" LENGTH="27 "/>
    <textElement ID="I" KEY="W03" ENTRY="Uses object not in list or production" LENGTH="40 "/>
    <textElement ID="I" KEY="W04" ENTRY="All conflicts are dealt with by the list" LENGTH="50 "/>
    <textElement ID="I" KEY="W05" ENTRY="Object missing in List and Production!" LENGTH="38 "/>
    <textElement ID="I" KEY="W11" ENTRY="Overwrites version(s), newer version in list" LENGTH="44 "/>
    <textElement ID="I" KEY="W16" ENTRY="Log couldn&apos;t be read or TP not released" LENGTH="40 "/>
    <textElement ID="I" KEY="W17" ENTRY="Previous transport not transported" LENGTH="40 "/>
    <textElement ID="I" KEY="W18" ENTRY="Marked for re-import to Production" LENGTH="40 "/>
    <textElement ID="I" KEY="W19" ENTRY="Transport not released" LENGTH="40 "/>
    <textElement ID="I" KEY="W20" ENTRY="Release started" LENGTH="40 "/>
    <textElement ID="I" KEY="W21" ENTRY="Couldn&apos;t read log, but object in list" LENGTH="40 "/>
    <textElement ID="I" KEY="W22" ENTRY="Newer version in Acceptance, but in list" LENGTH="40 "/>
    <textElement ID="I" KEY="W23" ENTRY="Newer version in Acceptance" LENGTH="41 "/>
    <textElement ID="R" ENTRY="Transport Checking Tool (Object level)" LENGTH="70 "/>
    <textElement ID="S" KEY="PA_CHD" ENTRY="        Reset &apos;Checked&apos; field" LENGTH="29 "/>
    <textElement ID="S" KEY="PA_CHECK" ENTRY="        Check ON" LENGTH="16 "/>
    <textElement ID="S" KEY="PA_CHKKY" ENTRY="        Check table keys" LENGTH="24 "/>
    <textElement ID="S" KEY="PA_FILE" ENTRY="        File name" LENGTH="17 "/>
    <textElement ID="S" KEY="PA_ICON" ENTRY="        Show" LENGTH="12 "/>
    <textElement ID="S" KEY="PA_NOCHK" ENTRY="        Check OFF" LENGTH="17 "/>
    <textElement ID="S" KEY="PA_NOICN" ENTRY="        Hide" LENGTH="12 "/>
    <textElement ID="S" KEY="PA_PRD" ENTRY="        Production" LENGTH="18 "/>
    <textElement ID="S" KEY="PA_QAS" ENTRY="        Acceptance" LENGTH="18 "/>
    <textElement ID="S" KEY="PA_SEL" ENTRY="        Build transport list" LENGTH="28 "/>
    <textElement ID="S" KEY="PA_STR" ENTRY="        Short Description" LENGTH="25 "/>
    <textElement ID="S" KEY="PA_UPL" ENTRY="        Upload transport list" LENGTH="29 "/>
    <textElement ID="S" KEY="PA_USER" ENTRY="        Use User specific layout" LENGTH="32 "/>
    <textElement ID="S" KEY="SO_DATE" ENTRY="        Date" LENGTH="12 "/>
    <textElement ID="S" KEY="SO_EXOBJ" ENTRY="        Obj. Name" LENGTH="17 "/>
    <textElement ID="S" KEY="SO_KORR" ENTRY="        Request number" LENGTH="22 "/>
    <textElement ID="S" KEY="SO_PROJ" ENTRY="        CTS Project" LENGTH="19 "/>
    <textElement ID="S" KEY="SO_USER" ENTRY="        User Name" LENGTH="17 "/>
   </language>
  </textPool>
  <pfstatus>
   <pfstatus_sta CODE="STANDARD_FULLSCREEN" MODAL="D" ACTCODE="000001" PFKCODE="000001" BUTCODE="0001" INT_NOTE="Standard for generic List Output in Fullscreen Grid"/>
   <pfstatus_fun CODE="%ML" TEXTNO="001" TEXT_TYPE="S" FUN_TEXT="Folder" PATH="F"/>
   <pfstatus_fun CODE="%PC" TEXTNO="001" TEXT_TYPE="S" TEXT_NAME="ICON_EXPORT" ICON_ID="@49@" FUN_TEXT="Local File..." PATH="L"/>
   <pfstatus_fun CODE="%SC" TEXTNO="001" TEXT_TYPE="S" TEXT_NAME="ICON_SEARCH" ICON_ID="@13@" FUN_TEXT="Find" PATH="N"/>
   <pfstatus_fun CODE="%SC+" TEXTNO="001" TEXT_TYPE="S" TEXT_NAME="ICON_SEARCH_NEXT" ICON_ID="@4E@" FUN_TEXT="Find Next"/>
   <pfstatus_fun CODE="%SL" TEXTNO="001" TEXT_TYPE="S" TEXT_NAME="ICON_MAIL" ICON_ID="@1S@" FUN_TEXT="Mail Recipient" PATH="M"/>
   <pfstatus_fun CODE="&amp;ABC" TEXTNO="001" TEXT_TYPE="S" TEXT_NAME="ICON_ABC" ICON_ID="@DL@" FUN_TEXT="ABC Analysis" PATH="A"/>
   <pfstatus_fun CODE="&amp;ADD" TEXTNO="001" TEXT_TYPE="S" TEXT_NAME="ICON_INSERT_MULTIPLE_LINES" ICON_ID="@GU@" FUN_TEXT="Add conflicts" ICON_TEXT="Add Conflicts" INFO_TEXT="Add conflicts from one or more selected rows"/>
   <pfstatus_fun CODE="&amp;ADD_FILE" TEXTNO="001" TEXT_TYPE="S" TEXT_NAME="ICON_IMPORT" ICON_ID="@48@" FUN_TEXT="Add file" ICON_TEXT="Add file" INFO_TEXT="Upload another file to be merged with the list"/>
   <pfstatus_fun CODE="&amp;ADD_TP" TEXTNO="001" TEXT_TYPE="S" TEXT_NAME="ICON_INSERT_ROW" ICON_ID="@17@" FUN_TEXT="Add transport" ICON_TEXT="Add Transport" INFO_TEXT="Add a single transport to the list"/>
   <pfstatus_fun CODE="&amp;ALL" TEXTNO="001" TEXT_TYPE="S" TEXT_NAME="ICON_SELECT_ALL" ICON_ID="@4B@" FUN_TEXT="Select All" PATH="E"/>
   <pfstatus_fun CODE="&amp;AQW" TEXTNO="001" TEXT_TYPE="S" TEXT_NAME="ICON_WORD_PROCESSING" ICON_ID="@DK@" FUN_TEXT="Word Processing..." PATH="W"/>
   <pfstatus_fun CODE="&amp;AUF" TEXTNO="001" TEXT_TYPE="S" FUN_TEXT="Define Totals Drilldown..." PATH="S"/>
   <pfstatus_fun CODE="&amp;AVE" TEXTNO="001" TEXT_TYPE="S" FUN_TEXT="Saving..." PATH="S"/>
   <pfstatus_fun CODE="&amp;AVE" TEXTNO="002" TEXT_TYPE="S" TEXT_NAME="ICON_ALV_VARIANT_SAVE" ICON_ID="@DN@" FUN_TEXT="Save Layout..."/>
   <pfstatus_fun CODE="&amp;AVR" TEXTNO="001" TEXT_TYPE="S" FUN_TEXT="Mean Value" PATH="M"/>
   <pfstatus_fun CODE="&amp;CDF" TEXTNO="001" TEXT_TYPE="S" FUN_TEXT="Unfreeze Columns" PATH="U"/>
   <pfstatus_fun CODE="&amp;CFI" TEXTNO="001" TEXT_TYPE="S" FUN_TEXT="Freeze to Column" PATH="F"/>
   <pfstatus_fun CODE="&amp;COUNT" TEXTNO="001" TEXT_TYPE="S" FUN_TEXT="Count" PATH="C"/>
   <pfstatus_fun CODE="&amp;DEL" TEXTNO="001" TEXT_TYPE="S" TEXT_NAME="ICON_DELETE_ROW" ICON_ID="@18@" FUN_TEXT="Remove transport" ICON_TEXT="Remove" INFO_TEXT="Remove selected transport(s) from the list"/>
   <pfstatus_fun CODE="&amp;DOC" TEXTNO="001" TEXT_TYPE="S" TEXT_NAME="ICON_CHANGE_TEXT" ICON_ID="@0Q@" FUN_TEXT="Edit Doc." ICON_TEXT="Edit Doc." INFO_TEXT="Edit Documentation"/>
   <pfstatus_fun CODE="&amp;EB9" TEXTNO="001" TEXT_TYPE="S" TEXT_NAME="ICON_TABLE_SETTINGS" ICON_ID="@36@" FUN_TEXT="Call Up Report..." PATH="R"/>
   <pfstatus_fun CODE="&amp;ELP" TEXTNO="001" TEXT_TYPE="S" TEXT_NAME="ICON_SYSTEM_HELP" ICON_ID="@35@" FUN_TEXT="Help"/>
   <pfstatus_fun CODE="&amp;ERW" TEXTNO="001" TEXT_TYPE="S" FUN_TEXT="Manage..." PATH="M"/>
   <pfstatus_fun CODE="&amp;ETA" TEXTNO="001" TEXT_TYPE="S" TEXT_NAME="ICON_SELECT_DETAIL" ICON_ID="@16@" FUN_TEXT="Details"/>
   <pfstatus_fun CODE="&amp;F03" TEXTNO="001" TEXT_TYPE="S" FUN_TEXT="Back" PATH="B"/>
   <pfstatus_fun CODE="&amp;F12" TEXTNO="001" TEXT_TYPE="S" TEXT_NAME="ICON_CANCEL" ICON_ID="@0W@" FUN_TEXT="Cancel" PATH="A"/>
   <pfstatus_fun CODE="&amp;F15" TEXTNO="001" TEXT_TYPE="S" FUN_TEXT="Exit" PATH="X"/>
   <pfstatus_fun CODE="&amp;F4" TEXTNO="001" TEXT_TYPE="S" FUN_TEXT="Possible Entries"/>
   <pfstatus_fun CODE="&amp;GRAPH" TEXTNO="001" TEXT_TYPE="S" TEXT_NAME="ICON_GRAPHICS" ICON_ID="@0N@" FUN_TEXT="Graphic" PATH="G"/>
   <pfstatus_fun CODE="&amp;IC1" TEXTNO="001" TEXT_TYPE="S" TEXT_NAME="ICON_SELECT_DETAIL" ICON_ID="@16@" FUN_TEXT="Choose"/>
   <pfstatus_fun CODE="&amp;ILD" TEXTNO="001" TEXT_TYPE="S" TEXT_NAME="ICON_FILTER_UNDO" ICON_ID="@GD@" FUN_TEXT="Delete Filter" PATH="L"/>
   <pfstatus_fun CODE="&amp;ILT" TEXTNO="001" TEXT_TYPE="S" TEXT_NAME="ICON_FILTER" ICON_ID="@4G@" FUN_TEXT="Set Filter" PATH="F"/>
   <pfstatus_fun CODE="&amp;IMPORT" TEXTNO="001" TEXT_TYPE="S" TEXT_NAME="ICON_SCRAP" ICON_ID="@K3@" FUN_TEXT="Import Again" ICON_TEXT="Re-import" INFO_TEXT="Mark transport for re-import"/>
   <pfstatus_fun CODE="&amp;INFO" TEXTNO="001" TEXT_TYPE="S" TEXT_NAME="ICON_INFORMATION" ICON_ID="@0S@" FUN_TEXT="Information" ICON_TEXT="Info" INFO_TEXT="Information"/>
   <pfstatus_fun CODE="&amp;MAX" TEXTNO="001" TEXT_TYPE="S" FUN_TEXT="Maximum" PATH="A"/>
   <pfstatus_fun CODE="&amp;MIN" TEXTNO="001" TEXT_TYPE="S" FUN_TEXT="Minimum" PATH="I"/>
   <pfstatus_fun CODE="&amp;NCONF" TEXTNO="001" TEXT_TYPE="S" TEXT_NAME="ICON_NEXT_STEP" ICON_ID="@B8@" FUN_TEXT="Next Conflict" ICON_TEXT="Next Conflict" INFO_TEXT="Jump to the next conflict in the list"/>
   <pfstatus_fun CODE="&amp;OAD" TEXTNO="001" TEXT_TYPE="S" FUN_TEXT="Choose..." PATH="E"/>
   <pfstatus_fun CODE="&amp;OAD" TEXTNO="002" TEXT_TYPE="S" TEXT_NAME="ICON_ALV_VARIANT_CHOOSE" ICON_ID="@DM@" FUN_TEXT="Select Layout..."/>
   <pfstatus_fun CODE="&amp;ODN" TEXTNO="001" TEXT_TYPE="S" TEXT_NAME="ICON_SORT_DOWN" ICON_ID="@3F@" FUN_TEXT="Sort in Descending Order" PATH="O"/>
   <pfstatus_fun CODE="&amp;OL0" TEXTNO="001" TEXT_TYPE="S" TEXT_NAME="ICON_ALV_VARIANTS" ICON_ID="@LZ@" FUN_TEXT="Change Layout..."/>
   <pfstatus_fun CODE="&amp;OLX" TEXTNO="001" TEXT_TYPE="S" TEXT_NAME="ICON_VARIANTS" ICON_ID="@0R@" FUN_TEXT="Change..." PATH="C"/>
   <pfstatus_fun CODE="&amp;OPT" TEXTNO="001" TEXT_TYPE="S" FUN_TEXT="Optimize Width" PATH="P"/>
   <pfstatus_fun CODE="&amp;OUP" TEXTNO="001" TEXT_TYPE="S" TEXT_NAME="ICON_SORT_UP" ICON_ID="@3E@" FUN_TEXT="Sort in Ascending Order" PATH="I"/>
   <pfstatus_fun CODE="&amp;PREP_XLS" TEXTNO="001" TEXT_TYPE="S" TEXT_NAME="ICON_HISTORY" ICON_ID="@96@" FUN_TEXT="Simple list" ICON_TEXT="Simple list" INFO_TEXT="Display the list on Header level (no object info)"/>
   <pfstatus_fun CODE="&amp;REFRESH" TEXTNO="001" TEXT_TYPE="S" TEXT_NAME="ICON_REFRESH" ICON_ID="@42@" FUN_TEXT="Refresh"/>
   <pfstatus_fun CODE="&amp;RNT" TEXTNO="001" TEXT_TYPE="S" TEXT_NAME="ICON_PRINT" ICON_ID="@0X@" FUN_TEXT="Print" PATH="P"/>
   <pfstatus_fun CODE="&amp;RNT_PREV" TEXTNO="001" TEXT_TYPE="S" TEXT_NAME="ICON_LAYOUT_CONTROL" ICON_ID="@3G@" FUN_TEXT="Print Preview" PATH="R"/>
   <pfstatus_fun CODE="&amp;SAL" TEXTNO="001" TEXT_TYPE="S" TEXT_NAME="ICON_DESELECT_ALL" ICON_ID="@4D@" FUN_TEXT="Deselect All" PATH="D"/>
   <pfstatus_fun CODE="&amp;SAVE" TEXTNO="001" TEXT_TYPE="S" TEXT_NAME="ICON_SYSTEM_SAVE" ICON_ID="@2L@" FUN_TEXT="Save"/>
   <pfstatus_fun CODE="&amp;SUM" TEXTNO="001" TEXT_TYPE="S" TEXT_NAME="ICON_INTERMEDIATE_SUM" ICON_ID="@5V@" FUN_TEXT="Subtotals..." PATH="S"/>
   <pfstatus_fun CODE="&amp;UMC" TEXTNO="001" TEXT_TYPE="S" TEXT_NAME="ICON_SUM" ICON_ID="@3Z@" FUN_TEXT="Total" PATH="T"/>
   <pfstatus_fun CODE="&amp;VEXCEL" TEXTNO="001" TEXT_TYPE="S" TEXT_NAME="ICON_XLS" ICON_ID="@J2@" FUN_TEXT="Microsoft Excel" PATH="M"/>
   <pfstatus_fun CODE="&amp;VGRID" TEXTNO="001" TEXT_TYPE="S" FUN_TEXT="SAP List Viewer" PATH="S"/>
   <pfstatus_fun CODE="&amp;VLOTUS" TEXTNO="001" TEXT_TYPE="S" FUN_TEXT="Lotus 1-2-3" PATH="L"/>
   <pfstatus_fun CODE="&amp;XINT" TEXTNO="001" TEXT_TYPE="S" FUN_TEXT="Additional Functions of SAP Query" PATH="E"/>
   <pfstatus_fun CODE="&amp;XXL" TEXTNO="001" TEXT_TYPE="S" TEXT_NAME="ICON_XXL" ICON_ID="@DJ@" FUN_TEXT="Spreadsheet..." PATH="A"/>
   <pfstatus_fun CODE="DDIC" TEXTNO="001" TEXT_TYPE="S" TEXT_NAME="ICON_TIME_CONTROL" ICON_ID="@BH@" FUN_TEXT="Switch DDIC check ON" ICON_TEXT="DDIC Check" INFO_TEXT="Switch DDIC check ON (and perform initial run)"/>
   <pfstatus_fun CODE="EABR" TEXTNO="001" TYPE="S" TEXT_TYPE="S" TEXT_NAME="ICON_CANCEL" ICON_ID="@0W@" FUN_TEXT="Exit" PATH="A"/>
   <pfstatus_fun CODE="GOON" TEXTNO="001" TEXT_TYPE="S" TEXT_NAME="ICON_OKAY" ICON_ID="@0V@" FUN_TEXT="Continue"/>
   <pfstatus_fun CODE="RECHECK" TEXTNO="001" TEXT_TYPE="S" TEXT_NAME="ICON_EXECUTE_OBJECT" ICON_ID="@15@" FUN_TEXT="Recheck transports" ICON_TEXT="Recheck" INFO_TEXT="Recheck selected transports"/>
   <pfstatus_men CODE="000001" NO="01" REF_TYPE="F" REF_CODE="&amp;RNT_PREV" REF_NO="001"/>
   <pfstatus_men CODE="000001" NO="02" REF_TYPE="F" REF_CODE="&amp;RNT" REF_NO="001"/>
   <pfstatus_men CODE="000001" NO="03" REF_TYPE="S"/>
   <pfstatus_men CODE="000001" NO="04" REF_TYPE="M" REF_CODE="000002"/>
   <pfstatus_men CODE="000001" NO="05" REF_TYPE="M" REF_CODE="000003"/>
   <pfstatus_men CODE="000001" NO="06" REF_TYPE="S"/>
   <pfstatus_men CODE="000001" NO="07" REF_TYPE="F" REF_CODE="&amp;F15" REF_NO="001"/>
   <pfstatus_men CODE="000002" NO="01" REF_TYPE="F" REF_CODE="&amp;AQW" REF_NO="001"/>
   <pfstatus_men CODE="000002" NO="02" REF_TYPE="F" REF_CODE="&amp;XXL" REF_NO="001"/>
   <pfstatus_men CODE="000002" NO="03" REF_TYPE="F" REF_CODE="%PC" REF_NO="001"/>
   <pfstatus_men CODE="000002" NO="04" REF_TYPE="F" REF_CODE="&amp;XINT" REF_NO="001"/>
   <pfstatus_men CODE="000003" NO="01" REF_TYPE="F" REF_CODE="%SL" REF_NO="001"/>
   <pfstatus_men CODE="000003" NO="02" REF_TYPE="F" REF_CODE="%ML" REF_NO="001"/>
   <pfstatus_men CODE="000004" NO="01" REF_TYPE="F" REF_CODE="&amp;ALL" REF_NO="001"/>
   <pfstatus_men CODE="000004" NO="02" REF_TYPE="F" REF_CODE="&amp;SAL" REF_NO="001"/>
   <pfstatus_men CODE="000004" NO="03" REF_TYPE="S"/>
   <pfstatus_men CODE="000004" NO="04" REF_TYPE="F" REF_CODE="&amp;ILT" REF_NO="001"/>
   <pfstatus_men CODE="000004" NO="05" REF_TYPE="F" REF_CODE="&amp;ILD" REF_NO="001"/>
   <pfstatus_men CODE="000004" NO="06" REF_TYPE="S"/>
   <pfstatus_men CODE="000004" NO="07" REF_TYPE="F" REF_CODE="&amp;OUP" REF_NO="001"/>
   <pfstatus_men CODE="000004" NO="08" REF_TYPE="F" REF_CODE="&amp;ODN" REF_NO="001"/>
   <pfstatus_men CODE="000004" NO="09" REF_TYPE="S"/>
   <pfstatus_men CODE="000004" NO="10" REF_TYPE="M" REF_CODE="000005"/>
   <pfstatus_men CODE="000004" NO="11" REF_TYPE="F" REF_CODE="&amp;SUM" REF_NO="001"/>
   <pfstatus_men CODE="000004" NO="12" REF_TYPE="S"/>
   <pfstatus_men CODE="000004" NO="13" REF_TYPE="F" REF_CODE="%SC" REF_NO="001"/>
   <pfstatus_men CODE="000004" NO="14" REF_TYPE="S"/>
   <pfstatus_men CODE="000004" NO="15" REF_TYPE="F" REF_CODE="&amp;F12" REF_NO="001"/>
   <pfstatus_men CODE="000005" NO="01" REF_TYPE="F" REF_CODE="&amp;UMC" REF_NO="001"/>
   <pfstatus_men CODE="000005" NO="02" REF_TYPE="F" REF_CODE="&amp;AVR" REF_NO="001"/>
   <pfstatus_men CODE="000005" NO="03" REF_TYPE="F" REF_CODE="&amp;MIN" REF_NO="001"/>
   <pfstatus_men CODE="000005" NO="04" REF_TYPE="F" REF_CODE="&amp;MAX" REF_NO="001"/>
   <pfstatus_men CODE="000005" NO="05" REF_TYPE="F" REF_CODE="&amp;COUNT" REF_NO="001"/>
   <pfstatus_men CODE="000006" NO="01" REF_TYPE="F" REF_CODE="&amp;ABC" REF_NO="001"/>
   <pfstatus_men CODE="000006" NO="02" REF_TYPE="S"/>
   <pfstatus_men CODE="000006" NO="03" REF_TYPE="F" REF_CODE="&amp;F03" REF_NO="001"/>
   <pfstatus_men CODE="000007" NO="01" REF_TYPE="F" REF_CODE="&amp;VGRID" REF_NO="001"/>
   <pfstatus_men CODE="000007" NO="02" REF_TYPE="F" REF_CODE="&amp;VEXCEL" REF_NO="001"/>
   <pfstatus_men CODE="000007" NO="03" REF_TYPE="F" REF_CODE="&amp;VLOTUS" REF_NO="001"/>
   <pfstatus_men CODE="000007" NO="04" REF_TYPE="S"/>
   <pfstatus_men CODE="000007" NO="05" REF_TYPE="F" REF_CODE="&amp;GRAPH" REF_NO="001"/>
   <pfstatus_men CODE="000008" NO="01" REF_TYPE="M" REF_CODE="000009"/>
   <pfstatus_men CODE="000008" NO="02" REF_TYPE="M" REF_CODE="000010"/>
   <pfstatus_men CODE="000008" NO="03" REF_TYPE="F" REF_CODE="&amp;AUF" REF_NO="001"/>
   <pfstatus_men CODE="000009" NO="01" REF_TYPE="F" REF_CODE="&amp;OLX" REF_NO="001"/>
   <pfstatus_men CODE="000009" NO="02" REF_TYPE="F" REF_CODE="&amp;OAD" REF_NO="001"/>
   <pfstatus_men CODE="000009" NO="03" REF_TYPE="S"/>
   <pfstatus_men CODE="000009" NO="04" REF_TYPE="F" REF_CODE="&amp;AVE" REF_NO="001"/>
   <pfstatus_men CODE="000009" NO="05" REF_TYPE="S"/>
   <pfstatus_men CODE="000009" NO="06" REF_TYPE="F" REF_CODE="&amp;ERW" REF_NO="001"/>
   <pfstatus_men CODE="000010" NO="01" REF_TYPE="F" REF_CODE="&amp;OPT" REF_NO="001"/>
   <pfstatus_men CODE="000010" NO="02" REF_TYPE="S"/>
   <pfstatus_men CODE="000010" NO="03" REF_TYPE="F" REF_CODE="&amp;CFI" REF_NO="001"/>
   <pfstatus_men CODE="000010" NO="04" REF_TYPE="F" REF_CODE="&amp;CDF" REF_NO="001"/>
   <pfstatus_mtx CODE="000001" TEXT_TYPE="S" TEXT="List" PATH="I" INT_NOTE="Standard Supplement"/>
   <pfstatus_mtx CODE="000001" TEXT_TYPE="S" TEXT="List" PATH="I" INT_NOTE="Standard Supplement"/>
   <pfstatus_mtx CODE="000002" TEXT_TYPE="S" TEXT="Export" PATH="E" INT_NOTE="STANDARD Save"/>
   <pfstatus_mtx CODE="000003" TEXT_TYPE="S" TEXT="Send To" PATH="S"/>
   <pfstatus_mtx CODE="000004" TEXT_TYPE="S" TEXT="Edit" PATH="E" INT_NOTE="STANDARD"/>
   <pfstatus_mtx CODE="000005" TEXT_TYPE="S" TEXT="Calculate" PATH="C"/>
   <pfstatus_mtx CODE="000006" TEXT_TYPE="S" TEXT="Goto" PATH="G" INT_NOTE="STANDARD"/>
   <pfstatus_mtx CODE="000007" TEXT_TYPE="S" TEXT="Views" PATH="V"/>
   <pfstatus_mtx CODE="000008" TEXT_TYPE="S" TEXT="Settings" PATH="S" INT_NOTE="STANDARD_FULLSCREEN"/>
   <pfstatus_mtx CODE="000009" TEXT_TYPE="S" TEXT="Layout" PATH="A" INT_NOTE="Sub STANDARD"/>
   <pfstatus_mtx CODE="000010" TEXT_TYPE="S" TEXT="Columns" PATH="C"/>
   <pfstatus_act CODE="000001" NO="01" MENUCODE="000001"/>
   <pfstatus_act CODE="000001" NO="02" MENUCODE="000004"/>
   <pfstatus_act CODE="000001" NO="03" MENUCODE="000006"/>
   <pfstatus_act CODE="000001" NO="04" MENUCODE="000007"/>
   <pfstatus_act CODE="000001" NO="05" MENUCODE="000008"/>
   <pfstatus_but PFK_CODE="000001" CODE="0001" NO="01" PFNO="00"/>
   <pfstatus_but PFK_CODE="000001" CODE="0001" NO="02" PFNO="12"/>
   <pfstatus_but PFK_CODE="000001" CODE="0001" NO="03" PFNO="39"/>
   <pfstatus_but PFK_CODE="000001" CODE="0001" NO="04" PFNO="S"/>
   <pfstatus_but PFK_CODE="000001" CODE="0001" NO="05" PFNO="05"/>
   <pfstatus_but PFK_CODE="000001" CODE="0001" NO="06" PFNO="06"/>
   <pfstatus_but PFK_CODE="000001" CODE="0001" NO="07" PFNO="S"/>
   <pfstatus_but PFK_CODE="000001" CODE="0001" NO="08" PFNO="28"/>
   <pfstatus_but PFK_CODE="000001" CODE="0001" NO="09" PFNO="40"/>
   <pfstatus_but PFK_CODE="000001" CODE="0001" NO="10" PFNO="29"/>
   <pfstatus_but PFK_CODE="000001" CODE="0001" NO="11" PFNO="38"/>
   <pfstatus_but PFK_CODE="000001" CODE="0001" NO="12" PFNO="S"/>
   <pfstatus_but PFK_CODE="000001" CODE="0001" NO="13" PFNO="46"/>
   <pfstatus_but PFK_CODE="000001" CODE="0001" NO="14" PFNO="S"/>
   <pfstatus_but PFK_CODE="000001" CODE="0001" NO="15" PFNO="31"/>
   <pfstatus_but PFK_CODE="000001" CODE="0001" NO="16" PFNO="S"/>
   <pfstatus_but PFK_CODE="000001" CODE="0001" NO="17" PFNO="32"/>
   <pfstatus_but PFK_CODE="000001" CODE="0001" NO="18" PFNO="33"/>
   <pfstatus_but PFK_CODE="000001" CODE="0001" NO="19" PFNO="34"/>
   <pfstatus_but PFK_CODE="000001" CODE="0001" NO="20" PFNO="S"/>
   <pfstatus_but PFK_CODE="000001" CODE="0001" NO="21" PFNO="36"/>
   <pfstatus_but PFK_CODE="000001" CODE="0001" NO="22" PFNO="13"/>
   <pfstatus_but PFK_CODE="000001" CODE="0001" NO="23" PFNO="22"/>
   <pfstatus_but PFK_CODE="000001" CODE="0001" NO="24" PFNO="S"/>
   <pfstatus_but PFK_CODE="000001" CODE="0001" NO="25" PFNO="14"/>
   <pfstatus_but PFK_CODE="000001" CODE="0001" NO="26" PFNO="16"/>
   <pfstatus_but PFK_CODE="000001" CODE="0001" NO="27" PFNO="17"/>
   <pfstatus_but PFK_CODE="000001" CODE="0001" NO="28" PFNO="18"/>
   <pfstatus_but PFK_CODE="000001" CODE="0001" NO="29" PFNO="19"/>
   <pfstatus_but PFK_CODE="000001" CODE="0001" NO="30" PFNO="S"/>
   <pfstatus_but PFK_CODE="000001" CODE="0001" NO="31" PFNO="21"/>
   <pfstatus_but PFK_CODE="000001" CODE="0001" NO="32" PFNO="S"/>
   <pfstatus_but PFK_CODE="000001" CODE="0001" NO="33" PFNO="23"/>
   <pfstatus_pfk CODE="000001" PFNO="00" FUNCODE="GOON" FUNNO="001"/>
   <pfstatus_pfk CODE="000001" PFNO="00" FUNCODE="GOON" FUNNO="001"/>
   <pfstatus_pfk CODE="000001" PFNO="01" FUNCODE="&amp;ELP" FUNNO="001"/>
   <pfstatus_pfk CODE="000001" PFNO="02" FUNCODE="&amp;IC1" FUNNO="001"/>
   <pfstatus_pfk CODE="000001" PFNO="03" FUNCODE="&amp;F03" FUNNO="001"/>
   <pfstatus_pfk CODE="000001" PFNO="04" FUNCODE="&amp;F4" FUNNO="001"/>
   <pfstatus_pfk CODE="000001" PFNO="05" FUNCODE="&amp;ALL" FUNNO="001"/>
   <pfstatus_pfk CODE="000001" PFNO="06" FUNCODE="&amp;SAL" FUNNO="001"/>
   <pfstatus_pfk CODE="000001" PFNO="08" FUNCODE="&amp;REFRESH" FUNNO="001"/>
   <pfstatus_pfk CODE="000001" PFNO="11" FUNCODE="&amp;SAVE" FUNNO="001"/>
   <pfstatus_pfk CODE="000001" PFNO="12" FUNCODE="&amp;F12" FUNNO="001"/>
   <pfstatus_pfk CODE="000001" PFNO="12" FUNCODE="EABR" FUNNO="001"/>
   <pfstatus_pfk CODE="000001" PFNO="12" FUNCODE="EABR" FUNNO="001"/>
   <pfstatus_pfk CODE="000001" PFNO="13" FUNCODE="RECHECK" FUNNO="001"/>
   <pfstatus_pfk CODE="000001" PFNO="14" FUNCODE="&amp;ADD" FUNNO="001"/>
   <pfstatus_pfk CODE="000001" PFNO="15" FUNCODE="&amp;F15" FUNNO="001"/>
   <pfstatus_pfk CODE="000001" PFNO="16" FUNCODE="&amp;ADD_TP" FUNNO="001"/>
   <pfstatus_pfk CODE="000001" PFNO="17" FUNCODE="&amp;ADD_FILE" FUNNO="001"/>
   <pfstatus_pfk CODE="000001" PFNO="18" FUNCODE="&amp;DEL" FUNNO="001"/>
   <pfstatus_pfk CODE="000001" PFNO="19" FUNCODE="&amp;IMPORT" FUNNO="001"/>
   <pfstatus_pfk CODE="000001" PFNO="20" FUNCODE="&amp;DOC" FUNNO="001"/>
   <pfstatus_pfk CODE="000001" PFNO="21" FUNCODE="&amp;NCONF" FUNNO="001"/>
   <pfstatus_pfk CODE="000001" PFNO="22" FUNCODE="DDIC" FUNNO="001"/>
   <pfstatus_pfk CODE="000001" PFNO="23" FUNCODE="&amp;PREP_XLS" FUNNO="001"/>
   <pfstatus_pfk CODE="000001" PFNO="25" FUNCODE="&amp;ABC" FUNNO="001"/>
   <pfstatus_pfk CODE="000001" PFNO="28" FUNCODE="&amp;OUP" FUNNO="001"/>
   <pfstatus_pfk CODE="000001" PFNO="29" FUNCODE="&amp;ILT" FUNNO="001"/>
   <pfstatus_pfk CODE="000001" PFNO="30" FUNCODE="&amp;UMC" FUNNO="001"/>
   <pfstatus_pfk CODE="000001" PFNO="31" FUNCODE="%SL" FUNNO="001"/>
   <pfstatus_pfk CODE="000001" PFNO="32" FUNCODE="&amp;OL0" FUNNO="001"/>
   <pfstatus_pfk CODE="000001" PFNO="33" FUNCODE="&amp;OAD" FUNNO="002"/>
   <pfstatus_pfk CODE="000001" PFNO="34" FUNCODE="&amp;AVE" FUNNO="002"/>
   <pfstatus_pfk CODE="000001" PFNO="36" FUNCODE="&amp;INFO" FUNNO="001"/>
   <pfstatus_pfk CODE="000001" PFNO="37" FUNCODE="&amp;EB9" FUNNO="001"/>
   <pfstatus_pfk CODE="000001" PFNO="38" FUNCODE="&amp;ILD" FUNNO="001"/>
   <pfstatus_pfk CODE="000001" PFNO="39" FUNCODE="&amp;ETA" FUNNO="001"/>
   <pfstatus_pfk CODE="000001" PFNO="40" FUNCODE="&amp;ODN" FUNNO="001"/>
   <pfstatus_pfk CODE="000001" PFNO="42" FUNCODE="&amp;SUM" FUNNO="001"/>
   <pfstatus_pfk CODE="000001" PFNO="43" FUNCODE="&amp;VEXCEL" FUNNO="001"/>
   <pfstatus_pfk CODE="000001" PFNO="44" FUNCODE="&amp;AQW" FUNNO="001"/>
   <pfstatus_pfk CODE="000001" PFNO="45" FUNCODE="%PC" FUNNO="001"/>
   <pfstatus_pfk CODE="000001" PFNO="46" FUNCODE="&amp;RNT_PREV" FUNNO="001"/>
   <pfstatus_pfk CODE="000001" PFNO="47" FUNCODE="&amp;GRAPH" FUNNO="001"/>
   <pfstatus_pfk CODE="000001" PFNO="71" FUNCODE="%SC" FUNNO="001"/>
   <pfstatus_pfk CODE="000001" PFNO="84" FUNCODE="%SC+" FUNNO="001"/>
   <pfstatus_pfk CODE="000001" PFNO="86" FUNCODE="&amp;RNT" FUNNO="001"/>
   <pfstatus_set STATUS="STANDARD_FULLSCREEN" FUNCTION="%CH"/>
   <pfstatus_set STATUS="STANDARD_FULLSCREEN" FUNCTION="%ML"/>
   <pfstatus_set STATUS="STANDARD_FULLSCREEN" FUNCTION="%PC"/>
   <pfstatus_set STATUS="STANDARD_FULLSCREEN" FUNCTION="%SC"/>
   <pfstatus_set STATUS="STANDARD_FULLSCREEN" FUNCTION="%SC+"/>
   <pfstatus_set STATUS="STANDARD_FULLSCREEN" FUNCTION="%SL"/>
   <pfstatus_set STATUS="STANDARD_FULLSCREEN" FUNCTION="&amp;ABC"/>
   <pfstatus_set STATUS="STANDARD_FULLSCREEN" FUNCTION="&amp;ADD"/>
   <pfstatus_set STATUS="STANDARD_FULLSCREEN" FUNCTION="&amp;ADD_FILE"/>
   <pfstatus_set STATUS="STANDARD_FULLSCREEN" FUNCTION="&amp;ADD_TP"/>
   <pfstatus_set STATUS="STANDARD_FULLSCREEN" FUNCTION="&amp;ALL"/>
   <pfstatus_set STATUS="STANDARD_FULLSCREEN" FUNCTION="&amp;AQW"/>
   <pfstatus_set STATUS="STANDARD_FULLSCREEN" FUNCTION="&amp;AUF"/>
   <pfstatus_set STATUS="STANDARD_FULLSCREEN" FUNCTION="&amp;AVE"/>
   <pfstatus_set STATUS="STANDARD_FULLSCREEN" FUNCTION="&amp;AVR"/>
   <pfstatus_set STATUS="STANDARD_FULLSCREEN" FUNCTION="&amp;BS"/>
   <pfstatus_set STATUS="STANDARD_FULLSCREEN" FUNCTION="&amp;BS+"/>
   <pfstatus_set STATUS="STANDARD_FULLSCREEN" FUNCTION="&amp;BS-"/>
   <pfstatus_set STATUS="STANDARD_FULLSCREEN" FUNCTION="&amp;CDF"/>
   <pfstatus_set STATUS="STANDARD_FULLSCREEN" FUNCTION="&amp;CFI"/>
   <pfstatus_set STATUS="STANDARD_FULLSCREEN" FUNCTION="&amp;COUNT"/>
   <pfstatus_set STATUS="STANDARD_FULLSCREEN" FUNCTION="&amp;CRB"/>
   <pfstatus_set STATUS="STANDARD_FULLSCREEN" FUNCTION="&amp;CRBATCH"/>
   <pfstatus_set STATUS="STANDARD_FULLSCREEN" FUNCTION="&amp;CRDESIG"/>
   <pfstatus_set STATUS="STANDARD_FULLSCREEN" FUNCTION="&amp;CRE"/>
   <pfstatus_set STATUS="STANDARD_FULLSCREEN" FUNCTION="&amp;CRL"/>
   <pfstatus_set STATUS="STANDARD_FULLSCREEN" FUNCTION="&amp;CRR"/>
   <pfstatus_set STATUS="STANDARD_FULLSCREEN" FUNCTION="&amp;CRTEMPL"/>
   <pfstatus_set STATUS="STANDARD_FULLSCREEN" FUNCTION="&amp;CRYSTAL"/>
   <pfstatus_set STATUS="STANDARD_FULLSCREEN" FUNCTION="&amp;DAU"/>
   <pfstatus_set STATUS="STANDARD_FULLSCREEN" FUNCTION="&amp;DEL"/>
   <pfstatus_set STATUS="STANDARD_FULLSCREEN" FUNCTION="&amp;DOC"/>
   <pfstatus_set STATUS="STANDARD_FULLSCREEN" FUNCTION="&amp;DOF"/>
   <pfstatus_set STATUS="STANDARD_FULLSCREEN" FUNCTION="&amp;DON"/>
   <pfstatus_set STATUS="STANDARD_FULLSCREEN" FUNCTION="&amp;EB3"/>
   <pfstatus_set STATUS="STANDARD_FULLSCREEN" FUNCTION="&amp;EB9"/>
   <pfstatus_set STATUS="STANDARD_FULLSCREEN" FUNCTION="&amp;ELP"/>
   <pfstatus_set STATUS="STANDARD_FULLSCREEN" FUNCTION="&amp;ERW"/>
   <pfstatus_set STATUS="STANDARD_FULLSCREEN" FUNCTION="&amp;ETA"/>
   <pfstatus_set STATUS="STANDARD_FULLSCREEN" FUNCTION="&amp;F03"/>
   <pfstatus_set STATUS="STANDARD_FULLSCREEN" FUNCTION="&amp;F12"/>
   <pfstatus_set STATUS="STANDARD_FULLSCREEN" FUNCTION="&amp;F15"/>
   <pfstatus_set STATUS="STANDARD_FULLSCREEN" FUNCTION="&amp;F4"/>
   <pfstatus_set STATUS="STANDARD_FULLSCREEN" FUNCTION="&amp;GRAPH"/>
   <pfstatus_set STATUS="STANDARD_FULLSCREEN" FUNCTION="&amp;IC1"/>
   <pfstatus_set STATUS="STANDARD_FULLSCREEN" FUNCTION="&amp;ILD"/>
   <pfstatus_set STATUS="STANDARD_FULLSCREEN" FUNCTION="&amp;ILT"/>
   <pfstatus_set STATUS="STANDARD_FULLSCREEN" FUNCTION="&amp;IMPORT"/>
   <pfstatus_set STATUS="STANDARD_FULLSCREEN" FUNCTION="&amp;INFO"/>
   <pfstatus_set STATUS="STANDARD_FULLSCREEN" FUNCTION="&amp;KOM"/>
   <pfstatus_set STATUS="STANDARD_FULLSCREEN" FUNCTION="&amp;LFO"/>
   <pfstatus_set STATUS="STANDARD_FULLSCREEN" FUNCTION="&amp;LIS"/>
   <pfstatus_set STATUS="STANDARD_FULLSCREEN" FUNCTION="&amp;MAX"/>
   <pfstatus_set STATUS="STANDARD_FULLSCREEN" FUNCTION="&amp;MIN"/>
   <pfstatus_set STATUS="STANDARD_FULLSCREEN" FUNCTION="&amp;NCONF"/>
   <pfstatus_set STATUS="STANDARD_FULLSCREEN" FUNCTION="&amp;NFO"/>
   <pfstatus_set STATUS="STANDARD_FULLSCREEN" FUNCTION="&amp;NTE"/>
   <pfstatus_set STATUS="STANDARD_FULLSCREEN" FUNCTION="&amp;OAD"/>
   <pfstatus_set STATUS="STANDARD_FULLSCREEN" FUNCTION="&amp;ODN"/>
   <pfstatus_set STATUS="STANDARD_FULLSCREEN" FUNCTION="&amp;OL0"/>
   <pfstatus_set STATUS="STANDARD_FULLSCREEN" FUNCTION="&amp;OLX"/>
   <pfstatus_set STATUS="STANDARD_FULLSCREEN" FUNCTION="&amp;OMP"/>
   <pfstatus_set STATUS="STANDARD_FULLSCREEN" FUNCTION="&amp;OPT"/>
   <pfstatus_set STATUS="STANDARD_FULLSCREEN" FUNCTION="&amp;OUP"/>
   <pfstatus_set STATUS="STANDARD_FULLSCREEN" FUNCTION="&amp;PREP_XLS"/>
   <pfstatus_set STATUS="STANDARD_FULLSCREEN" FUNCTION="&amp;REFRESH"/>
   <pfstatus_set STATUS="STANDARD_FULLSCREEN" FUNCTION="&amp;RNT"/>
   <pfstatus_set STATUS="STANDARD_FULLSCREEN" FUNCTION="&amp;RNT_PREV"/>
   <pfstatus_set STATUS="STANDARD_FULLSCREEN" FUNCTION="&amp;SAL"/>
   <pfstatus_set STATUS="STANDARD_FULLSCREEN" FUNCTION="&amp;SAVE"/>
   <pfstatus_set STATUS="STANDARD_FULLSCREEN" FUNCTION="&amp;SUM"/>
   <pfstatus_set STATUS="STANDARD_FULLSCREEN" FUNCTION="&amp;UMC"/>
   <pfstatus_set STATUS="STANDARD_FULLSCREEN" FUNCTION="&amp;URL"/>
   <pfstatus_set STATUS="STANDARD_FULLSCREEN" FUNCTION="&amp;VCRYSTAL"/>
   <pfstatus_set STATUS="STANDARD_FULLSCREEN" FUNCTION="&amp;VEXCEL"/>
   <pfstatus_set STATUS="STANDARD_FULLSCREEN" FUNCTION="&amp;VGRID"/>
   <pfstatus_set STATUS="STANDARD_FULLSCREEN" FUNCTION="&amp;VLOTUS"/>
   <pfstatus_set STATUS="STANDARD_FULLSCREEN" FUNCTION="&amp;XINT"/>
   <pfstatus_set STATUS="STANDARD_FULLSCREEN" FUNCTION="&amp;XML"/>
   <pfstatus_set STATUS="STANDARD_FULLSCREEN" FUNCTION="&amp;XPA"/>
   <pfstatus_set STATUS="STANDARD_FULLSCREEN" FUNCTION="&amp;XXL"/>
   <pfstatus_set STATUS="STANDARD_FULLSCREEN" FUNCTION="BAC1"/>
   <pfstatus_set STATUS="STANDARD_FULLSCREEN" FUNCTION="BACK"/>
   <pfstatus_set STATUS="STANDARD_FULLSCREEN" FUNCTION="BEB1"/>
   <pfstatus_set STATUS="STANDARD_FULLSCREEN" FUNCTION="BEB2"/>
   <pfstatus_set STATUS="STANDARD_FULLSCREEN" FUNCTION="BEB3"/>
   <pfstatus_set STATUS="STANDARD_FULLSCREEN" FUNCTION="BEB9"/>
   <pfstatus_set STATUS="STANDARD_FULLSCREEN" FUNCTION="BEBN"/>
   <pfstatus_set STATUS="STANDARD_FULLSCREEN" FUNCTION="COL0"/>
   <pfstatus_set STATUS="STANDARD_FULLSCREEN" FUNCTION="COLX"/>
   <pfstatus_set STATUS="STANDARD_FULLSCREEN" FUNCTION="DDIC"/>
   <pfstatus_set STATUS="STANDARD_FULLSCREEN" FUNCTION="DETA"/>
   <pfstatus_set STATUS="STANDARD_FULLSCREEN" FUNCTION="DRUK"/>
   <pfstatus_set STATUS="STANDARD_FULLSCREEN" FUNCTION="DSAL"/>
   <pfstatus_set STATUS="STANDARD_FULLSCREEN" FUNCTION="ENTE"/>
   <pfstatus_set STATUS="STANDARD_FULLSCREEN" FUNCTION="EXIT"/>
   <pfstatus_set STATUS="STANDARD_FULLSCREEN" FUNCTION="EXPA"/>
   <pfstatus_set STATUS="STANDARD_FULLSCREEN" FUNCTION="FILD"/>
   <pfstatus_set STATUS="STANDARD_FULLSCREEN" FUNCTION="FILT"/>
   <pfstatus_set STATUS="STANDARD_FULLSCREEN" FUNCTION="GLIS"/>
   <pfstatus_set STATUS="STANDARD_FULLSCREEN" FUNCTION="GOON"/>
   <pfstatus_set STATUS="STANDARD_FULLSCREEN" FUNCTION="HELP"/>
   <pfstatus_set STATUS="STANDARD_FULLSCREEN" FUNCTION="INFO"/>
   <pfstatus_set STATUS="STANDARD_FULLSCREEN" FUNCTION="KOMP"/>
   <pfstatus_set STATUS="STANDARD_FULLSCREEN" FUNCTION="P+"/>
   <pfstatus_set STATUS="STANDARD_FULLSCREEN" FUNCTION="P++"/>
   <pfstatus_set STATUS="STANDARD_FULLSCREEN" FUNCTION="P-"/>
   <pfstatus_set STATUS="STANDARD_FULLSCREEN" FUNCTION="P--"/>
   <pfstatus_set STATUS="STANDARD_FULLSCREEN" FUNCTION="PF09"/>
   <pfstatus_set STATUS="STANDARD_FULLSCREEN" FUNCTION="PF13"/>
   <pfstatus_set STATUS="STANDARD_FULLSCREEN" FUNCTION="PIC1"/>
   <pfstatus_set STATUS="STANDARD_FULLSCREEN" FUNCTION="PICK"/>
   <pfstatus_set STATUS="STANDARD_FULLSCREEN" FUNCTION="PRI"/>
   <pfstatus_set STATUS="STANDARD_FULLSCREEN" FUNCTION="PRIN"/>
   <pfstatus_set STATUS="STANDARD_FULLSCREEN" FUNCTION="PRNT"/>
   <pfstatus_set STATUS="STANDARD_FULLSCREEN" FUNCTION="RECHECK"/>
   <pfstatus_set STATUS="STANDARD_FULLSCREEN" FUNCTION="RW"/>
   <pfstatus_set STATUS="STANDARD_FULLSCREEN" FUNCTION="SALL"/>
   <pfstatus_set STATUS="STANDARD_FULLSCREEN" FUNCTION="SAUF"/>
   <pfstatus_set STATUS="STANDARD_FULLSCREEN" FUNCTION="SAVE"/>
   <pfstatus_set STATUS="STANDARD_FULLSCREEN" FUNCTION="SCRB"/>
   <pfstatus_set STATUS="STANDARD_FULLSCREEN" FUNCTION="SCRE"/>
   <pfstatus_set STATUS="STANDARD_FULLSCREEN" FUNCTION="SCRL"/>
   <pfstatus_set STATUS="STANDARD_FULLSCREEN" FUNCTION="SCRR"/>
   <pfstatus_set STATUS="STANDARD_FULLSCREEN" FUNCTION="SKOM"/>
   <pfstatus_set STATUS="STANDARD_FULLSCREEN" FUNCTION="SODN"/>
   <pfstatus_set STATUS="STANDARD_FULLSCREEN" FUNCTION="SOUP"/>
   <pfstatus_set STATUS="STANDARD_FULLSCREEN" FUNCTION="SUMC"/>
   <pfstatus_set STATUS="STANDARD_FULLSCREEN" FUNCTION="ZSUM"/>
   <pfstatus_doc OBJ_TYPE="A" OBJ_CODE="000001" MODAL="D" INT_NOTE="STANDARD_FULLSCREEN"/>
   <pfstatus_doc OBJ_TYPE="P" OBJ_CODE="000001" MODAL="P" INT_NOTE="STANDARD_FULLSCREEN"/>
   <pfstatus_doc OBJ_TYPE="B" OBJ_CODE="000001" SUB_CODE="0001" MODAL="P" INT_NOTE="STANDARD_FULLSCREEN"/>
   <pfstatus_tit CODE="001" TEXT="Transport Checking Tool (Object level) - Version &amp;1"/>
  </pfstatus>
  <source>REPORT  zev_tp_checktool.
*&amp;******************************************************************&amp;*
*&amp; Report   : ZEV_TP_CHECKTOOL                                      &amp;*
*&amp; Version  : 1.00                                                  &amp;*
*&amp; Author   : Edwin VLEESHOUWERS                                    &amp;*
*&amp; Function : Development Consultant                                &amp;*
*&amp; Date     : 23.01.2012                                            &amp;*
*&amp;------------------------------------------------------------------&amp;*
*&amp; Program Details                                                  &amp;*
*&amp;------------------------------------------------------------------&amp;*
*&amp; Title    : Transport checking tool (on object level)             &amp;*
*&amp; Purpose  : Check transport objects before moving to production   &amp;*
*&amp;------------------------------------------------------------------&amp;*
*
*--------------------------------------------------------------------*
* PLEASE NOTE:
* This program is designed to be used for a THREE-TIER system.
*
*--------------------------------------------------------------------*
* INSTALLATION
*--------------------------------------------------------------------*
* Code Exchange link: https://cw.sdn.sap.com/cw/groups/ztct
*
* Use SAPLINK to import the Nugget file (located under Releases).
* This will only install a local program (R3TR PROG: this includes
* report texts and program documentation.
*
*&amp;------------------------------------------------------------------&amp;*
*&amp; Change History                                                   &amp;*
*&amp;------------------------------------------------------------------&amp;*
TYPE-POOLS: ctslg, &quot;Types for Function Group TR_LOG_OVERVIEW
            icon,  &quot;Assignment: Icon Names in List of ASCII Codes
            slis,  &quot;Global types for generic list modules
            stms,  &quot;Transport Management System: Global Types
            abap.

* Class for handling Events
CLASS: lcl_eventhandler_ztct DEFINITION DEFERRED.
CLASS: lcl_ztct              DEFINITION DEFERRED.

DATA: e070       TYPE e070,       &quot;CTS: Header
      e071       TYPE e071,       &quot;CTS: Object Entries Requests/Task
      vrsd       TYPE vrsd,       &quot;Version management: directory table
      ctsproject TYPE ctsproject. &quot;Assignm. of CTS Proj. to Ext. Proj.

*--------------------------------------------------------------------*
* Data definitions
*--------------------------------------------------------------------*
* Database tables:
TABLES: sscrfields.      &quot;Fields on selection screens
CONSTANTS:
       co_months               TYPE numc3        VALUE &apos;012&apos;.

DATA:  ra_project_trkorrs      TYPE RANGE OF ctsproject-trkorr.
DATA:  st_project_trkorrs      LIKE LINE  OF ra_project_trkorrs.
DATA:  ra_systems              TYPE RANGE OF tmscsys-sysnam.
DATA:  st_systems              LIKE LINE  OF ra_systems.

* Global data declarations:
DATA:  tp_prefix               TYPE char5.
DATA:  ta_sapsystems           TYPE TABLE OF tmscsys,
       st_sapsystems           TYPE tmscsys.
DATA:  st_smp_dyntxt           TYPE smp_dyntxt.
DATA:  tp_dokl_object          TYPE doku_obj. &quot;To check existence of doc

DATA:  ta_trkorr_range         TYPE RANGE OF e070-trkorr.
DATA:  st_trkorr_range         LIKE LINE OF ta_trkorr_range.
DATA:  ta_project_range        TYPE RANGE OF ctsproject-trkorr.
DATA:  ta_date_range           TYPE RANGE OF as4date.
DATA:  ta_excluded_objects     TYPE RANGE OF trobj_name.
DATA:  tp_transport_descr      TYPE as4text.
DATA:  tp_project_reference    TYPE trvalue.
* Process type is used to identify if a list is build (1),
* uploaded (2) or the program is used for version checking (3)
DATA:  tp_process_type         TYPE i.
* Date from for transport collection (passed to class)
DATA:  tp_date_from             TYPE as4date.
* To determine transport track on selection screen
DATA:  ta_prev_systems         TYPE tmscsyss.
DATA:  st_prev_system          TYPE tmscsys.
DATA:  ta_system_track         TYPE tcesys.
DATA:  st_system_track         TYPE sysname.
DATA:  ta_targets              TYPE trsysclis.
DATA:  st_target               TYPE trsyscli.
DATA:  tp_sysname              TYPE sysname.
DATA:  tp_index                TYPE sytabix.

*--------------------------------------------------------------------*
* Data - ALV
*--------------------------------------------------------------------*
* Declaration for ALV Grid
DATA: rf_table                TYPE REF TO cl_salv_table.
DATA: rf_table_xls            TYPE REF TO cl_salv_table.
DATA: rf_conflicts            TYPE REF TO cl_salv_table.
DATA: rf_table_keys           TYPE REF TO cl_salv_table.
DATA: rf_handle_events        TYPE REF TO lcl_eventhandler_ztct.
DATA: rf_events_table         TYPE REF TO cl_salv_events_table.

* Exception handling
DATA: rf_root                 TYPE REF TO cx_root.
DATA: rf_ztct                 TYPE REF TO lcl_ztct.

*----------------------------------------------------------------------*
*       CLASS lcl_eventhandler_ztct DEFINITION
*----------------------------------------------------------------------*
CLASS lcl_eventhandler_ztct DEFINITION FRIENDS lcl_ztct.

  PUBLIC SECTION.
    CLASS-DATA:
      rf_conflicts  TYPE REF TO cl_salv_table,
      rf_table_keys TYPE REF TO cl_salv_table.

    CLASS-METHODS on_function_click
      FOR EVENT if_salv_events_functions~added_function
        OF cl_salv_events_table IMPORTING e_salv_function.

    CLASS-METHODS: on_double_click
      FOR EVENT double_click
        OF cl_salv_events_table IMPORTING row column.

    CLASS-METHODS: on_link_click
      FOR EVENT link_click
        OF cl_salv_events_table IMPORTING row column.

    CLASS-METHODS: on_double_click_popup
      FOR EVENT double_click
        OF cl_salv_events_table IMPORTING row column.

    CLASS-METHODS: on_link_click_popup
      FOR EVENT link_click
        OF cl_salv_events_table IMPORTING row column.

ENDCLASS.                    &quot;lcl_eventhandler_ztct DEFINITION

*----------------------------------------------------------------------*
*       CLASS lcl_ztct DEFINITION
*----------------------------------------------------------------------*
CLASS lcl_ztct DEFINITION FRIENDS lcl_eventhandler_ztct.

  PUBLIC SECTION.

    TYPES: ra_trkorr                 TYPE RANGE OF trkorr.
    TYPES: ra_excluded_objects       TYPE RANGE OF trobj_name.
    TYPES: ra_date                   TYPE RANGE OF as4date.
    DATA:  ls_excluded_objects       LIKE LINE  OF ta_excluded_objects.
    TYPES: BEGIN OF ty_request_details,
                      trkorr         TYPE trkorr,
                      checked        TYPE icon_l4,
                      info           TYPE icon_l4,
                      tr_descr       TYPE as4text,
                      dev            TYPE icon_l4,
                      qas            TYPE icon_l4,
                      retcode        TYPE char04,
                      prd            TYPE icon_l4,
                      warning_lvl    TYPE icon_d,
*                     Warning_rank: The higher the number,
*                     the more serious the error
                      warning_rank   TYPE numc4,
                      warning_txt    TYPE text74,
                      object         TYPE trobjtype,
                      obj_name       TYPE trobj_name,
                      objkey         TYPE trobj_name,
                      keyobject      TYPE trobjtype,
                      keyobjname     TYPE tabname,
                      tabkey         TYPE tabkey,
                      checked_by     TYPE syuname,
                      as4date        TYPE as4date,
                      as4time        TYPE as4time,
                      as4user        TYPE as4user,
                      status_text    TYPE char20,
                      trfunction_txt TYPE val_text,
                      project        TYPE cts_id,
                      project_descr  TYPE as4text,
                      objfunc        TYPE objfunc,
                      flag           TYPE flag,
                      trstatus       TYPE trstatus,
                      trfunction     TYPE trfunction.
    TYPES:            t_color        TYPE lvc_t_scol,
           END OF  ty_request_details.

    TYPES: tt_request_details TYPE STANDARD TABLE OF ty_request_details
                              WITH DEFAULT KEY.

    TYPES: BEGIN OF lty_tables_with_keys,
             tabname  TYPE trobj_name,
             counter  TYPE lvc_outlen,
             ddtext   TYPE as4text,
           END OF lty_tables_with_keys.
    DATA: table_keys      TYPE TABLE OF lty_tables_with_keys.
    DATA: table_keys_line TYPE lty_tables_with_keys.

    CONSTANTS:
      co_info             TYPE icon_d       VALUE &apos;@0S@&apos;. &quot;ICON_INFORMATION

*   Attributes
    DATA:  main_list                  TYPE tt_request_details.
    DATA:  main_list_line             TYPE ty_request_details.
    DATA:  main_list_xls              TYPE tt_request_details.
    DATA:  main_list_line_xls         TYPE ty_request_details.
    DATA:  conflicts                  TYPE tt_request_details.
    DATA:  st_request      TYPE ctslg_request_info.
    DATA:  st_steps        TYPE ctslg_step.
    DATA:  st_actions      TYPE ctslg_action.
    DATA:  tp_tabkey       TYPE trobj_name.
    DATA:  tp_lines        TYPE i.
    DATA:  tp_tab          TYPE char1
                                VALUE cl_abap_char_utilities=&gt;horizontal_tab.
    DATA: lp_save_restriction TYPE salv_de_layout_restriction.

*   Methods
    METHODS: constructor.
    METHODS: execute.
    METHODS: refresh_alv.
    METHODS: get_tp_prefix            IMPORTING im_dev              TYPE sysname   OPTIONAL
                                      RETURNING value(re_tp_prefix) TYPE char5.
    METHODS: get_filename             EXPORTING ex_file             TYPE localfile.
    METHODS: handle_error             IMPORTING rf_oref             TYPE REF TO cx_root.
    METHODS: set_check_flag           IMPORTING im_check_flag       TYPE abap_bool OPTIONAL.
    METHODS: set_check_ddic           IMPORTING im_check_ddic       TYPE abap_bool OPTIONAL.
    METHODS: set_check_tabkeys        IMPORTING im_check_tabkeys    TYPE abap_bool OPTIONAL.
    METHODS: set_clear_checked        IMPORTING im_clear_checked    TYPE abap_bool OPTIONAL.
    METHODS: set_skip_buffer_chk      IMPORTING im_skip_buffer_chk  TYPE abap_bool OPTIONAL.
    METHODS: set_trkorr_range         IMPORTING im_trkorr_range     TYPE ra_trkorr OPTIONAL.
    METHODS: set_project_range        IMPORTING im_project_range    TYPE ra_trkorr OPTIONAL.
    METHODS: set_date_range           IMPORTING im_date_range       TYPE ra_date   OPTIONAL.
    METHODS: set_excluded_objects     IMPORTING im_excluded_objects TYPE ra_excluded_objects OPTIONAL.
    METHODS: set_search_string        IMPORTING im_search_string    TYPE as4text   OPTIONAL.
    METHODS: set_user_layout          IMPORTING im_user_layout      TYPE abap_bool OPTIONAL.
    METHODS: set_process_type         IMPORTING im_process_type     TYPE i.
    METHODS: set_skiplive             IMPORTING im_skiplive         TYPE abap_bool OPTIONAL.
    METHODS: set_filename             IMPORTING im_filename         TYPE localfile OPTIONAL.
    METHODS: set_systems              IMPORTING im_dev_system       TYPE sysname
                                                im_qas_system       TYPE sysname
                                                im_prd_system       TYPE sysname.
    METHODS: set_building_conflict_popup IMPORTING im_building_conflict_popup TYPE abap_bool OPTIONAL.
    METHODS: go_back_months           IMPORTING im_backmonths	      TYPE numc3
                                                im_currdate         TYPE sydatum
                                      RETURNING value(re_date)      TYPE sydatum.

  PRIVATE SECTION.
    TYPES: BEGIN OF ty_ddic_e071,
             trkorr   TYPE trkorr,
             pgmid    TYPE pgmid,
             object   TYPE trobjtype,
             obj_name TYPE trobj_name,
           END OF ty_ddic_e071.
    TYPES: tt_ddic_e071 TYPE STANDARD TABLE OF ty_ddic_e071.
    DATA:  ta_ddic_e071 TYPE tt_ddic_e071.
    CONSTANTS:
      co_error           TYPE icon_d       VALUE &apos;@F1@&apos;, &quot;ICON_LED_RED
      co_ddic            TYPE icon_d       VALUE &apos;@CY@&apos;, &quot;ICON_INCOMPLETE
      co_warn            TYPE icon_d       VALUE &apos;@5D@&apos;, &quot;ICON_LED_YELLOW
      co_okay            TYPE icon_d       VALUE &apos;@5B@&apos;, &quot;ICON_LED_GREEN
      co_checked         TYPE icon_d       VALUE &apos;@01@&apos;, &quot;ICON_CHECKED
      co_hint            TYPE icon_d       VALUE &apos;@AI@&apos;, &quot;ICON_HINT
      co_alert           TYPE icon_d       VALUE &apos;@03@&apos;, &quot;ICON_FAILURE
      co_scrap           TYPE icon_d       VALUE &apos;@K3@&apos;, &quot;ICON_SCRAP
      co_docu            TYPE icon_d       VALUE &apos;@DH@&apos;, &quot;ICON_PROTOCOL
      co_inact           TYPE icon_d       VALUE &apos;@BZ@&apos;. &quot;ICON_LED_INACTIVE
    CONSTANTS:
      co_okay_rank       TYPE i            VALUE 0,  &quot;ICON_LED_GREEN
      co_alert0_rank     TYPE i            VALUE 5,  &quot;ICON_FAILURE
      co_alert1_rank     TYPE i            VALUE 6,  &quot;ICON_FAILURE
      co_alert2_rank     TYPE i            VALUE 7,  &quot;ICON_FAILURE
      co_alert3_rank     TYPE i            VALUE 8,  &quot;ICON_FAILURE
      co_hint1_rank      TYPE i            VALUE 10, &quot;ICON_HINT
      co_hint2_rank      TYPE i            VALUE 12, &quot;ICON_HINT
      co_hint3_rank      TYPE i            VALUE 14, &quot;ICON_HINT
      co_hint4_rank      TYPE i            VALUE 16, &quot;ICON_HINT
      co_info_rank       TYPE i            VALUE 20, &quot;ICON_INFORMATION
      co_warn_rank       TYPE i            VALUE 50, &quot;ICON_LED_YELLOW
      co_ddic_rank       TYPE i            VALUE 98, &quot;ICON_INCOMPLETE
      co_error_rank      TYPE i            VALUE 99. &quot;ICON_LED_RED
    CONSTANTS:
      co_non_charlike    TYPE string       VALUE &apos;h&apos;.

    DATA: lp_alert0_text TYPE text74.
    DATA: lp_alert1_text TYPE text74.
    DATA: lp_alert2_text TYPE text74.
    DATA: lp_alert3_text TYPE text74.
    DATA: lp_hint1_text  TYPE text74.
    DATA: lp_hint2_text  TYPE text74.
    DATA: lp_hint3_text  TYPE text74.
    DATA: lp_hint4_text  TYPE text74.
    DATA: lp_info_text   TYPE text74.
    DATA: lp_warn_text   TYPE text74.
    DATA: lp_error_text  TYPE text74.
    DATA: lp_ddic_text TYPE text74.

* Attributes
    DATA:  project_trkorrs            TYPE ra_trkorr.
    DATA:  prefix                     TYPE char5.
    DATA:  aggr_tp_list_of_objects    TYPE tt_request_details.
    DATA:  add_to_main                TYPE tt_request_details.
    DATA:  tab_delimited              TYPE table_of_strings.
    DATA:  conflict_line              TYPE ty_request_details.
    DATA:  line_found_in_list         TYPE ty_request_details.
    DATA:  total(10)                  TYPE n.
    DATA:  ddic_objects               TYPE string_table.
    DATA:  ddic_e071                  TYPE tt_ddic_e071.
    DATA:  ddic_e071_line             TYPE ty_ddic_e071.
    DATA:  where_used                 TYPE sci_findlst.
    DATA:  where_used_line            TYPE rsfindlst.
    DATA:  check_flag                 TYPE abap_bool.
    DATA:  check_ddic                 TYPE abap_bool.
    DATA:  check_tabkeys              TYPE abap_bool.
    DATA:  clear_checked              TYPE abap_bool.
    DATA:  skip_buffer_chk            TYPE abap_bool.
    DATA:  trkorr_range               TYPE ra_trkorr.
    DATA:  project_range              TYPE ra_trkorr.
    DATA:  date_range                 TYPE ra_date.
    DATA:  excluded_objects           TYPE ra_excluded_objects.
    DATA:  search_string              TYPE as4text.
    DATA:  user_layout                TYPE abap_bool.
    DATA:  process_type               TYPE i.
    DATA:  skiplive                   TYPE abap_bool.
    DATA:  filename                   TYPE string.
    DATA:  dev_system                 TYPE sysname.
    DATA:  qas_system                 TYPE sysname.
    DATA:  prd_system                 TYPE sysname.
    DATA:  tooltips                   TYPE REF TO cl_salv_tooltips.
    DATA:  building_conflict_popup    TYPE flag.

    METHODS: refresh_import_queues.
    METHODS: flag_for_process         IMPORTING rows                TYPE salv_t_row
                                                cell                TYPE salv_s_cell.
    METHODS: get_main_transports      IMPORTING im_trkorr_range     TYPE gtabkey_trkorrt.
    METHODS: get_tp_info              IMPORTING im_trkorr           TYPE trkorr
                                                im_obj_name         TYPE trobj_name
                                      RETURNING value(re_line)      TYPE ty_request_details.
    METHODS: get_added_objects        IMPORTING im_to_add           TYPE ra_trkorr
                                      EXPORTING ex_to_add           TYPE tt_request_details.
    METHODS: add_to_list              IMPORTING im_to_add           TYPE tt_request_details
                                      EXPORTING ex_main             TYPE tt_request_details.
    METHODS: build_conflict_popup     IMPORTING rows                TYPE salv_t_row
                                                cell                TYPE salv_s_cell.
    METHODS: delete_tp_from_list      IMPORTING rows                TYPE salv_t_row
                                                cell                TYPE salv_s_cell.
    METHODS: flag_same_objects        EXPORTING ex_main_list        TYPE tt_request_details.
    METHODS: mark_all_tp_records      IMPORTING im_cell             TYPE salv_s_cell
                                      CHANGING  im_rows             TYPE salv_t_row.
    METHODS: main_to_tab_delimited    IMPORTING im_main_list        TYPE tt_request_details
                                      EXPORTING ex_tab_delimited    TYPE table_of_strings.
    METHODS: tab_delimited_to_main    IMPORTING im_tab_delimited    TYPE table_of_strings
                                      EXPORTING ex_main_list        TYPE tt_request_details.
    METHODS: display_transport        IMPORTING im_trkorr           TYPE trkorr.
    METHODS: display_user             IMPORTING im_user             TYPE syuname.
    METHODS: display_docu             IMPORTING im_trkorr           TYPE trkorr.
    METHODS: check_if_in_list         IMPORTING im_line             TYPE ty_request_details
                                                im_tabix            TYPE sytabix
                                      EXPORTING ex_line             TYPE ty_request_details.
    METHODS: check_documentation      IMPORTING im_trkorr           TYPE trkorr
                                      CHANGING  ch_table            TYPE tt_request_details.
    METHODS: docu_call                IMPORTING im_object           TYPE doku_obj.
    METHODS: clear_flags.
    METHODS: column_settings          IMPORTING im_column_ref       TYPE salv_t_column_ref
                                                im_rf_columns_table TYPE REF TO cl_salv_columns_table
                                                im_table            TYPE REF TO cl_salv_table.
    METHODS: is_empty_column          IMPORTING im_column           TYPE lvc_fname
                                                im_table            TYPE tt_request_details
                                      RETURNING value(re_is_empty)  TYPE abap_bool.
*    METHODS: refresh_alv.
    METHODS: display_excel            IMPORTING im_table            TYPE tt_request_details.
    METHODS: set_tp_prefix            IMPORTING im_dev              TYPE sysname OPTIONAL.
    METHODS: top_of_page              EXPORTING ex_form_element     TYPE REF TO cl_salv_form_element.
    METHODS: check_if_same_object     IMPORTING im_line             TYPE ty_request_details
                                                im_newer_older      TYPE ty_request_details
                                      EXPORTING ex_tabkey           TYPE trobj_name
                                                ex_return           TYPE c.
    METHODS: sort_main_list.
    METHODS: determine_warning_text   IMPORTING im_highest_rank     TYPE numc4
                                      EXPORTING ex_highest_text     TYPE text74.
    METHODS: get_tps_for_same_object  IMPORTING im_line             TYPE ty_request_details
                                      EXPORTING ex_newer            TYPE tt_request_details
                                                ex_older            TYPE tt_request_details.
    METHODS: progress_indicator       IMPORTING im_counter          TYPE sytabix
                                                im_object           TYPE trobj_name
                                                im_total            TYPE numc10
                                                im_text             TYPE itex132
                                                im_flag             TYPE c.
    METHODS: alv_xls_init             EXPORTING ex_rf_table         TYPE REF TO cl_salv_table
                                      CHANGING  ch_table            TYPE table.
    METHODS: alv_xls_output.
    METHODS: prepare_ddic_check.
    METHODS: set_ddic_objects.
    METHODS: do_ddic_check            CHANGING  ch_main_list        TYPE tt_request_details.
    METHODS: set_properties_conflicts IMPORTING im_table            TYPE tt_request_details
                                      EXPORTING ex_xend             TYPE i.
    METHODS: get_data                 IMPORTING im_trkorr_range     TYPE gtabkey_trkorrt.
    METHODS: check_for_conflicts      CHANGING  ch_main_list        TYPE tt_request_details.
    METHODS: build_table_keys_popup.
    METHODS: add_table_keys_to_list   EXPORTING table               TYPE tt_request_details.
    METHODS: get_additional_tp_info   CHANGING  ch_table            TYPE tt_request_details.
    METHODS: gui_upload               IMPORTING im_filename         TYPE string
                                      EXPORTING ex_tab_delimited    TYPE table_of_strings
                                                ex_cancelled        TYPE abap_bool.
    METHODS: determine_col_width      IMPORTING im_field            TYPE any
                                      EXPORTING ex_colwidth         TYPE lvc_outlen.
    METHODS: check_colwidth           IMPORTING im_name             TYPE abap_compname
                                                im_colwidth         TYPE lvc_outlen
                                      RETURNING value(re_colwidth)  TYPE lvc_outlen.
    METHODS: remove_tp_in_prd.
    METHODS: version_check.
    METHODS: alv_init.
    METHODS: set_color.
    METHODS: alv_set_properties       IMPORTING im_table            TYPE REF TO cl_salv_table.
    METHODS: alv_set_tooltips         IMPORTING im_table            TYPE REF TO cl_salv_table.
    METHODS: alv_output.
    METHODS: set_where_used.
    METHODS: get_import_datetime_qas  IMPORTING im_trkorr          TYPE trkorr
                                      EXPORTING ex_as4time         TYPE as4time
                                                ex_as4date         TYPE as4date
                                                ex_return          TYPE sysubrc.
ENDCLASS.                    &quot;lcl_ztct DEFINITION

*--------------------------------------------------------------------*
* Selection screen Build
*--------------------------------------------------------------------*

* Possibility to add a button on the selection screen application
* toolbar (If required, uncomment). Function text and icon is filled
* in AT SELECTION-SCREEN OUTPUT
* SELECTION-SCREEN: FUNCTION KEY 1.

* B10: Selection range / Upload file
*---------------------------------------
SELECTION-SCREEN: BEGIN OF BLOCK box1 WITH FRAME TITLE tp_b10.
PARAMETERS:       pa_sel RADIOBUTTON GROUP mod DEFAULT &apos;X&apos;
                                               USER-COMMAND sel.
PARAMETERS:       pa_upl RADIOBUTTON GROUP mod.
SELECTION-SCREEN: END OF BLOCK box1.

* B20: Selection criteria or Upload file
*---------------------------------------
SELECTION-SCREEN: BEGIN OF BLOCK box2 WITH FRAME TITLE tp_b20.
PARAMETERS:       pa_str TYPE as4text VISIBLE LENGTH 41
                                      MODIF ID sel.
SELECTION-SCREEN: BEGIN OF LINE.
SELECTION-SCREEN: COMMENT 1(20) tp_c21 MODIF ID sel.
SELECTION-SCREEN: POSITION 30.
SELECT-OPTIONS:   so_user FOR sy-uname DEFAULT sy-uname
                                       MATCHCODE OBJECT user_addr
                                       MODIF ID sel.
SELECTION-SCREEN: PUSHBUTTON 71(5) i_name
                                   USER-COMMAND name
                                   MODIF ID sel.            &quot;#EC NEEDED
SELECTION-SCREEN: END OF LINE.
SELECT-OPTIONS:   so_korr FOR e070-strkorr MODIF ID sel.
SELECT-OPTIONS:   so_proj FOR ctsproject-trkorr MODIF ID sel.
SELECT-OPTIONS:   so_date FOR e070-as4date MODIF ID sel.
SELECTION-SCREEN: PUSHBUTTON 69(7) i_date
                             USER-COMMAND date
                             MODIF ID sel.                  &quot;#EC NEEDED
SELECTION-SCREEN: BEGIN OF LINE.
SELECTION-SCREEN: COMMENT 1(20) tp_c22 MODIF ID upl.
SELECTION-SCREEN: POSITION POS_LOW.
PARAMETERS:       pa_file TYPE localfile MODIF ID upl.
SELECTION-SCREEN: END OF LINE.
SELECTION-SCREEN: END OF BLOCK box2.

* B30: Transport Track
*---------------------------------------
SELECTION-SCREEN: BEGIN OF BLOCK box3 WITH FRAME TITLE tp_b30.
SELECTION-SCREEN: BEGIN OF LINE.
* C31 - Route
SELECTION-SCREEN: COMMENT 1(20) tp_c31.
SELECTION-SCREEN: POSITION POS_LOW.
PARAMETERS:       pa_dev TYPE sysname DEFAULT &apos;DEV&apos;.
* C32 - --&gt;
SELECTION-SCREEN: COMMENT 45(3) tp_c32.
SELECTION-SCREEN: POSITION 51.
PARAMETERS:       pa_qas TYPE sysname DEFAULT &apos;QAS&apos;.
* C33 - --&gt;
SELECTION-SCREEN: COMMENT 63(3) tp_c33 MODIF ID vrs.
SELECTION-SCREEN: POSITION 69.
PARAMETERS:       pa_prd TYPE sysname DEFAULT &apos;PRD&apos; MODIF ID vrs.
SELECTION-SCREEN: END OF LINE.
SELECTION-SCREEN: END OF BLOCK box3.

* B40: Check options
*---------------------------------------
SELECTION-SCREEN: BEGIN OF BLOCK box4 WITH FRAME TITLE tp_b40.
SELECTION-SCREEN: BEGIN OF LINE.
PARAMETERS:       pa_check RADIOBUTTON GROUP rad DEFAULT &apos;X&apos;
                           USER-COMMAND chk MODIF ID vrs.
SELECTION-SCREEN: COMMENT 4(20)   tp_c46 MODIF ID vrs.
PARAMETERS:       pa_nochk RADIOBUTTON GROUP rad MODIF ID vrs.
SELECTION-SCREEN: END OF LINE.
SELECTION-SCREEN: SKIP 1.
SELECTION-SCREEN: BEGIN OF LINE.
PARAMETERS:       pa_noprd AS CHECKBOX DEFAULT &apos;X&apos; MODIF ID vrs.
* C41 - Use User specific layout
SELECTION-SCREEN: COMMENT 4(63) tp_c40 MODIF ID vrs.
SELECTION-SCREEN: END OF LINE.

SELECTION-SCREEN: BEGIN OF LINE.
PARAMETERS:       pa_user AS CHECKBOX DEFAULT &apos; &apos; MODIF ID vrs.
* C41 - Use User specific layout
SELECTION-SCREEN: COMMENT 4(63) tp_c41 MODIF ID vrs.
SELECTION-SCREEN: END OF LINE.

SELECTION-SCREEN: BEGIN OF LINE.
PARAMETERS:       pa_buff AS CHECKBOX DEFAULT &apos; &apos; MODIF ID vrs.
* C42 - Skip transport buffer check
SELECTION-SCREEN: COMMENT 4(63) tp_c42 MODIF ID vrs.
SELECTION-SCREEN: END OF LINE.
SELECTION-SCREEN: BEGIN OF LINE.
PARAMETERS:       pa_chkky AS CHECKBOX DEFAULT &apos;X&apos; MODIF ID chk
                           USER-COMMAND key.
* C43 - Check table keys
SELECTION-SCREEN: COMMENT 4(16) tp_c43 MODIF ID chk.
SELECTION-SCREEN: END OF LINE.
*PARAMETERS:       pa_kdate TYPE as4date MODIF ID key.
SELECTION-SCREEN: BEGIN OF LINE.
PARAMETERS:       pa_chd AS CHECKBOX DEFAULT &apos; &apos; MODIF ID upl.
* C44  - Reset &apos;Checked&apos; field
SELECTION-SCREEN: COMMENT 4(16) tp_c44 MODIF ID upl.
SELECTION-SCREEN: END OF LINE.
SELECTION-SCREEN: END OF BLOCK box4.

* B50: Exclude from check
*---------------------------------------
SELECTION-SCREEN: BEGIN OF BLOCK box5 WITH FRAME TITLE tp_b50.
*C51 - Objects in the range will not be taken into account when checking
*      the
SELECTION-SCREEN: COMMENT /1(74) tp_c51 MODIF ID chk.
*C52 - transports. Useful to exclude common customizing tables (like
*      SWOTICE for
SELECTION-SCREEN: COMMENT /1(74) tp_c52 MODIF ID chk.
* C53 - workflow or the tables for Pricing procedures).
SELECTION-SCREEN: COMMENT /1(74) tp_c53 MODIF ID chk.
SELECT-OPTIONS:   so_exobj FOR e071-obj_name NO INTERVALS
                                               MODIF ID chk.
SELECTION-SCREEN: END OF BLOCK box5.

* B60 - Overview of used Icons
*---------------------------------------
SELECTION-SCREEN: BEGIN OF BLOCK box6 WITH FRAME TITLE tp_b60.
SELECTION-SCREEN: BEGIN OF LINE.
PARAMETERS:       pa_icon RADIOBUTTON GROUP ico USER-COMMAND ico
                                                MODIF ID vrs.
* C61 - Show
SELECTION-SCREEN: COMMENT 4(6) tp_c61 MODIF ID vrs.
PARAMETERS:       pa_noicn RADIOBUTTON GROUP ico DEFAULT &apos;X&apos;
                                                 MODIF ID vrs.
* C62 - Hide
SELECTION-SCREEN: COMMENT 14(4) tp_c62 MODIF ID vrs.
SELECTION-SCREEN: END OF LINE.
SELECTION-SCREEN: BEGIN OF LINE.
SELECTION-SCREEN: PUSHBUTTON 1(4) p_error USER-COMMAND error
                                          MODIF ID ico.     &quot;#EC NEEDED
* W01 - Transporting to Production will overwrite a newer version!
SELECTION-SCREEN: COMMENT 8(74) tp_w01  MODIF ID ico.
SELECTION-SCREEN: END OF LINE.
SELECTION-SCREEN: BEGIN OF LINE.
SELECTION-SCREEN: PUSHBUTTON 1(4) p_ddic USER-COMMAND ddic
                                          MODIF ID ico.     &quot;#EC NEEDED
*W18 - Transport already in Production, but selected for re-import by
*      the user
SELECTION-SCREEN: COMMENT 8(74) tp_w05  MODIF ID ico.
SELECTION-SCREEN: END OF LINE.
SELECTION-SCREEN: BEGIN OF LINE.
SELECTION-SCREEN: PUSHBUTTON 1(4) p_warn  USER-COMMAND warn
                                          MODIF ID ico.     &quot;#EC NEEDED
* W17 - Previous transport not transported
SELECTION-SCREEN: COMMENT 8(74) tp_w17  MODIF ID ico.
SELECTION-SCREEN: END OF LINE.
SELECTION-SCREEN: BEGIN OF LINE.
SELECTION-SCREEN: PUSHBUTTON 1(4) p_info  USER-COMMAND info
                                          MODIF ID ico.     &quot;#EC NEEDED
*W23 - There is a newer version in Acceptance. Check if it should be
*      moved too
SELECTION-SCREEN: COMMENT 8(74) tp_w23  MODIF ID ico.
SELECTION-SCREEN: END OF LINE.
SELECTION-SCREEN: BEGIN OF LINE.
SELECTION-SCREEN: PUSHBUTTON 1(4) p_hint  USER-COMMAND hint
                                          MODIF ID ico.     &quot;#EC NEEDED
*W04 - Previous or newer transport not transported, but is also in the
*      list
SELECTION-SCREEN: COMMENT 8(74) tp_w04  MODIF ID ico.
SELECTION-SCREEN: END OF LINE.
SELECTION-SCREEN: BEGIN OF LINE.
SELECTION-SCREEN: PUSHBUTTON 1(4) p_added USER-COMMAND added
                                          MODIF ID ico.     &quot;#EC NEEDED
*W18 - Transport already in Production, but selected for re-import by
*      the user
SELECTION-SCREEN: COMMENT 8(74) tp_w18  MODIF ID ico.
SELECTION-SCREEN: END OF LINE.
SELECTION-SCREEN: END OF BLOCK box6.

*--------------------------------------------------------------------*
* Initialize
*--------------------------------------------------------------------*
INITIALIZATION.

* To be able to use methods on the selection screen
  IF rf_ztct IS NOT BOUND.
    TRY .
        CREATE OBJECT rf_ztct.
      CATCH cx_root INTO rf_root.
        rf_ztct-&gt;handle_error( EXPORTING rf_oref = rf_root ).
    ENDTRY.
  ENDIF.

  MOVE: icon_terminated_position       TO i_name,
        icon_defect                    TO p_error,
        icon_wf_workitem_error         TO p_ddic,
        icon_led_yellow                TO p_warn,
        icon_information               TO p_info,
        icon_hint                      TO p_hint,
        icon_scrap                     TO p_added.

  MOVE: &apos;Clear&apos;(025)                   TO i_date.
  IF so_date IS INITIAL.
    MOVE: &apos;Clear&apos;(025)                 TO i_date.
    so_date-sign = &apos;I&apos;.
    so_date-option = &apos;BT&apos;.
    so_date-high = sy-datum.
    so_date-low = rf_ztct-&gt;go_back_months( im_currdate   = sy-datum
                                           im_backmonths = 6 ).
    APPEND so_date TO so_date.
  ELSE.
    MOVE: &apos;Def.&apos;(026)                  TO i_date.
    REFRESH so_date.
  ENDIF.

* Set selection texts (to link texts to selection screen):
* This is done to facilitate (love that word...) the copying of this
* program to other environments without losing all the texts.
  tp_b10 = &apos;Selection range / Upload file&apos;(b10).
  tp_b30 = &apos;Transport Track&apos;(b30).
  tp_b40 = &apos;Check options&apos;(b40).
  tp_b50 = &apos;Exclude from check&apos;(b50).
  tp_b60 = &apos;Overview of used Icons&apos;(b60).
  tp_c21 = &apos;User&apos;(c21).
  tp_c22 = &apos;File name&apos;(c22).
  tp_c31 = &apos;Route&apos;(c31).
  tp_c32 = &apos;--&gt;&apos;(c32).
  tp_c33 = &apos;--&gt;&apos;(c33).
  tp_c40 = &apos;Do not select transports already in production&apos;(c40).
  tp_c41 = &apos;Use User specific layout&apos;(c41).
  tp_c42 = &apos;Skip transport buffer check&apos;(c42).
  tp_c43 = &apos;Check table keys&apos;(c43).
  tp_c44 = &apos;Reset `Checked` field&apos;(c44).
  tp_c46 = &apos;Check ON / Check OFF&apos;(c46).
  tp_c51 = &apos;Objects in the range will not be taken into account &apos; &amp;
           &apos;when checking the&apos;(c51).
  tp_c52 = &apos;transports. Useful to exclude common customizing tables &apos; &amp;
           &apos;(like SWOTICE for&apos;(c52).
  tp_c53 = &apos;workflow or the tables for Pricing procedures).&apos;(c53).
  tp_c61 = &apos;Show&apos;(c61).
  tp_c62 = &apos;Hide&apos;(c62).
  tp_w01 = &apos;Newer version in production!&apos;(w01).
  tp_w05 = &apos;Object missing in List and Production!&apos;(w05).
  tp_w17 = &apos;Previous transport not transported&apos;(w17).
  tp_w23 = &apos;Newer version in Acceptance&apos;(w23).
  tp_w04 = &apos;All conflicts are dealt with by the list&apos;(w04).
  tp_w18 = &apos;Marked for re-import to Production&apos;(w18).

* Create a range table containing all project numbers:
  st_project_trkorrs-sign = &apos;I&apos;.
  st_project_trkorrs-option = &apos;EQ&apos;.
  SELECT trkorr FROM ctsproject
                INTO st_project_trkorrs-low.          &quot;#EC CI_SGLSELECT
    APPEND st_project_trkorrs TO ra_project_trkorrs.
  ENDSELECT.

* Get the transport track
  tp_sysname = sy-sysid.
  CALL FUNCTION &apos;TR_GET_LIST_OF_TARGETS&apos;
    EXPORTING
      iv_src_system    = tp_sysname
    IMPORTING
      et_targets       = ta_targets
    EXCEPTIONS
      tce_config_error = 1
      OTHERS           = 2.
  IF sy-subrc &lt;&gt; 0.
    MESSAGE ID sy-msgid TYPE sy-msgty NUMBER sy-msgno
            WITH sy-msgv1 sy-msgv2 sy-msgv3 sy-msgv4.
  ENDIF.
  pa_dev = sy-sysid.
  LOOP AT ta_targets INTO st_target.
    CASE sy-tabix.
      WHEN 1.
        pa_qas = st_target.
      WHEN 2.
        pa_prd = st_target.
    ENDCASE.
  ENDLOOP.

* Move to range:
  st_systems-sign   = &apos;I&apos;.
  st_systems-option = &apos;EQ&apos;.
  LOOP AT ta_sapsystems INTO st_sapsystems.
    MOVE st_sapsystems-sysnam TO st_systems-low.
    APPEND st_systems TO ra_systems.
  ENDLOOP.

* Default values for s_exobj. These objects will not be checked!
* Exclude Single values:
  so_exobj-sign   = &apos;E&apos;.
  so_exobj-option = &apos;EQ&apos;.
  so_exobj-low    = &apos;SWOTICE&apos;.  &quot; Index of Frozen DDIC Structures
  APPEND so_exobj TO so_exobj.
  so_exobj-low    = &apos;TVDIR&apos;.    &quot; View Directory
  APPEND so_exobj TO so_exobj.
  so_exobj-low    = &apos;TDDAT&apos;.    &quot; Maintenance Areas for Tables
  APPEND so_exobj TO so_exobj.
*--------------------------------------------------------------------*
* Selection screen Checks
*--------------------------------------------------------------------*
AT SELECTION-SCREEN.
  CASE sy-ucomm.
    WHEN &apos;NAME&apos;.
      IF NOT so_user IS INITIAL.
        REFRESH: so_user.
        CLEAR:   so_user.
        MOVE icon_create_position TO i_name.
      ELSE.
        so_user-option = &apos;EQ&apos;.
        so_user-sign = &apos;I&apos;.
        so_user-low = sy-uname.
        APPEND: so_user TO so_user.
        MOVE icon_terminated_position TO i_name.
      ENDIF.
    WHEN &apos;DATE&apos;.
      IF so_date IS INITIAL.
        MOVE: &apos;Clear&apos;(025) TO i_date.
        IF so_date[] IS INITIAL.
          so_date-sign = &apos;I&apos;.
          so_date-option = &apos;BT&apos;.
          so_date-high = sy-datum.
          so_date-low = rf_ztct-&gt;go_back_months( im_currdate   = sy-datum
                                                 im_backmonths = 6 ).
          APPEND so_date TO so_date.
        ENDIF.
      ELSE.
        MOVE: &apos;Def.&apos;(026) TO i_date.
        REFRESH so_date.
      ENDIF.
  ENDCASE.

AT SELECTION-SCREEN OUTPUT.
* This commented out code can be used to add a function on the toolbar:
  st_smp_dyntxt-text       = &apos;Information&apos;(027).
  st_smp_dyntxt-icon_id    = rf_ztct-&gt;co_info.
  st_smp_dyntxt-icon_text  = &apos;Info&apos;(024).
  st_smp_dyntxt-quickinfo  = &apos;General Info&apos;(028).
  st_smp_dyntxt-path       = &apos;I&apos;.
  sscrfields-functxt_01 = st_smp_dyntxt.

  LOOP AT SCREEN.
    CASE screen-group1.
      WHEN &apos;SEL&apos;.
        IF pa_sel = &apos;X&apos;.
          screen-active = &apos;1&apos;.
          tp_b20 = &apos;Selection criteria&apos;(b21).
        ELSE.
          screen-active = &apos;0&apos;.
          tp_b20 = &apos;File upload&apos;(b22).
        ENDIF.
        MODIFY SCREEN.
      WHEN &apos;CHK&apos;.
        IF pa_check = &apos;X&apos;.
          screen-active = &apos;1&apos;.
        ELSE.
          screen-active = &apos;0&apos;.
        ENDIF.
        MODIFY SCREEN.
      WHEN &apos;DIC&apos;.
        IF pa_check = &apos;X&apos;.
          screen-active = &apos;1&apos;.
        ELSE.
          screen-active = &apos;0&apos;.
        ENDIF.
        MODIFY SCREEN.
      WHEN &apos;KEY&apos;.
        IF pa_chkky = &apos;X&apos; AND pa_check = &apos;X&apos;.
          screen-active = &apos;1&apos;.
        ELSE.
          screen-active = &apos;0&apos;.
        ENDIF.
        MODIFY SCREEN.
      WHEN &apos;UPL&apos;.
        IF pa_upl = &apos;X&apos;.
          screen-active = &apos;1&apos;.
        ELSE.
          screen-active = &apos;0&apos;.
        ENDIF.
        MODIFY SCREEN.
      WHEN &apos;ICO&apos;.
        IF pa_icon = &apos;X&apos;.
          screen-active = &apos;1&apos;.
        ELSE.
          screen-active = &apos;0&apos;.
        ENDIF.
        MODIFY SCREEN.
      WHEN &apos;GRY&apos;.
        screen-input = &apos;0&apos;.
        MODIFY SCREEN.
    ENDCASE.
  ENDLOOP.

* If the user range is initial (removed manually), set the correct Icon:
AT SELECTION-SCREEN ON so_user.
  IF so_user[] IS INITIAL.
    MOVE icon_create_position TO i_name.
  ENDIF.

AT SELECTION-SCREEN ON VALUE-REQUEST FOR pa_file.
  rf_ztct-&gt;get_filename( IMPORTING ex_file = pa_file ).

*--------------------------------------------------------------------*
*       CLASS lcl_eventhandler_ztct IMPLEMENTATION
*--------------------------------------------------------------------*
CLASS lcl_eventhandler_ztct IMPLEMENTATION.

  METHOD on_function_click.
    TYPES: BEGIN OF lty_sval.
            INCLUDE TYPE sval.
    TYPES: END OF lty_sval.
    TYPES: lty_field TYPE STANDARD TABLE OF lty_sval.
    DATA: ra_transports_to_add TYPE RANGE OF e070-trkorr,
          st_transports_to_add LIKE LINE OF ra_transports_to_add.
    DATA: ta_excluded_objects  TYPE RANGE OF trobj_name.
    DATA: ls_excluded_objects  LIKE LINE  OF ta_excluded_objects.
* Global data declarations:
    DATA: lp_title            TYPE string.
    DATA: lp_filename         TYPE string.
    DATA: lp_file             TYPE localfile.
    DATA: lt_fields           TYPE lty_field. &quot;ty_sval.
    DATA: ls_fields           TYPE sval.
    DATA: lp_tabix            TYPE sytabix.
    DATA: lr_selections       TYPE REF TO cl_salv_selections.
    DATA: lp_localfile        TYPE localfile.
    DATA: lp_filelength       TYPE i.
    DATA: ls_row              TYPE int4.
    DATA: lp_row_found        TYPE abap_bool.
    DATA: lp_return           TYPE c.
*   Selected rows
    DATA: lt_rows             TYPE salv_t_row.
    DATA: ls_cell             TYPE salv_s_cell.
    DATA: lp_path             TYPE string.
    DATA: lp_fullpath         TYPE string.
    DATA: lp_result           TYPE i.
    DATA: lp_desktop          TYPE string.
    DATA: lp_timestamp        TYPE tzntstmps.
    DATA: lp_default_filename TYPE string.
    DATA: lp_question         TYPE string.
    DATA: lp_answer           TYPE char01.

    FIELD-SYMBOLS: &lt;rf_ref_table&gt; TYPE REF TO cl_salv_table.

*   Which popup are we displaying? Conflicts or Table keys?
    IF rf_conflicts IS BOUND.
      ASSIGN rf_conflicts TO &lt;rf_ref_table&gt;.
    ELSEIF rf_table_keys IS BOUND.
      ASSIGN rf_table_keys TO &lt;rf_ref_table&gt;.
    ELSE.
      ASSIGN rf_table TO &lt;rf_ref_table&gt;.
    ENDIF.

*   Get current row
    IF e_salv_function = &apos;GOON&apos; OR e_salv_function = &apos;ABR&apos;.
      lr_selections = &lt;rf_ref_table&gt;-&gt;get_selections(  ).
      lt_rows = lr_selections-&gt;get_selected_rows( ).
      ls_cell = lr_selections-&gt;get_current_cell( ).
    ELSE.
      lr_selections = &lt;rf_ref_table&gt;-&gt;get_selections(  ).
      lt_rows = lr_selections-&gt;get_selected_rows( ).
      ls_cell = lr_selections-&gt;get_current_cell( ).
      READ TABLE rf_ztct-&gt;main_list INTO  rf_ztct-&gt;main_list_line
                                    INDEX ls_cell-row.
    ENDIF.
    CASE e_salv_function.
      WHEN &apos;GOON&apos;.
        IF rf_conflicts IS BOUND.
          rf_conflicts-&gt;close_screen( ).
*         Move the conflicts to a range. The transports in this range will
*         be added to the main list:
          REFRESH: ra_transports_to_add.
          rf_ztct-&gt;set_building_conflict_popup( abap_false ).
          CLEAR: st_transports_to_add.
          st_transports_to_add-sign = &apos;I&apos;.
          st_transports_to_add-option = &apos;EQ&apos;.
*         If row(s) are selected, use the table
          LOOP AT lt_rows INTO ls_row.
            READ TABLE rf_ztct-&gt;conflicts INTO  rf_ztct-&gt;conflict_line
                                          INDEX ls_row.
            st_transports_to_add-low = rf_ztct-&gt;conflict_line-trkorr.
            APPEND st_transports_to_add TO ra_transports_to_add.
          ENDLOOP.
*         Rows MUST be selected, take the current cell instead
          IF lt_rows[] IS INITIAL.
            MESSAGE i000(db) WITH &apos;No rows selected: No transports will be added&apos;(m06).
          ENDIF.
          IF ra_transports_to_add[] IS NOT INITIAL.
            rf_ztct-&gt;get_added_objects( EXPORTING im_to_add = ra_transports_to_add
                                        IMPORTING ex_to_add = rf_ztct-&gt;add_to_main ).
            rf_ztct-&gt;get_additional_tp_info( CHANGING ch_table = rf_ztct-&gt;add_to_main ).
            rf_ztct-&gt;add_to_list( EXPORTING im_to_add = rf_ztct-&gt;add_to_main
                                  IMPORTING ex_main   = rf_ztct-&gt;main_list ).
*         After the transports have been added, check if there are added
*         transports that are already in prd. If so, make them visible by
*         changing the prd icon to co_scrap.
            LOOP AT rf_ztct-&gt;main_list INTO rf_ztct-&gt;main_list_line
                                       WHERE prd    = rf_ztct-&gt;co_okay
                                       AND   trkorr IN ra_transports_to_add.
              rf_ztct-&gt;main_list_line-prd = rf_ztct-&gt;co_scrap.
              MODIFY rf_ztct-&gt;main_list FROM rf_ztct-&gt;main_list_line.
            ENDLOOP.
*         After the transports have been added, we need to check again
            rf_ztct-&gt;flag_same_objects( IMPORTING ex_main_list = rf_ztct-&gt;main_list ).
            rf_ztct-&gt;check_for_conflicts( CHANGING ch_main_list = rf_ztct-&gt;main_list ).
            rf_ztct-&gt;refresh_alv( ).                   &quot;Refresh the ALV
          ENDIF.
          FREE rf_conflicts.
        ELSE.
*         If row(s) are selected, use the table
          rf_table_keys-&gt;close_screen( ).
          LOOP AT lt_rows INTO ls_row.
            READ TABLE rf_ztct-&gt;table_keys INTO rf_ztct-&gt;table_keys_line
                                           INDEX ls_row.
*           Add all tables that were NOT selected to the exclusion range
            IF sy-subrc &lt;&gt; 0.
              ls_excluded_objects-sign   = &apos;E&apos;.
              ls_excluded_objects-option = &apos;EQ&apos;.
              ls_excluded_objects-low    = rf_ztct-&gt;table_keys_line-tabname.
              APPEND ls_excluded_objects TO ta_excluded_objects.
            ENDIF.
          ENDLOOP.
*         If user pressed cancel (Add all tables, do not check any)
          IF lt_rows[] IS INITIAL.
            LOOP AT rf_ztct-&gt;table_keys INTO  rf_ztct-&gt;table_keys_line.
              ls_excluded_objects-sign   = &apos;E&apos;.
              ls_excluded_objects-option = &apos;EQ&apos;.
              ls_excluded_objects-low    = rf_ztct-&gt;table_keys_line-tabname.
              APPEND ls_excluded_objects TO ta_excluded_objects.
            ENDLOOP.
            MESSAGE i000(db) WITH &apos;No rows selected: Table keys will &apos; &amp;
                                  &apos;not be checked&apos;(m07).
          ENDIF.
          FREE rf_table_keys.
        ENDIF.
      WHEN &apos;ABR&apos;.
        IF rf_table_keys IS BOUND.
          rf_table_keys-&gt;close_screen( ).
*         If user pressed cancel (Add all tables, do not check any)
          LOOP AT rf_ztct-&gt;table_keys INTO  rf_ztct-&gt;table_keys_line.
            ls_excluded_objects-sign   = &apos;E&apos;.
            ls_excluded_objects-option = &apos;EQ&apos;.
            ls_excluded_objects-low    = rf_ztct-&gt;table_keys_line-tabname.
            APPEND ls_excluded_objects TO ta_excluded_objects.
          ENDLOOP.
          MESSAGE i000(db) WITH &apos;Cancelled: Table keys will &apos; &amp;
                                &apos;not be checked&apos;(m09).
          FREE rf_table_keys.
        ELSE.
          rf_conflicts-&gt;close_screen( ).
          FREE rf_conflicts.
        ENDIF.
      WHEN &apos;RECHECK&apos;.
        rf_ztct-&gt;set_building_conflict_popup( abap_false ).
        rf_ztct-&gt;refresh_import_queues( ).
        rf_ztct-&gt;flag_for_process( EXPORTING rows = lt_rows
                                             cell = ls_cell ).
        rf_ztct-&gt;add_table_keys_to_list( IMPORTING table = rf_ztct-&gt;main_list ).
        rf_ztct-&gt;get_additional_tp_info( CHANGING ch_table = rf_ztct-&gt;main_list ).
        rf_ztct-&gt;flag_same_objects( IMPORTING ex_main_list = rf_ztct-&gt;main_list ).
        rf_ztct-&gt;check_for_conflicts( CHANGING ch_main_list = rf_ztct-&gt;main_list ).
        rf_ztct-&gt;refresh_alv( ).                   &quot;Refresh the ALV
      WHEN &apos;DDIC&apos;.
        IF rf_ztct-&gt;where_used[] IS INITIAL.
          lp_question = &apos;This will take approx. 5-15 minutes... Continue?&apos;(041).
        ELSE.
          lp_question = &apos;This has already been done. Do again?&apos;(042).
        ENDIF.

        CALL FUNCTION &apos;POPUP_TO_CONFIRM&apos;
          EXPORTING
            titlebar              = &apos;Runtime Alert&apos;(039)
            text_question         = lp_question
            text_button_1         = &apos;Yes&apos;(037)
            icon_button_1         = &apos;ICON_OKAY&apos;
            text_button_2         = &apos;No&apos;(043)
            icon_button_2         = &apos;ICON_CANCEL&apos;
            default_button        = &apos;2&apos;
            display_cancel_button = &apos; &apos;
*           START_COLUMN          = 25
*           START_ROW             = 6
          IMPORTING
            answer                = lp_answer
          EXCEPTIONS
            text_not_found        = 0
            OTHERS                = 0.
        IF sy-subrc &lt;&gt; 0.
* Implement suitable error handling here
        ENDIF.
        IF lp_answer = &apos;1&apos;.
          rf_ztct-&gt;check_ddic = abap_true.
          rf_ztct-&gt;set_ddic_objects( ).
          rf_ztct-&gt;set_where_used( ).
        ENDIF.
        rf_ztct-&gt;do_ddic_check( CHANGING ch_main_list = rf_ztct-&gt;main_list ).
        rf_ztct-&gt;refresh_alv( ).                   &quot;Refresh the ALV
      WHEN &apos;&amp;ADD&apos;. &quot;Button clicked
        rf_ztct-&gt;set_building_conflict_popup(  ).
*       Here, we want to give the option to the user to select the
*       transports to be added. Display a popup with the option to select the
*       transports to be added with checkboxes.
        rf_ztct-&gt;flag_for_process( EXPORTING rows = lt_rows
                                             cell = ls_cell ).
        rf_ztct-&gt;flag_same_objects( IMPORTING ex_main_list = rf_ztct-&gt;main_list ).
        rf_ztct-&gt;check_for_conflicts( CHANGING ch_main_list = rf_ztct-&gt;main_list ).
        rf_ztct-&gt;build_conflict_popup( rows = lt_rows
                                       cell = ls_cell ).
      WHEN &apos;&amp;ADD_TP&apos;.
        REFRESH: lt_fields.
        CLEAR:   ls_fields.
        ls_fields-tabname   = &apos;E070&apos;.
        ls_fields-fieldname = &apos;TRKORR&apos;.
        APPEND ls_fields TO lt_fields.
        CALL FUNCTION &apos;POPUP_GET_VALUES_DB_CHECKED&apos;
          EXPORTING
            popup_title     = &apos;Selected transports&apos;(t01)
          IMPORTING
            returncode      = lp_return
          TABLES
            fields          = lt_fields
          EXCEPTIONS
            error_in_fields = 1
            OTHERS          = 2.
        CASE sy-subrc.
          WHEN 1.
            MESSAGE e000(db) WITH &apos;ERROR: ERROR_IN_FIELDS&apos;(m08).
          WHEN 2.
            MESSAGE e000(db) WITH &apos;Error occurred&apos;(029).
        ENDCASE.
*       Exit if cancelled:
        CHECK lp_return &lt;&gt; &apos;A&apos;.
*       Move the conflicts to a range. The transports in this range will
*       be added to the main list:
        REFRESH: ra_transports_to_add.
        CLEAR:   st_transports_to_add.
        st_transports_to_add-sign = &apos;I&apos;.
        st_transports_to_add-option = &apos;EQ&apos;.
        READ TABLE lt_fields INTO ls_fields INDEX 1.
        CHECK NOT ls_fields-value IS INITIAL.
*       Is it already in the list?
        READ TABLE rf_ztct-&gt;main_list WITH KEY trkorr = ls_fields-value(20)
                                        TRANSPORTING NO FIELDS.
        CHECK sy-subrc &lt;&gt; 0.
*       Add transport number to the internal table to add:
        st_transports_to_add-low = ls_fields-value.
        APPEND st_transports_to_add TO ra_transports_to_add.
        rf_ztct-&gt;get_added_objects( EXPORTING im_to_add = ra_transports_to_add
                                      IMPORTING ex_to_add = rf_ztct-&gt;add_to_main ).
        rf_ztct-&gt;get_additional_tp_info( CHANGING ch_table = rf_ztct-&gt;add_to_main ).
        rf_ztct-&gt;add_to_list( EXPORTING im_to_add = rf_ztct-&gt;add_to_main
                                IMPORTING ex_main   = rf_ztct-&gt;main_list ).
*       After the transports have been added, check if there are added
*       transports that are already in prd. If so, make them visible by
*       changing the prd icon to co_scrap.
        LOOP AT rf_ztct-&gt;main_list INTO  rf_ztct-&gt;main_list_line
                             WHERE prd    = rf_ztct-&gt;co_okay
                             AND   trkorr IN ra_transports_to_add.
          rf_ztct-&gt;main_list_line-prd = rf_ztct-&gt;co_scrap.
          MODIFY rf_ztct-&gt;main_list FROM rf_ztct-&gt;main_list_line.
        ENDLOOP.
*       Unfortunately, after the transports have been added, we need to
*       check again...
        rf_ztct-&gt;flag_same_objects( IMPORTING ex_main_list = rf_ztct-&gt;main_list ).
        rf_ztct-&gt;check_for_conflicts( CHANGING ch_main_list = rf_ztct-&gt;main_list ).
        rf_ztct-&gt;refresh_alv( ).                   &quot;Refresh the ALV
      WHEN &apos;&amp;ADD_FILE&apos;.
        rf_ztct-&gt;clear_flags( ).
        rf_ztct-&gt;get_filename( IMPORTING ex_file = lp_localfile ).
        MOVE lp_localfile TO lp_filename.
        rf_ztct-&gt;gui_upload( EXPORTING im_filename      = lp_filename
                             IMPORTING ex_tab_delimited = rf_ztct-&gt;tab_delimited ).
        rf_ztct-&gt;check_for_conflicts( CHANGING ch_main_list = rf_ztct-&gt;main_list ).
        rf_ztct-&gt;refresh_alv( ).                   &quot;Refresh the ALV
      WHEN &apos;&amp;DEL&apos;.                                &quot;Button clicked
*       Mark all records for the selected transport(s)
        rf_ztct-&gt;clear_flags( ).
        rf_ztct-&gt;mark_all_tp_records( EXPORTING im_cell = ls_cell
                                      CHANGING  im_rows = lt_rows ).
        rf_ztct-&gt;flag_for_process( EXPORTING rows = lt_rows
                                             cell = ls_cell ).
        rf_ztct-&gt;flag_same_objects( IMPORTING ex_main_list = rf_ztct-&gt;main_list ).
        rf_ztct-&gt;delete_tp_from_list( EXPORTING rows = lt_rows
                                                cell = ls_cell ).
        rf_ztct-&gt;check_for_conflicts( CHANGING ch_main_list = rf_ztct-&gt;main_list ).
        rf_ztct-&gt;refresh_alv( ).                   &quot;Refresh the ALV
      WHEN &apos;&amp;IMPORT&apos;. &quot;Button clicked
*       Re-transport a request (transport already in production)
        rf_ztct-&gt;clear_flags( ).
        rf_ztct-&gt;flag_for_process( EXPORTING rows = lt_rows
                                               cell = ls_cell ).
        REFRESH: ra_transports_to_add.
        CLEAR:   st_transports_to_add.
        st_transports_to_add-sign = &apos;I&apos;.
        st_transports_to_add-option = &apos;EQ&apos;.
        LOOP AT rf_ztct-&gt;main_list INTO  rf_ztct-&gt;main_list_line
                                     WHERE flag = &apos;X&apos;
                                     AND   prd  = rf_ztct-&gt;co_okay.
          st_transports_to_add-low = rf_ztct-&gt;main_list_line-trkorr.
          APPEND st_transports_to_add TO ra_transports_to_add.
        ENDLOOP.
        IF ra_transports_to_add IS INITIAL.
          MESSAGE i000(db) WITH &apos;No records selected that can be re-imported&apos;(m11).
          EXIT.
        ENDIF.
        LOOP AT rf_ztct-&gt;main_list INTO rf_ztct-&gt;main_list_line
                                     WHERE trkorr IN ra_transports_to_add.
          rf_ztct-&gt;main_list_line-flag = &apos;X&apos;.
          rf_ztct-&gt;main_list_line-prd  = rf_ztct-&gt;co_scrap.
          MODIFY rf_ztct-&gt;main_list FROM rf_ztct-&gt;main_list_line.
        ENDLOOP.
        rf_ztct-&gt;flag_same_objects( IMPORTING ex_main_list = rf_ztct-&gt;main_list ).
        rf_ztct-&gt;check_for_conflicts( CHANGING ch_main_list = rf_ztct-&gt;main_list ).
        rf_ztct-&gt;refresh_alv( ).                   &quot;Refresh the ALV
      WHEN &apos;&amp;DOC&apos;. &quot;Button clicked
        MOVE rf_ztct-&gt;main_list_line-trkorr TO tp_dokl_object.
        rf_ztct-&gt;docu_call( EXPORTING im_object = tp_dokl_object ).
        rf_ztct-&gt;check_documentation( EXPORTING im_trkorr = rf_ztct-&gt;main_list_line-trkorr
                                        CHANGING  ch_table  = rf_ztct-&gt;main_list ).
      WHEN &apos;&amp;PREP_XLS&apos;.
        CHECK rf_table_xls IS NOT BOUND.
        rf_ztct-&gt;display_excel( EXPORTING im_table = rf_ztct-&gt;main_list ).
      WHEN &apos;&amp;SAVE&apos;.
*       Build header
        rf_ztct-&gt;main_to_tab_delimited( EXPORTING im_main_list     = rf_ztct-&gt;main_list
                                        IMPORTING ex_tab_delimited = rf_ztct-&gt;tab_delimited ).
* Finding desktop
        CALL METHOD cl_gui_frontend_services=&gt;get_desktop_directory
          CHANGING
            desktop_directory    = lp_desktop
          EXCEPTIONS
            cntl_error           = 1
            error_no_gui         = 2
            not_supported_by_gui = 3
            OTHERS               = 4.
        IF sy-subrc &lt;&gt; 0.
          MESSAGE e001(00) WITH
              &apos;Desktop not found&apos;(008).
        ENDIF.

        CONVERT DATE sy-datum TIME sy-uzeit
          INTO TIME STAMP lp_timestamp TIME ZONE sy-zonlo.
        lp_default_filename = lp_timestamp.
        CONCATENATE &apos;ZTCT-&apos; lp_default_filename INTO lp_default_filename.

        lp_title = &apos;Save Transportlist&apos;(009).
        CALL METHOD cl_gui_frontend_services=&gt;file_save_dialog
          EXPORTING
            window_title         = lp_title
            default_extension    = &apos;TXT&apos;
            default_file_name    = lp_default_filename
            initial_directory    = lp_desktop
          CHANGING
            filename             = lp_filename
            path                 = lp_path
            fullpath             = lp_fullpath
          EXCEPTIONS
            cntl_error           = 1
            error_no_gui         = 2
            not_supported_by_gui = 3
            OTHERS               = 4.
        IF sy-subrc &lt;&gt; 0.
          MESSAGE ID sy-msgid TYPE sy-msgty NUMBER sy-msgno
                     WITH sy-msgv1 sy-msgv2 sy-msgv3 sy-msgv4.
        ENDIF.

*       Display save dialog window
        CALL METHOD cl_gui_frontend_services=&gt;gui_download
          EXPORTING
            filename                = lp_fullpath
            filetype                = &apos;ASC&apos;
          IMPORTING
            filelength              = lp_filelength
          CHANGING
            data_tab                = rf_ztct-&gt;tab_delimited
          EXCEPTIONS
            file_write_error        = 1
            no_batch                = 2
            gui_refuse_filetransfer = 3
            invalid_type            = 4
            no_authority            = 5
            unknown_error           = 6
            header_not_allowed      = 7
            separator_not_allowed   = 8
            filesize_not_allowed    = 9
            header_too_long         = 10
            dp_error_create         = 11
            dp_error_send           = 12
            dp_error_write          = 13
            unknown_dp_error        = 14
            access_denied           = 15
            dp_out_of_memory        = 16
            disk_full               = 17
            dp_timeout              = 18
            file_not_found          = 19
            dataprovider_exception  = 20
            control_flush_error     = 21
            not_supported_by_gui    = 22
            error_no_gui            = 23
            OTHERS                  = 24.
        CASE sy-subrc.
          WHEN 0.
          WHEN OTHERS.
            MESSAGE ID sy-msgid TYPE sy-msgty NUMBER sy-msgno
                       WITH sy-msgv1 sy-msgv2 sy-msgv3 sy-msgv4.
        ENDCASE.
      WHEN &apos;&amp;NCONF&apos;.
        CLEAR: lp_row_found.
        lp_tabix = ls_cell-row + 1.
        LOOP AT rf_ztct-&gt;main_list INTO rf_ztct-&gt;main_list_line FROM lp_tabix.
          IF lp_row_found IS INITIAL AND
            ( rf_ztct-&gt;main_list_line-warning_rank &gt;= rf_ztct-&gt;co_info_rank ).
            ls_cell-row = sy-tabix.
            ls_cell-columnname = &apos;WARNING_LVL&apos;.
            lr_selections-&gt;set_current_cell( ls_cell ).
            lp_row_found = abap_true.
          ENDIF.
        ENDLOOP.
        IF lp_row_found IS INITIAL.
          LOOP AT rf_ztct-&gt;main_list INTO rf_ztct-&gt;main_list_line.
            IF lp_row_found IS INITIAL AND
             ( rf_ztct-&gt;main_list_line-warning_rank &gt;= rf_ztct-&gt;co_info_rank ).
              ls_cell-row = sy-tabix.
              ls_cell-columnname = &apos;WARNING_LVL&apos;.
              lr_selections-&gt;set_current_cell( ls_cell ).
              lp_row_found = abap_true.
            ENDIF.
          ENDLOOP.
          IF lp_row_found IS INITIAL.
            MESSAGE i000(db) WITH &apos;No next conflict found&apos;(021).
          ENDIF.
        ENDIF.
        rf_ztct-&gt;refresh_alv( ).                   &quot;Refresh the ALV
    ENDCASE.
  ENDMETHOD.                    &quot;on_function_click

  METHOD on_double_click.
    DATA: lr_selections      TYPE REF TO cl_salv_selections.
*   Selected rows
    DATA: lt_rows    TYPE salv_t_row.
    DATA: ls_cell    TYPE salv_s_cell.

    lr_selections = rf_table-&gt;get_selections(  ).
    lt_rows = lr_selections-&gt;get_selected_rows( ).
    ls_cell = lr_selections-&gt;get_current_cell( ).

*   Only display the details when the list is the MAIN list (Object level
* not when the list is on Header level (XLS)
    IF rf_table_xls IS BOUND.
      EXIT.
    ELSE.
      READ TABLE rf_ztct-&gt;main_list     INTO rf_ztct-&gt;main_list_line INDEX row.
    ENDIF.
    CASE column.
      WHEN &apos;TRKORR&apos;.
        rf_ztct-&gt;display_transport( EXPORTING im_trkorr = rf_ztct-&gt;main_list_line-trkorr ).
      WHEN &apos;AS4USER&apos;.
        rf_ztct-&gt;display_user( EXPORTING im_user = rf_ztct-&gt;main_list_line-as4user ).
      WHEN &apos;CHECKED_BY&apos;.
        rf_ztct-&gt;display_user( EXPORTING im_user = rf_ztct-&gt;main_list_line-checked_by ).
*     Documentation
      WHEN &apos;INFO&apos;.
        rf_ztct-&gt;display_docu( EXPORTING im_trkorr = rf_ztct-&gt;main_list_line-trkorr ).
        rf_ztct-&gt;refresh_alv( ).                   &quot;Refresh the ALV
      WHEN &apos;WARNING_LVL&apos;.
*       Display popup with the conflicting transports/objects
        IF rf_ztct-&gt;main_list_line-warning_lvl IS NOT INITIAL.
          rf_ztct-&gt;build_conflict_popup( rows = lt_rows
                                         cell = ls_cell ).
          rf_ztct-&gt;refresh_alv( ).                 &quot;Refresh the ALV
        ENDIF.
      WHEN OTHERS.
    ENDCASE.
  ENDMETHOD.                                       &quot;on_double_click

  METHOD on_double_click_popup.
    DATA: lr_selections      TYPE REF TO cl_salv_selections.
*   Selected rows
    DATA: lt_rows    TYPE salv_t_row.
    DATA: ls_cell    TYPE salv_s_cell.

    lr_selections = rf_table-&gt;get_selections(  ).
    lt_rows = lr_selections-&gt;get_selected_rows( ).
    ls_cell = lr_selections-&gt;get_current_cell( ).

    READ TABLE rf_ztct-&gt;conflicts INTO rf_ztct-&gt;conflict_line INDEX row.
    CASE column.
      WHEN &apos;TRKORR&apos;.
        rf_ztct-&gt;display_transport( EXPORTING im_trkorr = rf_ztct-&gt;conflict_line-trkorr ).
      WHEN &apos;AS4USER&apos;.
        rf_ztct-&gt;display_user( EXPORTING im_user = rf_ztct-&gt;conflict_line-as4user ).
      WHEN &apos;CHECKED_BY&apos;.
        rf_ztct-&gt;display_user( EXPORTING im_user = rf_ztct-&gt;conflict_line-checked_by ).
*     Documentation
      WHEN &apos;INFO&apos;.
        rf_ztct-&gt;display_docu( EXPORTING im_trkorr = rf_ztct-&gt;conflict_line-trkorr ).
        rf_ztct-&gt;refresh_alv( ).                   &quot;Refresh the ALV
      WHEN OTHERS.
    ENDCASE.
  ENDMETHOD.                                       &quot;on_double_click

  METHOD on_link_click.
    FIELD-SYMBOLS: &lt;rf_ref_table&gt; TYPE REF TO cl_salv_table.
*   Which table are we displaying? Object level or Header level (XLS)?
    IF rf_table_xls IS BOUND.
      READ TABLE rf_ztct-&gt;main_list_xls INTO rf_ztct-&gt;main_list_line INDEX row.
    ELSE.
      READ TABLE rf_ztct-&gt;main_list     INTO rf_ztct-&gt;main_list_line INDEX row.
    ENDIF.
    CASE column.
      WHEN &apos;TRKORR&apos;.
        rf_ztct-&gt;display_transport( EXPORTING im_trkorr = rf_ztct-&gt;main_list_line-trkorr ).
      WHEN OTHERS.
    ENDCASE.
  ENDMETHOD.                                       &quot;on_link_click

  METHOD on_link_click_popup.
    READ TABLE rf_ztct-&gt;conflicts INTO rf_ztct-&gt;conflict_line INDEX row.
    CASE column.
      WHEN &apos;TRKORR&apos;.
        rf_ztct-&gt;display_transport( EXPORTING im_trkorr = rf_ztct-&gt;conflict_line-trkorr ).
      WHEN OTHERS.
    ENDCASE.
  ENDMETHOD.                                       &quot;on_link_click_popup

ENDCLASS.                    &quot;lcl_eventhandler_ztct IMPLEMENTATION

*--------------------------------------------------------------------*
*       CLASS lcl_ztct IMPLEMENTATION
*--------------------------------------------------------------------*
CLASS lcl_ztct IMPLEMENTATION.

  METHOD constructor.
    DATA: ra_project_trkorrs            TYPE RANGE OF trkorr.
    DATA: st_project_trkorrs            LIKE LINE OF ra_project_trkorrs.

    lp_alert0_text = &apos;Log couldn&apos;&apos;t be read or TP not released&apos;(w16).
    lp_alert1_text = &apos;Transport not released&apos;(w19).
    lp_alert2_text = &apos;Release started&apos;(w20).
    lp_alert3_text = &apos;Transport not in Transport Buffer&apos;(m12).
    lp_hint1_text  = &apos;Newer version in Acceptance, but in list&apos;(w22).
    lp_hint2_text  = &apos;All conflicts are dealt with by the list&apos;(w04).
    lp_hint3_text  = &apos;Couldn&apos;&apos;t read log, but object in list&apos;(w21).
    lp_hint4_text  = &apos;Overwrites version(s), newer version in list&apos;(w11).
    lp_warn_text   = &apos;Previous transport not transported&apos;(w17).
    lp_error_text  = &apos;Newer version in production!&apos;(w01).
    lp_ddic_text   = &apos;Uses object not in list or production&apos;(w03).
    lp_info_text   = &apos;Newer version in Acceptance&apos;(w23).
*   Create a range table containing all project transport numbers.
*   When selecting transports, these can be skipped.
    st_project_trkorrs-sign = &apos;I&apos;.
    st_project_trkorrs-option = &apos;EQ&apos;.
    SELECT trkorr FROM ctsproject
                  INTO st_project_trkorrs-low.        &quot;#EC CI_SGLSELECT
      APPEND st_project_trkorrs TO me-&gt;project_trkorrs.
    ENDSELECT.
  ENDMETHOD.                    &quot;constructor

  METHOD execute.
    DATA: lp_cancelled TYPE abap_bool.
    IF process_type = 1.
      me-&gt;get_data( EXPORTING im_trkorr_range = trkorr_range ).
*     Table checks not possible for version checking.
      IF process_type = 1.
        me-&gt;build_table_keys_popup( ).
        me-&gt;add_table_keys_to_list( IMPORTING table = me-&gt;main_list ).
      ENDIF.
      me-&gt;get_additional_tp_info( CHANGING ch_table = me-&gt;main_list ).
*     First selection: If the flag to exclude transport that are already
*     in production is set, remove all these transports from the main
*     list.
      IF skiplive IS NOT INITIAL.
        me-&gt;remove_tp_in_prd( ).
      ENDIF.
* Reason to check data dictionary objects:
* If objects in the transport list contain DDIC objects that do NOT
* exist in production and do NOT exist in the transport list, errors
* (DUMPS) will happen when the transports are moved to production.
* Checking steps:
*   1. Get all Z-objects in tables DD01L, DD02L and DD04L (Domains,
*      Tables, Elements)
*   2. Get all transports from E071 containing these objects
*   3. Store the link between Transports and Objects in attribute WHERE_USED
*   4. Remove from the table all records for objects/transports that have
*       been transported to production
*   5. Execute a Where-Used on all remaining objects
*   6. If there are Objects in the main transport list, that are ALSO in
*     the Where-Used list then THE TRANSPORT CANNOT GO TO PRODUCTION!
      IF check_ddic = abap_true.
        me-&gt;prepare_ddic_check( ).
      ENDIF.
      me-&gt;check_for_conflicts( CHANGING ch_main_list = me-&gt;main_list ).
    ELSE.
      me-&gt;gui_upload( EXPORTING im_filename  = filename
                      IMPORTING ex_cancelled = lp_cancelled ).
      IF lp_cancelled = abap_true.
        EXIT.
      ENDIF.
    ENDIF.
    me-&gt;set_color( ).
    me-&gt;alv_init( ).
    me-&gt;alv_set_properties( EXPORTING im_table = rf_table ).
    me-&gt;alv_set_tooltips( EXPORTING im_table = rf_table ).
    me-&gt;alv_output( ).
  ENDMETHOD.                    &quot;execute

  METHOD get_data.
    me-&gt;refresh_import_queues( ).
    me-&gt;get_main_transports( EXPORTING im_trkorr_range = im_trkorr_range ).
  ENDMETHOD.                    &quot;get_data

  METHOD: get_tp_prefix.
    IF me-&gt;prefix IS INITIAL.
*     Build transport prefix
      IF im_dev IS SUPPLIED.
        set_tp_prefix( EXPORTING im_dev = im_dev ).
      ELSE.
        set_tp_prefix( ).
      ENDIF.
    ENDIF.
    re_tp_prefix = me-&gt;prefix.
  ENDMETHOD.                    &quot;set_tp_prefix

  METHOD: set_tp_prefix.
*   Build transport prefix:
    IF im_dev IS SUPPLIED.
      CONCATENATE im_dev &apos;K%&apos; INTO me-&gt;prefix.
    ELSE.
      CONCATENATE sy-sysid &apos;K%&apos; INTO me-&gt;prefix.
    ENDIF.
  ENDMETHOD.                    &quot;set_tp_prefix

  METHOD: refresh_import_queues.
    CALL FUNCTION &apos;TMS_MGR_REFRESH_IMPORT_QUEUES&apos;.
  ENDMETHOD.                    &quot;refresh_import_queues

  METHOD: flag_for_process.
    DATA: ra_trkorr TYPE RANGE OF trkorr.
    DATA: ls_trkorr LIKE LINE OF ra_trkorr.
    DATA: ls_row      TYPE int4.
    IF rows IS INITIAL AND cell IS INITIAL.
      MESSAGE i000(db) WITH &apos;Please select records or put the cursor on a row&apos;(m10).
      EXIT.
    ENDIF.
*   First clear all the flags:
    me-&gt;clear_flags( ).
*   If the DDIC check is OFF, but there ARE DDIC warnings in the list,
*   then we need to flag these records to be checked. If that is not
*   done then the DDIC warning icon would stay, even if the missing
*   DDIC object would be added to the list...
    IF me-&gt;check_ddic = abap_false.
      LOOP AT me-&gt;main_list INTO  me-&gt;main_list_line
                            WHERE warning_lvl = co_ddic.
        me-&gt;main_list_line-flag = abap_true.
        MODIFY me-&gt;main_list FROM me-&gt;main_list_line INDEX sy-tabix TRANSPORTING flag.
      ENDLOOP.
    ENDIF.
*   If row(s) are selected, use the table
    LOOP AT rows INTO ls_row.
      me-&gt;main_list_line-flag = abap_true.
      MODIFY me-&gt;main_list FROM me-&gt;main_list_line INDEX ls_row TRANSPORTING flag.
    ENDLOOP.
*   If no rows were selected, take the current cell instead
    IF sy-subrc &lt;&gt; 0.
      READ TABLE me-&gt;main_list INTO me-&gt;main_list_line INDEX cell-row.
      me-&gt;main_list_line-flag = abap_true.
      MODIFY me-&gt;main_list FROM me-&gt;main_list_line INDEX cell-row TRANSPORTING flag.
    ENDIF.
  ENDMETHOD.                    &quot;flag_for_process

  METHOD: check_for_conflicts.
    DATA: ls_ddic_conflict_info TYPE ty_request_details.
    DATA: ta_stms_wbo_requests TYPE TABLE OF stms_wbo_request,
          st_stms_wbo_requests TYPE stms_wbo_request.
    DATA: lp_counter           TYPE i.
    DATA: lp_tabix             TYPE sytabix.
    DATA: lp_return            TYPE c.
    DATA: lp_exit              TYPE abap_bool.
    DATA: ls_main              TYPE ty_request_details.
    DATA: ls_line_temp         TYPE ty_request_details.
    DATA: lt_newer_transports  TYPE tt_request_details.
    DATA: lt_older_transports  TYPE tt_request_details.
    DATA: ls_newer_line        TYPE ty_request_details.
    DATA: ls_older_line        TYPE ty_request_details.
    DATA: lp_domnam            TYPE char10.
    DATA: lp_highest_lvl       TYPE icon_d.
    DATA: lp_highest_rank      TYPE numc4.
    DATA: lp_highest_text      TYPE text74.
    DATA: lp_highest_col       TYPE lvc_t_scol.
    DATA: lp_target            TYPE tmssysnam.
    DATA: lp_obj_name          TYPE trobj_name.
    REFRESH: me-&gt;conflicts.
    CLEAR:   me-&gt;conflict_line,
             me-&gt;total.
    CHECK me-&gt;check_flag = abap_true.
*   For each transports, all the objects in the transport will be checked.
*   If there is a newer version of an object in prd, then a warning will
*   be displayed. Also if a newer version that was in prd was actually
*   overwritten or if an object could not be checked.
*   Total for progress indicator: How many will be checked?
    CLEAR: lp_counter.
    LOOP AT ch_main_list INTO ls_main WHERE prd &lt;&gt; co_okay
                                      AND   dev &lt;&gt; co_error
                                      AND   flag = abap_true.
      me-&gt;total = me-&gt;total + 1.
    ENDLOOP.

*   Check each object in the main list, that has been flagged (also allow
*   checking of transports in prd, those may have been added for transport
*   again):
    LOOP AT ch_main_list INTO ls_main WHERE prd  &lt;&gt; co_okay
                                      AND   dev  &lt;&gt; co_error
                                      AND   flag =  abap_true.
      CLEAR: me-&gt;conflict_line.
      CLEAR: ls_main-warning_lvl,
             ls_main-warning_rank,
             ls_main-warning_txt.
      lp_tabix = sy-tabix.
*     Show the progress indicator
      lp_counter = lp_counter + 1.
      me-&gt;progress_indicator( EXPORTING im_counter = lp_counter
                                        im_object  = ls_main-obj_name
                                        im_total   = me-&gt;total
                                        im_text    = &apos;Objects checked&apos;(011)
                                        im_flag    = &apos; &apos; ).
*     The CHECKED flag is useful to check if the check has been carried
*     out. On the selection screen, you can choose to clear the flags
*     (which can be useful if the file is old and needs to be rechecked)
*     This flag will aid the user when the user checks the list in
*     stages (Example: Half today and the other half tomorrow).
*     st_main-checked is set here to &apos;X&apos;. It will be updated later when
*     the check has been executed and the main list updated with the
*     change.
      ls_main-checked = co_checked.
      MODIFY ch_main_list FROM ls_main TRANSPORTING checked.
*     Check for documentation:
      me-&gt;check_documentation( EXPORTING im_trkorr = ls_main-trkorr
                               CHANGING  ch_table  = ch_main_list ).
*     The check is only relevant if transport is in QAS or DEV! Check is
*     skipped for the transports, already in prd.
      IF ls_main-qas = co_okay.
        MOVE me-&gt;prd_system TO lp_target.
      ENDIF.
*     Now check the object:
      me-&gt;get_tps_for_same_object( EXPORTING im_line  = ls_main
                                   IMPORTING ex_newer = lt_newer_transports
                                             ex_older = lt_older_transports ).
*     Compare version in QAS with version in prd
*     If a newer version/request is found in prd, then add a warning and
*     continue with the next.
      IF NOT lt_newer_transports[] IS INITIAL.
        LOOP AT lt_newer_transports INTO ls_newer_line.  &quot;#EC CI_NESTED
*         Get transport description:
          SELECT SINGLE as4text FROM  e07t
                                INTO  ls_newer_line-tr_descr
                                WHERE trkorr = ls_newer_line-trkorr
                                AND   langu  = &apos;E&apos;.  &quot;#EC CI_SEL_NESTED
*         Check if it has been transported to the target system:
          CLEAR: ta_stms_wbo_requests.
          CALL FUNCTION &apos;TMS_MGR_READ_TRANSPORT_REQUEST&apos;
            EXPORTING
              iv_request                 = ls_newer_line-trkorr
              iv_target_system           = lp_target
              iv_header_only             = &apos;X&apos;
              iv_monitor                 = &apos; &apos;
            IMPORTING
              et_request_infos           = ta_stms_wbo_requests
            EXCEPTIONS
              read_config_failed         = 1
              table_of_requests_is_empty = 2
              system_not_available       = 3
              OTHERS                     = 4.
          IF sy-subrc &lt;&gt; 0.
            MESSAGE ID sy-msgid TYPE sy-msgty NUMBER sy-msgno
                    WITH sy-msgv1 sy-msgv2 sy-msgv3 sy-msgv4.
          ENDIF.
          READ TABLE ta_stms_wbo_requests INDEX 1
                             INTO st_stms_wbo_requests.
          IF st_stms_wbo_requests-e070 IS NOT INITIAL.
*           Only display the warning if the preceding transport is not
*           one of the selected transports (and in an earlier
*           position)
            me-&gt;check_if_same_object( EXPORTING im_line        = ls_main
                                                im_newer_older = ls_newer_line
                                      IMPORTING ex_tabkey      = tp_tabkey
                                                ex_return      = lp_return ).
            CHECK lp_return = abap_true.
*           Fill conflict list
            MOVE-CORRESPONDING ls_newer_line TO me-&gt;conflict_line.
            me-&gt;conflict_line-warning_lvl  = co_error.
            me-&gt;conflict_line-warning_rank = co_error_rank.
            me-&gt;conflict_line-warning_txt  = lp_error_text.
            me-&gt;conflict_line-objkey       = tp_tabkey.
*           Get the last date the object was imported
            me-&gt;get_import_datetime_qas( EXPORTING im_trkorr  = ls_older_line-trkorr
                                         IMPORTING ex_as4time = me-&gt;conflict_line-as4time
                                                   ex_as4date = me-&gt;conflict_line-as4date ).
*           Check if the transport is in the list
*           Display the warning if the preceding transport is not
*           in the main list. If it is, then display the hint icon.
            READ TABLE ch_main_list
                 INTO  ls_line_temp
                 WITH KEY trkorr = ls_newer_line-trkorr
                 TRANSPORTING prd.
            IF sy-subrc = 0.
              IF ls_line_temp-prd = co_scrap.
*               This newer version is in the list and made visible:
                me-&gt;conflict_line-warning_lvl = co_scrap.
              ENDIF.
            ELSE.
              APPEND: me-&gt;conflict_line TO me-&gt;conflicts.
              CLEAR:  me-&gt;conflict_line.
            ENDIF.
          ELSE.
            me-&gt;check_if_in_list( EXPORTING im_line  = ls_newer_line
                                            im_tabix = lp_tabix
                                  IMPORTING ex_line  = me-&gt;line_found_in_list ).
            IF me-&gt;line_found_in_list IS NOT INITIAL.
*             Even if the transport is only in QAS and not in prd (so a
*             newer transport exists, but will not be overwritten), we still
*             want to let the user now about it. To prevent that a newer
*             development exists and should go to production, but it might
*             be forgotten if not selected....
              ls_newer_line-warning_lvl  = ls_main-warning_lvl  = co_hint.
              ls_newer_line-warning_rank = ls_main-warning_rank = co_hint2_rank.
              ls_newer_line-warning_txt  = ls_main-warning_txt  = lp_hint2_text.
*             No need to check further. A newer transport was found but because
*             that newer transport is in the list, we can stop checking for newer
*             transports because that will be done for the transport that is in
*             the list.
              lp_exit = abap_true.
            ELSE.
*             The transport is not yet transported, but if it is found
*             further down in the list, it is okay. Change the warning level
*             from ERROR to INFO.
              ls_newer_line-warning_lvl  = ls_main-warning_lvl  = co_info.
              ls_newer_line-warning_rank = ls_main-warning_rank = co_info_rank.
              ls_newer_line-warning_txt  = ls_main-warning_txt  = lp_info_text.
            ENDIF.
            MOVE-CORRESPONDING ls_newer_line TO me-&gt;conflict_line.
            APPEND: me-&gt;conflict_line TO me-&gt;conflicts.
            CLEAR:  me-&gt;conflict_line.
            IF lp_exit = abap_true.
              EXIT.
            ENDIF.
          ENDIF.
        ENDLOOP.
      ENDIF.
*     Select all the transports that are older. These will be checked to
*     see if they have been moved to prd. If the older version has been
*     transported, it is okay.
*     If not, then add a warning and continue with the next record.
      IF NOT lt_older_transports[] IS INITIAL.
        LOOP AT lt_older_transports INTO ls_older_line.  &quot;#EC CI_NESTED
*         Get transport description:
          SELECT SINGLE as4text FROM  e07t
                                INTO  ls_older_line-tr_descr
                                WHERE trkorr = ls_older_line-trkorr
                                AND   langu  = &apos;E&apos;.  &quot;#EC CI_SEL_NESTED
*         Check if it has been transported to QAS
          CLEAR: ta_stms_wbo_requests.
          CALL FUNCTION &apos;TMS_MGR_READ_TRANSPORT_REQUEST&apos;
            EXPORTING
              iv_request                 = ls_older_line-trkorr
              iv_target_system           = lp_target
              iv_header_only             = &apos;X&apos;
              iv_monitor                 = &apos; &apos;
            IMPORTING
              et_request_infos           = ta_stms_wbo_requests
            EXCEPTIONS
              read_config_failed         = 1
              table_of_requests_is_empty = 2
              system_not_available       = 3
              OTHERS                     = 4.
          IF sy-subrc &lt;&gt; 0.
            MESSAGE ID sy-msgid TYPE sy-msgty NUMBER sy-msgno
                    WITH sy-msgv1 sy-msgv2 sy-msgv3 sy-msgv4.
          ENDIF.
*         Was an older transport found that has not yet gone to EEP?
          READ TABLE ta_stms_wbo_requests INDEX 1
                                          INTO st_stms_wbo_requests.
          IF st_stms_wbo_requests-e070 IS INITIAL.
            me-&gt;check_if_same_object( EXPORTING im_line        = ls_main
                                                im_newer_older = ls_older_line
                                      IMPORTING ex_tabkey      = tp_tabkey
                                                ex_return      = lp_return ).
            IF lp_return = abap_true.                      &quot;Yes, same object!
              MOVE-CORRESPONDING ls_older_line TO me-&gt;conflict_line.
*             Get the last date the object was imported
              me-&gt;get_import_datetime_qas( EXPORTING im_trkorr  = ls_older_line-trkorr
                                           IMPORTING ex_as4time = me-&gt;conflict_line-as4time
                                                     ex_as4date = me-&gt;conflict_line-as4date ).
              me-&gt;conflict_line-warning_lvl  = co_warn.
              me-&gt;conflict_line-warning_rank = co_warn_rank.
              me-&gt;main_list_line-warning_txt = lp_warn_text.
              me-&gt;conflict_line-objkey       = tp_tabkey.
*             Check if the transport is in the list
*             Display the warning if the preceding transport is not
*             in the main list. If it is, then display the hint icon.
              READ TABLE ch_main_list
                   WITH KEY trkorr = ls_older_line-trkorr
                   TRANSPORTING NO FIELDS.
              IF sy-subrc = 0.
*               There is a warning but the conflicting transport is
*               ALSO in the list. Display the HINT Icon. The other
*               transport will be checked too, sooner or later...
                me-&gt;conflict_line-warning_lvl  = co_hint.
                me-&gt;conflict_line-warning_rank = co_hint2_rank.
                me-&gt;conflict_line-warning_txt  = lp_hint2_text.
              ENDIF.
*             Check if transport has been released.
*             D - Modifiable
*             L - Modifiable, protected
*             A - Modifiable, protected
*             O - Release started
*             R - Released
*             N - Released (with import protection for repaired objects)
              REFRESH: ta_stms_wbo_requests.
              CLEAR:   ta_stms_wbo_requests.
              CALL FUNCTION &apos;TMS_MGR_READ_TRANSPORT_REQUEST&apos;
                EXPORTING
                  iv_request                 = ls_older_line-trkorr
                  iv_target_system           = me-&gt;dev_system
                  iv_header_only             = &apos;X&apos;
                  iv_monitor                 = &apos; &apos;
                IMPORTING
                  et_request_infos           = ta_stms_wbo_requests
                EXCEPTIONS
                  read_config_failed         = 1
                  table_of_requests_is_empty = 2
                  system_not_available       = 3
                  OTHERS                     = 4.
              IF sy-subrc &lt;&gt; 0.
                MESSAGE ID sy-msgid TYPE sy-msgty NUMBER sy-msgno
                        WITH sy-msgv1 sy-msgv2 sy-msgv3 sy-msgv4.
              ENDIF.
              READ TABLE ta_stms_wbo_requests INDEX 1
                                              INTO st_stms_wbo_requests.
              IF st_stms_wbo_requests-e070-trstatus NA &apos;NR&apos;.
                me-&gt;conflict_line-warning_lvl  = co_alert.
                me-&gt;conflict_line-warning_rank = co_alert1_rank.
                me-&gt;conflict_line-warning_txt  = lp_alert1_text.
              ELSEIF st_stms_wbo_requests-e070-trstatus = &apos;O&apos;.
                me-&gt;conflict_line-warning_lvl  = co_alert.
                me-&gt;conflict_line-warning_rank = co_alert2_rank.
                me-&gt;conflict_line-warning_txt  = lp_alert2_text.
              ENDIF.
              APPEND: me-&gt;conflict_line TO me-&gt;conflicts.
              CLEAR:  me-&gt;conflict_line.
            ENDIF.
          ELSE.
*           When the first earlier transported version is found,
*           the check must be ended.
            EXIT.
          ENDIF.
        ENDLOOP.
      ENDIF.
*     Determine highest warning level in conflict list
*     Only when NOT building the conflict popup
      IF me-&gt;building_conflict_popup = abap_false.
        CLEAR: lp_highest_lvl,
               lp_highest_rank,
               lp_highest_text,
               lp_highest_col.
        LOOP AT me-&gt;conflicts INTO me-&gt;conflict_line.    &quot;#EC CI_NESTED
          IF me-&gt;conflict_line-warning_rank &gt; lp_highest_rank.
            lp_highest_lvl  = me-&gt;conflict_line-warning_lvl.
            lp_highest_rank = me-&gt;conflict_line-warning_rank.
            lp_highest_col  = me-&gt;conflict_line-t_color.
            me-&gt;determine_warning_text( EXPORTING im_highest_rank = lp_highest_rank
                                        IMPORTING ex_highest_text = lp_highest_text ).
          ENDIF.
        ENDLOOP.
        ls_main-warning_lvl  = lp_highest_lvl.
        ls_main-warning_rank = lp_highest_rank.
        ls_main-warning_txt  = lp_highest_text.
        ls_main-t_color      = lp_highest_col.
        MODIFY: ch_main_list FROM ls_main TRANSPORTING warning_lvl
                                                       warning_rank
                                                       warning_txt
                                                       t_color.
      ENDIF.
*     Refresh the conflict table. But, if the conflict popup is being build
*     for one or more lines, then do NOT refresh the conflict table. Display
*     ALL conflicts for all selected lines.
      IF me-&gt;building_conflict_popup = abap_false.
        REFRESH: me-&gt;conflicts.
      ENDIF.
    ENDLOOP.

*   Update the conflict table and the main list with DDIC information
    me-&gt;do_ddic_check( CHANGING ch_main_list = ch_main_list ).

*   Check if the transport is in Transport Buffer
*   TMS_MGR_REFRESH_IMPORT_QUEUES updates this table
    CLEAR:lp_counter.
    IF me-&gt;skip_buffer_chk         = abap_false AND &quot; X = Skip buffer check.
       me-&gt;building_conflict_popup = abap_false.    &quot; Never when building popup
      LOOP AT ch_main_list INTO ls_main WHERE prd  &lt;&gt; co_okay
                                        AND   dev  &lt;&gt; co_error
                                        AND   flag =  abap_true.
*       Show the progress indicator
        lp_counter = lp_counter + 1.
        me-&gt;progress_indicator( EXPORTING im_counter = lp_counter
                                          im_object  = ls_main-obj_name
                                          im_total   = me-&gt;total
                                          im_text    = &apos;Checking buffer&apos;(050)
                                          im_flag    = &apos; &apos; ).
        CLEAR: lp_domnam.
        SELECT SINGLE domnam INTO  lp_domnam FROM tmsbuffer
                             WHERE trkorr EQ ls_main-trkorr
                             AND   sysnam EQ me-&gt;prd_system. &quot;#EC CI_SEL_NESTED
        IF sy-subrc EQ 4.
*          ls_main-checked = co_okay.
          ls_main-warning_lvl  = co_alert.
          ls_main-warning_rank = co_alert3_rank.
          ls_main-warning_txt  = lp_alert3_text.
          MODIFY ch_main_list FROM  ls_main.
        ENDIF.
      ENDLOOP.
    ENDIF.
*   Sort ta_conflicts by date time stamp, descending. Most recent should
*   be displayed first:
    SORT me-&gt;conflicts BY as4date DESCENDING
                          as4time DESCENDING
                          trkorr  DESCENDING.
    DELETE ADJACENT DUPLICATES FROM me-&gt;conflicts
                               COMPARING trkorr object obj_name.
  ENDMETHOD.                    &quot;check_for_conflicts

  METHOD: build_table_keys_popup.
*   A popup is displayed with all tables found in the main list, that
*   have keys. The user has now the option to include them in the
*   checking procedure. This is the only place where the user has a
*   complete overview of the tables that have been found...
*   Declaration for ALV Columns
    DATA: lr_columns_table       TYPE REF TO cl_salv_columns_table.
    DATA: lr_column_table        TYPE REF TO cl_salv_column_table.
    DATA: lt_t_column_ref        TYPE salv_t_column_ref.
    DATA: ls_reference           TYPE salv_s_ddic_reference.
    DATA: ls_s_column_ref        TYPE salv_s_column_ref.
    DATA: st_colo                TYPE lvc_s_colo.
    DATA: lr_events              TYPE REF TO cl_salv_events_table.
*   Declaration for Global Display Settings
    DATA: lr_display_settings    TYPE REF TO cl_salv_display_settings.
*   Declaration for Table Selection settings
    DATA: lr_selections          TYPE REF TO cl_salv_selections.
    DATA: lp_title               TYPE lvc_title.
    DATA: lp_tp_prefix           TYPE char5.
    DATA: lp_xstart              TYPE i VALUE 26.
    DATA: lp_xend                TYPE i.
    DATA: lp_ystart              TYPE i VALUE 7.
    DATA: lp_yend                TYPE i.
    DATA: lp_cw_tabname          TYPE lvc_outlen.  &quot;Length
    DATA: lp_cw_counter          TYPE lvc_outlen.  &quot;Length
    DATA: lp_cw_ddtext           TYPE lvc_outlen.  &quot;Length
    lp_title = &apos;Keys can be checked for &apos; &amp;
               &apos;the following tables&apos;(t02).
*   Only if the option to check for table keys is switched ON and
*   checking is active
    CHECK: me-&gt;check_tabkeys = abap_true AND
           me-&gt;check_flag    = abap_true.
* Determine the transport prefix (if not done already)
    lp_tp_prefix = me-&gt;get_tp_prefix( im_dev = me-&gt;dev_system ).
*   Fill the internal table to be displayed in the popup:
    LOOP AT me-&gt;main_list INTO  me-&gt;main_list_line
                          WHERE objfunc    = &apos;K&apos;
                          AND   keyobject  IS INITIAL
                          AND   keyobjname IS INITIAL
                          AND   obj_name   IN excluded_objects.
      CLEAR: table_keys_line.
      SELECT ddtext FROM  dd02t
                    UP TO 1 ROWS
                    INTO  table_keys_line-ddtext
                    WHERE ddlanguage = sy-langu
                    AND   tabname    = me-&gt;main_list_line-obj_name. &quot;#EC CI_SEL_NESTED
      ENDSELECT.
*     Count the keys...
      SELECT COUNT(*)
              FROM  e071k INTO table_keys_line-counter
              WHERE trkorr     =  me-&gt;main_list_line-trkorr
              AND   mastertype =  me-&gt;main_list_line-object
              AND   NOT trkorr IN  me-&gt;project_trkorrs
              AND   trkorr LIKE lp_tp_prefix
              AND   objname    IN excluded_objects.  &quot;#EC CI_SEL_NESTED
      table_keys_line-tabname  = me-&gt;main_list_line-obj_name.
      COLLECT table_keys_line INTO table_keys.
    ENDLOOP.
    DELETE table_keys WHERE counter = 0.
    CHECK NOT table_keys[] IS INITIAL.
    SORT  table_keys BY counter DESCENDING.
*   Determine total width
    LOOP AT table_keys INTO table_keys_line.
      me-&gt;determine_col_width( EXPORTING im_field    = table_keys_line-tabname
                               IMPORTING ex_colwidth = lp_cw_tabname ).
      me-&gt;determine_col_width( EXPORTING im_field    = table_keys_line-counter
                               IMPORTING ex_colwidth = lp_cw_counter ).
      me-&gt;determine_col_width( EXPORTING im_field    = table_keys_line-ddtext
                               IMPORTING ex_colwidth = lp_cw_ddtext ).
    ENDLOOP.

    lp_xend = lp_cw_tabname + lp_cw_counter + lp_cw_ddtext.

    TRY.
        CALL METHOD cl_salv_table=&gt;factory
          IMPORTING
            r_salv_table = rf_table_keys
          CHANGING
            t_table      = table_keys.
*   Global display settings
        lr_display_settings = rf_table_keys-&gt;get_display_settings( ).
*   Activate Striped Pattern
        lr_display_settings-&gt;set_striped_pattern( if_salv_c_bool_sap=&gt;true ).
*   Report header
        lr_display_settings-&gt;set_list_header( lp_title ).
*       Table Selection Settings
        lr_selections = rf_table_keys-&gt;get_selections( ).
        IF lr_selections IS NOT INITIAL.
*         Allow row and column Selection (Adds checkbox)
          lr_selections-&gt;set_selection_mode(
                          if_salv_c_selection_mode=&gt;row_column ).
        ENDIF.
*       Get the columns from ALV Table
        lr_columns_table = rf_table_keys-&gt;get_columns( ).
        IF lr_columns_table IS NOT INITIAL.
          REFRESH : lt_t_column_ref.
          lt_t_column_ref = lr_columns_table-&gt;get( ).
*         Get columns properties
          lr_columns_table-&gt;set_optimize( if_salv_c_bool_sap=&gt;true ).
          lr_columns_table-&gt;set_key_fixation( if_salv_c_bool_sap=&gt;true ).
*         Individual Column Properties.
          LOOP AT lt_t_column_ref INTO ls_s_column_ref.
            TRY.
                lr_column_table ?=
                  lr_columns_table-&gt;get_column( ls_s_column_ref-columnname ).
              CATCH cx_salv_not_found INTO rf_root.
                me-&gt;handle_error( EXPORTING rf_oref = rf_root ).
            ENDTRY.
            CASE lr_column_table-&gt;get_columnname( ).
              WHEN &apos;COUNTER&apos;.
                ls_reference-table = &apos;UGMD_S_STOP_CONDITION&apos;.
                ls_reference-field = &apos;NUMBER_OF_RESULTS&apos;.
                lr_column_table-&gt;set_ddic_reference( ls_reference ).
                lr_column_table-&gt;set_alignment( if_salv_c_alignment=&gt;centered ).
            ENDCASE.
          ENDLOOP.
        ENDIF.
*       Register handler for actions
        lr_events = rf_table_keys-&gt;get_event( ).
        SET HANDLER lcl_eventhandler_ztct=&gt;on_function_click FOR lr_events.
*       Save reference to access object from handler
        lcl_eventhandler_ztct=&gt;rf_table_keys = rf_table_keys.
*       Use gui-status ST850 from program SAPLKKB
        rf_table_keys-&gt;set_screen_status( pfstatus = &apos;ST850&apos;
                                          report   = &apos;SAPLKKBL&apos; ).
*       Determine the size of the popup window:
        lp_xend = lp_xend + lp_xstart + 5.
        DESCRIBE TABLE table_keys LINES lp_yend.
        lp_yend = lp_yend + lp_ystart.
*       Display as popup
        rf_table_keys-&gt;set_screen_popup( start_column = lp_xstart
                                         end_column   = lp_xend
                                         start_line   = lp_ystart
                                         end_line     = lp_yend ).
        rf_table_keys-&gt;display( ).
      CATCH cx_salv_msg INTO rf_root.
        me-&gt;handle_error( EXPORTING rf_oref = rf_root ).
    ENDTRY.
  ENDMETHOD.                    &quot;build_table_keys_popup

  METHOD: add_table_keys_to_list .
    DATA: lt_keys             TYPE tt_request_details.
    DATA: ls_keys             TYPE ty_request_details.
*   Only if the option to check for table keys is switched ON, on the
*   selection screen:
    CHECK: check_tabkeys = abap_true.
*   Check if keys exist in table E071K. Only do this for the records
*   that have not been added already (without key object and name)
*   Remove the entries for which that is the case and add the objects,
*   with the keys.
*   s_exobj contains all tables that we do not want to check.
    LOOP AT table INTO ls_keys WHERE objfunc    = &apos;K&apos;
                               AND   keyobject  IS INITIAL
                               AND   keyobjname IS INITIAL
                               AND   obj_name   IN excluded_objects.  &quot;Exclude
      SELECT object objname tabkey
             FROM e071k
             INTO (ls_keys-keyobject,
                   ls_keys-keyobjname,
                   ls_keys-tabkey)
             WHERE trkorr     =  ls_keys-trkorr
             AND   mastertype =  ls_keys-object
             AND   mastername =  ls_keys-obj_name
             AND   NOT trkorr IN  me-&gt;project_trkorrs
             AND   trkorr     LIKE me-&gt;prefix
             AND   objname    IN excluded_objects.   &quot;#EC CI_SEL_NESTED
        APPEND ls_keys TO lt_keys.
      ENDSELECT.
    ENDLOOP.
    SORT lt_keys.
    DELETE ADJACENT DUPLICATES FROM lt_keys.
*   Add the entries for the table keys, and remove the root objects.
    LOOP AT lt_keys INTO ls_keys.
      DELETE table WHERE objfunc  = &apos;K&apos;
                   AND   trkorr   = ls_keys-trkorr
                   AND   object   = ls_keys-object
                   AND   obj_name = ls_keys-obj_name.
    ENDLOOP.
    APPEND LINES OF lt_keys TO table.
  ENDMETHOD.                    &quot;add_table_keys_to_list

  METHOD progress_indicator.
    DATA: lp_gprogtext         TYPE char1024.
    DATA: lp_gprogperc(4)      TYPE p DECIMALS 0.
    DATA: lp_gproggui          TYPE i.
    DATA: lp_step              TYPE i VALUE 1.
    DATA: lp_difference        TYPE i.
    DATA: lp_string            TYPE string.
    DATA: lp_total             TYPE numc10.
    DATA: lp_counter_reset     TYPE i.
*   IM_TOTAL cannot be changed, and we need to remove the leading
*   zero&apos;s. That is why intermediate parameter lp_TOTAL was added
    lp_total = im_total.
    lp_difference = lp_total - im_counter.
*   Determine step size
    IF im_flag = abap_true.
      IF lp_difference &lt; 100.
        lp_step = 1.
      ELSEIF lp_difference &lt; 1000.
        lp_step = 50.
      ELSE.
        lp_step = 100.
      ENDIF.
    ENDIF.
*   Number of selected items on GUI:
    CHECK lp_step &lt;&gt; 0.
    lp_gproggui = im_counter MOD lp_step.
    IF lp_gproggui = 0.
      WRITE im_counter TO lp_gprogtext LEFT-JUSTIFIED.
      IF lp_total &lt;&gt; 0.
        SHIFT lp_total LEFT DELETING LEADING &apos;0&apos;.
        CONCATENATE lp_gprogtext &apos;of&apos; lp_total
                    INTO lp_gprogtext SEPARATED BY &apos; &apos;.
      ENDIF.
      IF im_object IS NOT INITIAL.
        CONCATENATE &apos;(&apos; im_object &apos;)&apos;
                    INTO lp_string.
        CONDENSE lp_string.
      ENDIF.
      CONCATENATE lp_gprogtext im_text lp_string
                  INTO lp_gprogtext
                  SEPARATED BY &apos; &apos;.
      CONDENSE lp_gprogtext.
      CALL FUNCTION &apos;SAPGUI_PROGRESS_INDICATOR&apos;
        EXPORTING
          percentage = lp_gprogperc
          text       = lp_gprogtext.
    ENDIF.

* To avoid timeouts
    lp_counter_reset = im_counter MOD 50.
    IF lp_counter_reset = 0.
      CALL FUNCTION &apos;TH_REDISPATCH&apos;.
    ENDIF.

  ENDMETHOD.                    &quot;progress_indicator

  METHOD get_main_transports.
    DATA: ta_main_list_vrsd  TYPE tt_request_details.
    DATA: st_main_list_vrsd  TYPE ty_request_details.
    DATA: lp_return          TYPE c.
    FIELD-SYMBOLS: &lt;l_main_list&gt; TYPE ty_request_details.
    REFRESH: ta_main_list_vrsd.
    CALL FUNCTION &apos;SAPGUI_PROGRESS_INDICATOR&apos;
      EXPORTING
        text = &apos;Selecting data...&apos;(014).
*   Join over E070, E071:
*   Description is read later to prevent complicated join and
*   increased runtime
    SELECT a~trkorr   a~trfunction a~trstatus
           a~as4user  a~as4date    a~as4time
           b~object   b~obj_name   b~objfunc
           INTO (me-&gt;main_list_line-trkorr,
                 me-&gt;main_list_line-trfunction,
                 me-&gt;main_list_line-trstatus,
                 me-&gt;main_list_line-as4user,
                 me-&gt;main_list_line-as4date,
                 me-&gt;main_list_line-as4time,
                 me-&gt;main_list_line-object,
                 me-&gt;main_list_line-obj_name,
                 me-&gt;main_list_line-objfunc)
           FROM  e070 AS a JOIN e071 AS b
             ON  a~trkorr  = b~trkorr
           WHERE a~trkorr  IN im_trkorr_range
           AND   strkorr   = &apos;&apos;
           AND   a~trkorr  LIKE me-&gt;prefix
           AND ( pgmid     = &apos;LIMU&apos; OR
                 pgmid     = &apos;R3TR&apos; ).
*     If the transports should be checked, flag it.
      me-&gt;main_list_line-flag = abap_true.
      APPEND me-&gt;main_list_line TO me-&gt;main_list.
      CLEAR me-&gt;main_list_line.
    ENDSELECT.
*   Read transport description:
    IF me-&gt;main_list[] IS NOT INITIAL.
      LOOP AT me-&gt;main_list ASSIGNING &lt;l_main_list&gt;.
        SELECT SINGLE  as4text
                 FROM  e07t
                 INTO &lt;l_main_list&gt;-tr_descr
                 WHERE trkorr = &lt;l_main_list&gt;-trkorr
                 AND   langu  = sy-langu.            &quot;#EC CI_SEL_NESTED
      ENDLOOP.
    ENDIF.
    SORT me-&gt;main_list.
    DELETE ADJACENT DUPLICATES FROM me-&gt;main_list.
*   Only continue if there are transports to check...
    CHECK NOT me-&gt;main_list[] IS INITIAL.
*   Check if project is in selection range:
    IF project_range IS NOT INITIAL.
      LOOP AT me-&gt;main_list INTO me-&gt;main_list_line.
        lp_return = abap_false.
        SELECT reference
               FROM e070a
               INTO  me-&gt;main_list_line-project
               WHERE trkorr = me-&gt;main_list_line-trkorr
               AND   attribute = &apos;SAP_CTS_PROJECT&apos;.  &quot;#EC CI_SEL_NESTED
          IF me-&gt;main_list_line-project IN project_range.
            lp_return = abap_true.
            EXIT.
          ENDIF.
        ENDSELECT.
        IF lp_return = abap_false.
          DELETE me-&gt;main_list INDEX sy-tabix.
        ELSE.
*         Set check flag for all transports because it is the first
*         selection
          me-&gt;main_list_line-flag = abap_true.
          MODIFY me-&gt;main_list FROM me-&gt;main_list_line TRANSPORTING flag.
        ENDIF.
      ENDLOOP.
    ENDIF.
*   Check if the searchstring is in the transport description:
    IF NOT me-&gt;search_string IS INITIAL.
      LOOP AT me-&gt;main_list INTO me-&gt;main_list_line.
        IF me-&gt;search_string CS &apos;*&apos;.
          IF me-&gt;main_list_line-tr_descr NP me-&gt;search_string.
            DELETE me-&gt;main_list INDEX sy-tabix.
            CONTINUE.
          ENDIF.
        ELSE.
          IF me-&gt;main_list_line-tr_descr NS me-&gt;search_string.
            DELETE me-&gt;main_list INDEX sy-tabix.
            CONTINUE.
          ENDIF.
        ENDIF.
      ENDLOOP.
    ENDIF.
    CHECK me-&gt;main_list[] IS NOT INITIAL.
*   Also read from the version table VRSD. This table contains all
*   dependent objects. For example: If from E071 a function group
*   is retrieved, VRSD will contain all functions too.
    SELECT korrnum objtype objname
           author  datum zeit
           FROM  vrsd
           INTO (st_main_list_vrsd-trkorr,
                 st_main_list_vrsd-object,
                 st_main_list_vrsd-obj_name,
                 st_main_list_vrsd-as4user,
                 st_main_list_vrsd-as4date,
                 st_main_list_vrsd-as4time)
           FOR ALL ENTRIES IN me-&gt;main_list
           WHERE korrnum   =  me-&gt;main_list-trkorr.
      READ TABLE me-&gt;main_list INTO me-&gt;main_list_line
                               WITH KEY trkorr = st_main_list_vrsd-trkorr.
      MOVE: st_main_list_vrsd-object   TO me-&gt;main_list_line-object,
            st_main_list_vrsd-obj_name TO me-&gt;main_list_line-obj_name,
            st_main_list_vrsd-as4user  TO me-&gt;main_list_line-as4user,
            st_main_list_vrsd-as4date  TO me-&gt;main_list_line-as4date,
            st_main_list_vrsd-as4time  TO me-&gt;main_list_line-as4time.
*     Only append if the object from VRSD does not already exist in the
*     main list:
      READ TABLE me-&gt;main_list WITH KEY trkorr  = me-&gt;main_list_line-trkorr
                                        object   = me-&gt;main_list_line-object
                                        obj_name = me-&gt;main_list_line-obj_name
                                        TRANSPORTING NO FIELDS.
      IF sy-subrc &lt;&gt; 0.
        me-&gt;main_list_line-flag = abap_true.
        APPEND me-&gt;main_list_line TO ta_main_list_vrsd.
      ENDIF.
    ENDSELECT.
*   Duplicates may exist if the same object exists in different tasks
*   belonging to the same request:
    SORT ta_main_list_vrsd DESCENDING.
    DELETE ADJACENT DUPLICATES FROM ta_main_list_vrsd
                    COMPARING trkorr object obj_name.
*   Now add all VRSD entries to the main list:
    APPEND LINES OF ta_main_list_vrsd TO me-&gt;main_list.
    me-&gt;sort_main_list( ).
  ENDMETHOD.                    &quot;get_main_transports

  METHOD get_tp_info.
*   Join over E070, E071:
*   Description is read later to prevent complicated join and
*   increased runtime
    SELECT SINGLE a~trkorr  a~trfunction a~trstatus
                  a~as4user a~as4date  a~as4time
                  b~object  b~obj_name
           INTO (re_line-trkorr,
                 re_line-trfunction,
                 re_line-trstatus,
                 re_line-as4user,
                 re_line-as4date,
                 re_line-as4time,
                 re_line-object,
                 re_line-obj_name)
           FROM  e070 AS a JOIN e071 AS b
           ON    a~trkorr   = b~trkorr
           WHERE a~trkorr   = im_trkorr
           AND   strkorr    = &apos;&apos;
           AND   b~obj_name = im_obj_name.
*   Read transport description:
    SELECT SINGLE  as4text
             FROM  e07t
             INTO  re_line-tr_descr
             WHERE trkorr = im_trkorr
             AND   langu  = sy-langu.
    re_line-checked_by = sy-uname.
*       First get the descriptions (Status/Type/Project):
*       Retrieve texts for Status Description
    SELECT ddtext
           FROM  dd07t
           INTO  re_line-status_text UP TO 1 ROWS
           WHERE domname    = &apos;TRSTATUS&apos;
           AND   ddlanguage = sy-langu
           AND   domvalue_l = re_line-trstatus.      &quot;#EC CI_SEL_NESTED
    ENDSELECT.
*       Retrieve texts for Description of request/task type
    SELECT ddtext
           FROM  dd07t
           INTO  re_line-trfunction_txt UP TO 1 ROWS
           WHERE domname    = &apos;TRFUNCTION&apos;
           AND   ddlanguage = sy-langu
           AND   domvalue_l = re_line-trfunction.    &quot;#EC CI_SEL_NESTED
    ENDSELECT.
*       Retrieve the project number (and description):
    SELECT reference
           FROM  e070a UP TO 1 ROWS
           INTO  re_line-project
           WHERE trkorr    = re_line-trkorr
           AND   attribute = &apos;SAP_CTS_PROJECT&apos;.      &quot;#EC CI_SEL_NESTED
      SELECT descriptn
             FROM  ctsproject UP TO 1 ROWS
             INTO  re_line-project_descr              &quot;#EC CI_SGLSELECT
             WHERE trkorr  = re_line-project.        &quot;#EC CI_SEL_NESTED
      ENDSELECT.
    ENDSELECT.
*       Retrieve the description of the status
    SELECT ddtext
           FROM  dd07t UP TO 1 ROWS
           INTO  re_line-trstatus
           WHERE domname    = &apos;TRSTATUS&apos;
           AND   ddlanguage = sy-langu
           AND   domvalue_l = re_line-trstatus.      &quot;#EC CI_SEL_NESTED
    ENDSELECT.

  ENDMETHOD.                    &quot;get_tp_info

  METHOD get_added_objects.
    DATA: lp_tabix               TYPE sytabix,
          ls_main                TYPE ty_request_details,
          ls_main_list_vrsd      TYPE ty_request_details,
          lt_main_list_vrsd      TYPE tt_request_details,
          ls_added               TYPE ty_request_details.
    FIELD-SYMBOLS: &lt;l_main_list&gt; TYPE ty_request_details.
    REFRESH: ex_to_add.
    REFRESH: lt_main_list_vrsd.
    CLEAR:   ls_main.
*   Select all requests (not tasks) in the range. Objects belonging to
*   the request are included in the table.
    SELECT a~trkorr   a~trfunction a~trstatus
           a~as4user  a~as4date    a~as4time
           b~object   b~obj_name   b~objfunc
           INTO (ls_main-trkorr,
                 ls_main-trfunction,
                 ls_main-trstatus,
                 ls_main-as4user,
                 ls_main-as4date,
                 ls_main-as4time,
                 ls_main-object,
                 ls_main-obj_name,
                 ls_main-objfunc)
           FROM  e070 AS a JOIN e071 AS b
             ON  a~trkorr = b~trkorr
           WHERE a~trkorr IN im_to_add
           AND   a~strkorr = &apos;&apos;
           AND   ( b~pgmid = &apos;LIMU&apos; OR
                   b~pgmid = &apos;R3TR&apos; OR
                   b~pgmid = &apos;R3OB&apos; ).
      ls_main-flag = abap_true.
      APPEND: ls_main TO ex_to_add.
      CLEAR:  ls_main.
    ENDSELECT.
*   Read transport description:
    IF ex_to_add[] IS NOT INITIAL.
      LOOP AT ex_to_add ASSIGNING &lt;l_main_list&gt;.
        SELECT SINGLE  as4text
                 FROM  e07t
                 INTO &lt;l_main_list&gt;-tr_descr
                 WHERE trkorr = &lt;l_main_list&gt;-trkorr
                 AND   langu  = sy-langu.            &quot;#EC CI_SEL_NESTED
      ENDLOOP.
    ENDIF.
*   Also read from the version table VRSD. This table contains all
*   dependent objects. For example: If from E071 a function group
*   is retrieved, VRSD will contain all functions too.
    IF NOT ex_to_add[] IS INITIAL.
      SELECT korrnum objtype objname
             author  datum zeit
             FROM  vrsd
             INTO (ls_main_list_vrsd-trkorr,
                   ls_main_list_vrsd-object,
                   ls_main_list_vrsd-obj_name,
                   ls_main_list_vrsd-as4user,
                   ls_main_list_vrsd-as4date,
                   ls_main_list_vrsd-as4time)
             FOR ALL ENTRIES IN ex_to_add
             WHERE korrnum   =  ex_to_add-trkorr.
        READ TABLE ex_to_add
                   INTO ls_main
                   WITH KEY trkorr = ls_main_list_vrsd-trkorr.
        MOVE: ls_main_list_vrsd-object   TO ls_main-object,
              ls_main_list_vrsd-obj_name TO ls_main-obj_name,
              ls_main_list_vrsd-as4user  TO ls_main-as4user,
              ls_main_list_vrsd-as4date  TO ls_main-as4date,
              ls_main_list_vrsd-as4time  TO ls_main-as4time.
*       Only append if the object from VRSD does not already exist
*       in the main list:
        READ TABLE ex_to_add WITH KEY trkorr   = ls_main-trkorr
                                      object   = ls_main-object
                                      obj_name = ls_main-obj_name
                             TRANSPORTING NO FIELDS.
        IF sy-subrc &lt;&gt; 0.
          ls_main-flag = abap_true.
          APPEND ls_main TO lt_main_list_vrsd.
        ENDIF.
      ENDSELECT.
    ENDIF.
*   Now add all VRSD entries to the main list:
    APPEND LINES OF lt_main_list_vrsd TO ex_to_add.
    me-&gt;add_table_keys_to_list( IMPORTING table = ex_to_add ).
*   Only add the records that are not existing in the main list, so we
*   do not add the records that already exist in the main list.
    LOOP AT ex_to_add INTO ls_added.
      lp_tabix = sy-tabix.
      READ TABLE me-&gt;main_list WITH KEY trkorr     = ls_added-trkorr
                                        object     = ls_added-object
                                        obj_name   = ls_added-obj_name
                                        keyobject  = ls_added-keyobject
                                        keyobjname = ls_added-keyobjname
                                        tabkey     = ls_added-tabkey
                               TRANSPORTING NO FIELDS.
      IF sy-subrc = 0.
*       If the added transports are already in the list, but in prd, they
*       will be &apos;invisible&apos;, because the records with prd icon = co_okay
*       are filtered out. So, the prd icon needs to be changed to co_scrap
*       to become visible. We just make sure that all records for this
*       transport are made visible.
        LOOP AT me-&gt;main_list INTO  me-&gt;main_list_line   &quot;#EC CI_NESTED
                              WHERE trkorr     = ls_added-trkorr
                              AND   object     = ls_added-object
                              AND   obj_name   = ls_added-obj_name
                              AND   keyobject  = ls_added-keyobject
                              AND   keyobjname = ls_added-keyobjname
                              AND   tabkey     = ls_added-tabkey
                              AND   prd        = co_okay.
          me-&gt;main_list_line-prd = co_scrap.
          MODIFY me-&gt;main_list FROM me-&gt;main_list_line INDEX sy-tabix.
        ENDLOOP.
*       No need to add this transport again:
        DELETE ex_to_add INDEX lp_tabix.
      ENDIF.
    ENDLOOP.
    SORT: ex_to_add.
    DELETE ADJACENT DUPLICATES FROM ex_to_add.
  ENDMETHOD.                    &quot;get_added_objects

  METHOD get_additional_tp_info.
    DATA: lt_tr_cofilines      TYPE tr_cofilines.
    DATA: ls_tstrfcofil        TYPE tstrfcofil.
    DATA: ta_stms_wbo_requests TYPE TABLE OF stms_wbo_request.
    DATA: lp_retcode           TYPE strw_int4.
    DATA: st_stms_wbo_requests TYPE stms_wbo_request.
    DATA: st_systems           TYPE ctslg_system.
    DATA: lp_counter           TYPE i.
    DATA: lp_index             TYPE sytabix.
    DATA: lp_indexinc          TYPE sytabix.
    DATA: lp_trkorr            TYPE trkorr.
    DATA: ls_main_backup       TYPE ty_request_details.
    CLEAR: lp_counter,
           me-&gt;total.
*   The CHECKED_BY field is always going to be filled. If it is empty,
*   then this subroutine has not yet been executed for the record, and has
*   to be executed. Additional info ONLY needs to be gathered once.
*   This needs to be checked because transports can be added. If that
*   happened, additional info only needs to be retrieved for the added
*   transports.
    LOOP AT ch_table INTO me-&gt;main_list_line
                     WHERE flag = abap_true.
      me-&gt;total = me-&gt;total + 1.
    ENDLOOP.
    LOOP AT ch_table INTO me-&gt;main_list_line
                     WHERE flag = abap_true.
*     Show the progress indicator
      IF me-&gt;main_list_line-prd &lt;&gt; co_okay.
        lp_counter = lp_counter + 1.
        me-&gt;progress_indicator( EXPORTING im_counter = lp_counter
                                          im_object  = me-&gt;main_list_line-obj_name
                                          im_total   = me-&gt;total
                                          im_text    = &apos;Object data retrieved...&apos;(010)
                                          im_flag    = abap_true ).
      ENDIF.
      lp_index    = sy-tabix.
      lp_indexinc = lp_index + 1. &quot; To check next lines for same object
*     Only need to retrieve the additional info once, when a new transport
*     is encountered. This info is then copied to all the records (each
*     object) for the same request. So, only if the transport number is
*     different from the previous one.
      IF lp_trkorr &lt;&gt; me-&gt;main_list_line-trkorr.
        lp_trkorr = me-&gt;main_list_line-trkorr.
        me-&gt;main_list_line-checked_by = sy-uname.
*       First get the descriptions (Status/Type/Project):
*       Retrieve texts for Status Description
        SELECT ddtext
               FROM  dd07t
               INTO  me-&gt;main_list_line-status_text UP TO 1 ROWS
               WHERE domname    = &apos;TRSTATUS&apos;
               AND   ddlanguage = sy-langu
               AND   domvalue_l = me-&gt;main_list_line-trstatus. &quot;#EC CI_SEL_NESTED
        ENDSELECT.
*       Retrieve texts for Description of request/task type
        SELECT ddtext
               FROM  dd07t
               INTO  me-&gt;main_list_line-trfunction_txt UP TO 1 ROWS
               WHERE domname    = &apos;TRFUNCTION&apos;
               AND   ddlanguage = sy-langu
               AND   domvalue_l = me-&gt;main_list_line-trfunction. &quot;#EC CI_SEL_NESTED
        ENDSELECT.
*       Retrieve the project number (and description):
        SELECT reference
               FROM  e070a UP TO 1 ROWS
               INTO  me-&gt;main_list_line-project
               WHERE trkorr    = me-&gt;main_list_line-trkorr
               AND   attribute = &apos;SAP_CTS_PROJECT&apos;.  &quot;#EC CI_SEL_NESTED
          SELECT descriptn
                 FROM  ctsproject UP TO 1 ROWS
                 INTO  me-&gt;main_list_line-project_descr &quot;#EC CI_SGLSELECT
                 WHERE trkorr  = me-&gt;main_list_line-project. &quot;#EC CI_SEL_NESTED
          ENDSELECT.
        ENDSELECT.
*       Retrieve the description of the status
        SELECT ddtext
               FROM  dd07t UP TO 1 ROWS
               INTO  me-&gt;main_list_line-trstatus
               WHERE domname    = &apos;TRSTATUS&apos;
               AND   ddlanguage = sy-langu
               AND   domvalue_l = me-&gt;main_list_line-trstatus. &quot;#EC CI_SEL_NESTED
        ENDSELECT.
*       Check if transport has been released.
*       D - Modifiable
*       L - Modifiable, protected
*       A - Modifiable, protected
*       O - Release started
*       R - Released
*       N - Released (with import protection for repaired objects)
        REFRESH: ta_stms_wbo_requests.
        CLEAR:   ta_stms_wbo_requests.
        CALL FUNCTION &apos;TMS_MGR_READ_TRANSPORT_REQUEST&apos;
          EXPORTING
            iv_request                 = me-&gt;main_list_line-trkorr
            iv_target_system           = me-&gt;dev_system
            iv_header_only             = &apos;X&apos;
            iv_monitor                 = &apos; &apos;
          IMPORTING
            et_request_infos           = ta_stms_wbo_requests
          EXCEPTIONS
            read_config_failed         = 1
            table_of_requests_is_empty = 2
            system_not_available       = 3
            OTHERS                     = 4.
        IF sy-subrc &lt;&gt; 0.
          MESSAGE ID sy-msgid TYPE sy-msgty NUMBER sy-msgno
                  WITH sy-msgv1 sy-msgv2 sy-msgv3 sy-msgv4.
        ENDIF.
        READ TABLE ta_stms_wbo_requests INDEX 1
                                        INTO st_stms_wbo_requests.
*       Check if there is documentation available
        CLEAR: me-&gt;main_list_line-info.
        IF NOT st_stms_wbo_requests-docu[] IS INITIAL.
          me-&gt;check_documentation( EXPORTING im_trkorr = me-&gt;main_list_line-trkorr
                                   CHANGING  ch_table  = ch_table ).
        ENDIF.
* Check the returncode of this transport to QAS
        CALL FUNCTION &apos;STRF_READ_COFILE&apos;
          EXPORTING
            iv_trkorr     = me-&gt;main_list_line-trkorr
          TABLES
            tt_cofi_lines = lt_tr_cofilines
          EXCEPTIONS
            wrong_call    = 0
            no_info_found = 0
            OTHERS        = 0.
        READ TABLE lt_tr_cofilines INTO ls_tstrfcofil
                                   WITH KEY tarsystem = qas_system
                                            function  = &apos;G&apos;.
        me-&gt;main_list_line-retcode = ls_tstrfcofil-retcode.
        IF st_stms_wbo_requests-e070-trstatus NA &apos;NR&apos;.
          me-&gt;main_list_line-warning_lvl  = co_alert.
          me-&gt;main_list_line-warning_rank = co_alert1_rank.
          me-&gt;main_list_line-warning_txt  = lp_alert1_text.
        ELSEIF st_stms_wbo_requests-e070-trstatus = &apos;O&apos;.
          me-&gt;main_list_line-warning_lvl  = co_alert.
          me-&gt;main_list_line-warning_rank = co_alert2_rank.
          me-&gt;main_list_line-warning_txt  = lp_alert2_text.
        ELSE.
*         Retrieve the environments where the transport can be found.
*         Read the info of the request (transport log) to determine the
*         highest environment the transport has been moved to.
          CALL FUNCTION &apos;TR_READ_GLOBAL_INFO_OF_REQUEST&apos;
            EXPORTING
              iv_trkorr = me-&gt;main_list_line-trkorr
            IMPORTING
              es_cofile = st_request-cofile.

          IF st_request-cofile-systems IS INITIAL.
*           Transport log does not exist: not released or log deleted
            me-&gt;main_list_line-warning_lvl  = co_alert.
            me-&gt;main_list_line-warning_rank = co_alert0_rank.
            me-&gt;main_list_line-warning_txt  = lp_alert0_text.
*           First check if the object can also be found further down in
*           the list. If it is, then THAT transport will be checked.
*           Because, even if this transport&apos;s log can&apos;t be read, if the
*           same object is found later in the list, that one will be
*           checked too. We don&apos;t have to worry about the fact that the
*           log does not exist for this transport.
            LOOP AT ch_table INTO  me-&gt;line_found_in_list FROM lp_indexinc
                             WHERE object     =  me-&gt;main_list_line-object
                             AND   obj_name   =  me-&gt;main_list_line-obj_name
                             AND   keyobject  =  me-&gt;main_list_line-keyobject
                             AND   keyobjname =  me-&gt;main_list_line-keyobjname
                             AND   tabkey     =  me-&gt;main_list_line-tabkey
                             AND   prd        &lt;&gt; co_okay. &quot;#EC CI_NESTED
              EXIT.
            ENDLOOP.
            IF sy-subrc = 0.
              me-&gt;main_list_line-warning_lvl  = co_hint.
              me-&gt;main_list_line-warning_rank = co_hint3_rank.
              me-&gt;main_list_line-warning_txt  = lp_hint3_text.
            ENDIF.
          ELSE.
*           Initialize environment fields. The environments will be
*           checked
*           and updated with the correct environment later
            me-&gt;main_list_line-dev = co_inact.
            me-&gt;main_list_line-qas = co_inact.
            me-&gt;main_list_line-prd = co_inact.
*           Now check in which environments the transport can be found
            LOOP AT st_request-cofile-systems INTO st_systems. &quot;#EC CI_NESTED
*             For each environment, set the status icon:
              CASE st_systems-systemid.
                WHEN me-&gt;dev_system.
                  me-&gt;main_list_line-dev = co_okay. &quot;Green - Exists
                WHEN me-&gt;qas_system.
                  me-&gt;main_list_line-qas = co_okay. &quot;Green - Exists
*                 Get the latest date/time stamp
                  DESCRIBE TABLE st_systems-steps LINES tp_lines.
                  READ TABLE st_systems-steps INTO st_steps
                                              INDEX tp_lines.
                  CHECK st_steps-stepid &lt;&gt; &apos;&lt;&apos;.

                  DESCRIBE TABLE st_steps-actions LINES tp_lines.
                  READ TABLE st_steps-actions INTO st_actions
                                              INDEX tp_lines.
                  MOVE st_actions-time TO me-&gt;main_list_line-as4time.
                  MOVE st_actions-date TO me-&gt;main_list_line-as4date.
                WHEN me-&gt;prd_system.
                  DESCRIBE TABLE st_systems-steps LINES tp_lines.
                  READ TABLE st_systems-steps INTO st_steps
                                              INDEX tp_lines.
                  CHECK st_steps-stepid &lt;&gt; &apos;&lt;&apos;.
                  me-&gt;main_list_line-prd = co_okay. &quot;Green - Exists
                WHEN OTHERS.
              ENDCASE.
            ENDLOOP.
          ENDIF.
        ENDIF.
*       Update the main table from the workarea.
        MODIFY ch_table FROM me-&gt;main_list_line
                        INDEX lp_index
                        TRANSPORTING checked_by
                                     status_text
                                     trfunction_txt
                                     trstatus
                                     tr_descr
                                     retcode
                                     info
                                     warning_lvl
                                     warning_txt
                                     dev
                                     qas
                                     prd
                                     as4time
                                     as4date
                                     project
                                     project_descr.
*       Keep the workarea for the other objects within the same transport.
*       No need to select the same data for each objetc because it is the
*       same for all the transport objects (data retrieved on transport
*       level).
        ls_main_backup = me-&gt;main_list_line.
        CONTINUE.
      ELSE.
*       Update the main table from the workarea.
        MODIFY ch_table FROM ls_main_backup
                        INDEX lp_index
                        TRANSPORTING checked_by
                                     status_text
                                     trfunction_txt
                                     trstatus
                                     tr_descr
                                     retcode
                                     info
                                     warning_lvl
                                     warning_txt
                                     dev
                                     qas
                                     prd
                                     as4time
                                     as4date
                                     project
                                     project_descr.
        CONTINUE.
      ENDIF.
    ENDLOOP.
  ENDMETHOD.                    &quot;get_additional_tp_info

  METHOD add_to_list.
*   Add the records:
    APPEND LINES OF im_to_add TO ex_main.
*   Re-sort the list:
    me-&gt;sort_main_list( ).
  ENDMETHOD.                    &quot;add_to_list

  METHOD build_conflict_popup.
    DATA: lr_events          TYPE REF TO cl_salv_events_table.
    DATA: ls_conflict        TYPE ty_request_details.
    DATA: lp_xend            TYPE i.
    DATA: lp_yend            TYPE i.
    DATA: lp_xstart          TYPE i VALUE 50.
    DATA: lp_ystart          TYPE i VALUE 7.
*   Prevent the conflicts popup to be build multiple times
    CHECK rf_conflicts IS INITIAL.
*   Because we are going to only display the popup, the main list
*   does not need to be checked. So we set a flag. This makes sure
*   that all conflicting transports are added to the conflict list
*   and the main list is NOT checked again.
    me-&gt;set_building_conflict_popup(  ).
    me-&gt;flag_for_process( EXPORTING rows = rows
                                    cell = cell ).
    me-&gt;check_for_conflicts( CHANGING ch_main_list = me-&gt;main_list ).
*   If the button to add conflicts is clicked (not a double-click), then
*   remove from the popup all low-level warning messages
    IF sy-ucomm = &apos;&amp;ADD&apos;.
      LOOP AT me-&gt;conflicts INTO ls_conflict
                            WHERE warning_rank &lt; co_info_rank.
        DELETE me-&gt;conflicts INDEX sy-tabix.
      ENDLOOP.
    ENDIF.
*   Check if there are entries in the conflicts. If not, display a
*   message
    IF me-&gt;conflicts IS INITIAL.
      MESSAGE i000(db)
         WITH &apos;No transports need to be added&apos;(019)
              &apos;To see the conflicts, doubleclick the warning&apos;(020).
      EXIT.
    ENDIF.
    TRY.
        CALL METHOD cl_salv_table=&gt;factory
          IMPORTING
            r_salv_table = rf_conflicts
          CHANGING
            t_table      = me-&gt;conflicts.
*       Set ALV properties
        me-&gt;set_properties_conflicts( EXPORTING im_table = me-&gt;conflicts
                                      IMPORTING ex_xend  = lp_xend ).
*       Set Tooltips
        me-&gt;alv_set_tooltips( EXPORTING im_table = rf_conflicts ).
*       Register handler for actions
        lr_events = rf_conflicts-&gt;get_event( ).
        SET HANDLER lcl_eventhandler_ztct=&gt;on_function_click FOR lr_events.
*       Save reference to access object from handler
        lcl_eventhandler_ztct=&gt;rf_conflicts = rf_conflicts.
*       Use gui-status ST850 from program SAPLKKB
        rf_conflicts-&gt;set_screen_status( pfstatus      = &apos;ST850&apos;
                                         report        = &apos;SAPLKKBL&apos; ).
*       Determine the size of the popup window:
        lp_xend = lp_xend + lp_xstart + 5.
        DESCRIBE TABLE me-&gt;conflicts LINES lp_yend.
        IF lp_yend &lt; 5.
          lp_yend = 5.
        ENDIF.
        lp_yend = lp_yend + lp_ystart + 1.
*       Display as popup
        rf_conflicts-&gt;set_screen_popup( start_column = lp_xstart
                                        end_column   = lp_xend
                                        start_line   = lp_ystart
                                        end_line     = lp_yend ).
        rf_conflicts-&gt;display( ).
      CATCH cx_salv_msg INTO rf_root.
        me-&gt;handle_error( EXPORTING rf_oref = rf_root ).
    ENDTRY.
    FREE rf_conflicts.
    me-&gt;set_building_conflict_popup( abap_false ).
  ENDMETHOD.                    &quot;build_conflict_popup

  METHOD delete_tp_from_list.
    DATA: ra_trkorr TYPE RANGE OF trkorr.
    DATA: ls_trkorr LIKE LINE  OF ra_trkorr.
    DATA: ls_row TYPE int4.
*   If row(s) are selected, use the table
* Add transports to range
    ls_trkorr-sign   = &apos;I&apos;.
    ls_trkorr-option = &apos;EQ&apos;.
    LOOP AT rows INTO ls_row.
      READ TABLE me-&gt;main_list INTO  me-&gt;main_list_line
                               INDEX ls_row.
      ls_trkorr-low = me-&gt;main_list_line-trkorr.
      APPEND ls_trkorr TO ra_trkorr.
    ENDLOOP.
    SORT ra_trkorr.
    DELETE ADJACENT DUPLICATES FROM ra_trkorr.
    DELETE me-&gt;main_list WHERE trkorr IN ra_trkorr.
  ENDMETHOD.                    &quot;delete_tp_from_list

  METHOD flag_same_objects.
    DATA: lt_main_list_copy TYPE tt_request_details.
*   Only relevant if there is a check to be done
    CHECK me-&gt;check_flag = abap_true.
*   Set check flag for all transports that are going to be refreshed
*   because all of these need to be checked again.
    lt_main_list_copy[] = ex_main_list[].
    LOOP AT ex_main_list INTO me-&gt;main_list_line
                         WHERE flag = abap_true.
*     Also flag all the objects already existing in the main table
*     that are in the added list: They need to be checked again.
      LOOP AT lt_main_list_copy[] INTO  me-&gt;main_list_line
                                  WHERE object     = me-&gt;main_list_line-object
                                  AND   obj_name   = me-&gt;main_list_line-obj_name
                                  AND   keyobject  = me-&gt;main_list_line-keyobject
                                  AND   keyobjname = me-&gt;main_list_line-keyobjname
                                  AND   tabkey     = me-&gt;main_list_line-tabkey
                                  AND   flag = abap_false. &quot;#EC CI_NESTED
        me-&gt;main_list_line-flag = abap_true.
        MODIFY lt_main_list_copy FROM  me-&gt;main_list_line
                                 INDEX sy-tabix
                                 TRANSPORTING flag.
      ENDLOOP.
    ENDLOOP.
    ex_main_list[] = lt_main_list_copy[].
    FREE lt_main_list_copy.
  ENDMETHOD.                    &quot;flag_same_objects

  METHOD mark_all_tp_records.
    DATA: ra_trkorr TYPE RANGE OF trkorr.
    DATA: ls_trkorr LIKE LINE  OF ra_trkorr.
    DATA: ls_row    TYPE int4.
* Add transports to range
    ls_trkorr-sign   = &apos;I&apos;.
    ls_trkorr-option = &apos;EQ&apos;.
* If row(s) are selected, use the table
    LOOP AT im_rows INTO ls_row.
      READ TABLE me-&gt;main_list INTO  me-&gt;main_list_line
                               INDEX ls_row.
      ls_trkorr-low = me-&gt;main_list_line-trkorr.
      APPEND ls_trkorr TO ra_trkorr.
    ENDLOOP.
* If no rows were selected, take the current cell instead
    IF sy-subrc &lt;&gt; 0.
      READ TABLE me-&gt;main_list INTO  me-&gt;main_list_line
                               INDEX im_cell-row.
      ls_trkorr-low = me-&gt;main_list_line-trkorr.
      APPEND ls_trkorr TO ra_trkorr.
    ENDIF.
    CHECK ra_trkorr IS NOT INITIAL.
    SORT ra_trkorr.
    DELETE ADJACENT DUPLICATES FROM ra_trkorr.
* Mark all records for all marked transports
    LOOP AT me-&gt;main_list INTO me-&gt;main_list_line
                          WHERE trkorr IN ra_trkorr.
      APPEND sy-tabix TO im_rows.
    ENDLOOP.
    SORT im_rows.
    DELETE ADJACENT DUPLICATES FROM im_rows.
  ENDMETHOD.                    &quot;mark_all_tp_records

  METHOD clear_flags.
    LOOP AT me-&gt;main_list INTO  me-&gt;main_list_line
                          WHERE flag = abap_true.
      CLEAR: me-&gt;main_list_line-flag.
      MODIFY me-&gt;main_list FROM me-&gt;main_list_line
                           TRANSPORTING flag.
    ENDLOOP.
  ENDMETHOD.                    &quot;clear_flags

  METHOD get_filename.
    DATA: lp_window_title TYPE string,
          lp_rc           TYPE i,
          lp_desktop      TYPE string,
          lt_filetable    TYPE filetable.
* Finding desktop
    CALL METHOD cl_gui_frontend_services=&gt;get_desktop_directory
      CHANGING
        desktop_directory    = lp_desktop
      EXCEPTIONS
        cntl_error           = 1
        error_no_gui         = 2
        not_supported_by_gui = 3
        OTHERS               = 4.
    IF sy-subrc &lt;&gt; 0.
      MESSAGE e001(00) WITH
          &apos;Desktop not found&apos;(012).
    ENDIF.
* Update View
    CALL METHOD cl_gui_cfw=&gt;update_view
      EXCEPTIONS
        cntl_system_error = 1
        cntl_error        = 2
        OTHERS            = 3.
    lp_window_title = &apos;Select a transportlist&apos;(013).
    CALL METHOD cl_gui_frontend_services=&gt;file_open_dialog
      EXPORTING
        window_title            = lp_window_title
        default_extension       = &apos;TXT&apos;
        default_filename        = &apos;ZTCT_FILE&apos;
        file_filter             = &apos;.TXT&apos;
        initial_directory       = lp_desktop
      CHANGING
        file_table              = lt_filetable
        rc                      = lp_rc
      EXCEPTIONS
        file_open_dialog_failed = 1
        cntl_error              = 2
        error_no_gui            = 3
        not_supported_by_gui    = 4
        OTHERS                  = 5.
    IF sy-subrc &lt;&gt; 0.
      MESSAGE ID sy-msgid TYPE sy-msgty NUMBER sy-msgno
              WITH sy-msgv1 sy-msgv2 sy-msgv3 sy-msgv4.
    ENDIF.
    READ TABLE lt_filetable INDEX 1 INTO ex_file.
  ENDMETHOD.                    &quot;get_filename

  METHOD main_to_tab_delimited.
    DATA: lp_string             TYPE string.
    DATA: lp_type               TYPE char01.
    DATA: lp_com                TYPE i.
    FIELD-SYMBOLS: &lt;l_fs&gt;       TYPE any.

*   Determine the number of fields in the structure
    DATA: lr_tabledescr         TYPE REF TO cl_abap_tabledescr,
          lr_typedescr          TYPE REF TO cl_abap_typedescr,
          lr_structdescr        TYPE REF TO cl_abap_structdescr,
          lt_abap_component_tab TYPE abap_component_tab,
          ls_abap_component     TYPE abap_componentdescr.

    TRY.
        lr_typedescr = cl_abap_tabledescr=&gt;describe_by_data( p_data = me-&gt;main_list ).
        lr_tabledescr ?= lr_typedescr.
        lr_structdescr ?= lr_tabledescr-&gt;get_table_line_type( ).
      CATCH cx_sy_move_cast_error INTO rf_root.
        me-&gt;handle_error( EXPORTING rf_oref = rf_root ).
      CATCH cx_root INTO rf_root.
        me-&gt;handle_error( EXPORTING rf_oref = rf_root ).
    ENDTRY.

* Build header line
    REFRESH: ex_tab_delimited.
    lt_abap_component_tab = lr_structdescr-&gt;get_components( ).
    LOOP AT lt_abap_component_tab INTO ls_abap_component.
      CONCATENATE lp_string tp_tab ls_abap_component-name INTO lp_string.
    ENDLOOP.
    SHIFT lp_string LEFT DELETING LEADING tp_tab.
    APPEND lp_string TO ex_tab_delimited.
*   Now modify the lines of the main list to a tab delimited list
    LOOP AT im_main_list INTO me-&gt;main_list_line.
      CLEAR: lp_string.
      DO.
        ASSIGN COMPONENT sy-index OF STRUCTURE me-&gt;main_list_line TO &lt;l_fs&gt;.
        IF sy-subrc &lt;&gt; 0.
          EXIT.
        ELSE.
          IF sy-index = 1.
            lp_string = &lt;l_fs&gt;.
          ELSE.
            DESCRIBE FIELD &lt;l_fs&gt; TYPE lp_type COMPONENTS lp_com.
            IF lp_type NA co_non_charlike.
              CONCATENATE lp_string tp_tab &lt;l_fs&gt; INTO lp_string.
            ENDIF.
          ENDIF.
        ENDIF.
      ENDDO.
      APPEND lp_string TO ex_tab_delimited.
    ENDLOOP.
  ENDMETHOD.                    &quot;main_to_tab_delimited

  METHOD display_transport.
    CALL FUNCTION &apos;TMS_UI_SHOW_TRANSPORT_REQUEST&apos;
      EXPORTING
        iv_request                    = im_trkorr
      EXCEPTIONS
        show_transport_request_failed = 1
        OTHERS                        = 2.
    IF sy-subrc &lt;&gt; 0.
      MESSAGE ID sy-msgid TYPE sy-msgty NUMBER sy-msgno
              WITH sy-msgv1 sy-msgv2 sy-msgv3 sy-msgv4.
    ENDIF.
    LEAVE SCREEN.
  ENDMETHOD.                    &quot;display_transport

  METHOD display_user.
    DATA: lp_return   TYPE bapiret2.
    CALL FUNCTION &apos;BAPI_USER_DISPLAY&apos;
      EXPORTING
        username = im_user
      IMPORTING
        return   = lp_return.
    IF lp_return-type CA &apos;EA&apos;.
      CALL FUNCTION &apos;SUSR_SHOW_USER_DETAILS&apos;
        EXPORTING
          bname = im_user.
    ENDIF.
  ENDMETHOD.                    &quot;display_user

  METHOD display_docu.
    DATA: lp_dokl_object TYPE doku_obj.
    MOVE: im_trkorr  TO lp_dokl_object.
    me-&gt;docu_call( EXPORTING im_object = lp_dokl_object ).
    me-&gt;check_documentation( EXPORTING im_trkorr = im_trkorr
                             CHANGING  ch_table  = me-&gt;main_list ).
  ENDMETHOD.                    &quot;display_docu

  METHOD refresh_alv.
*   Declaration for Top of List settings
    DATA: lr_form_element TYPE REF TO cl_salv_form_element.

    me-&gt;top_of_page( IMPORTING ex_form_element = lr_form_element ).
    rf_table-&gt;set_top_of_list( lr_form_element ).
    me-&gt;set_color( ).
    me-&gt;alv_set_tooltips( EXPORTING im_table = rf_table ).
    rf_table-&gt;refresh( ).
  ENDMETHOD.                    &quot;refresh_alv

  METHOD tab_delimited_to_main.
    TYPES: BEGIN OF lty_upl_line,
             field          TYPE fieldname,
             value          TYPE string,
           END OF lty_upl_line.
    DATA: lt_upl_line       TYPE TABLE OF lty_upl_line.
    DATA: ls_upl_line       TYPE lty_upl_line.
    DATA: lt_main_upl       TYPE tt_request_details.
    DATA: ls_main_line_upl  TYPE ty_request_details.
    DATA: lp_record         TYPE string.
    DATA: ls_main           TYPE ty_request_details.
    DATA: lp_type           TYPE char01.
    DATA: lp_com            TYPE i.
    FIELD-SYMBOLS: &lt;l_fs&gt;   TYPE any.
*   Determine the number of fields in the structure
    DATA: l_o_tabledescr         TYPE REF TO cl_abap_tabledescr.
    DATA: l_o_typedescr          TYPE REF TO cl_abap_typedescr.
    DATA: l_o_structdescr        TYPE REF TO cl_abap_structdescr.
    DATA: l_s_abap_compdescr_tab TYPE abap_compdescr.
    DATA: ls_component           TYPE abap_compdescr.
    TRY.
        l_o_typedescr = cl_abap_tabledescr=&gt;describe_by_data( p_data = me-&gt;main_list ).
        l_o_tabledescr ?= l_o_typedescr.
        l_o_structdescr ?= l_o_tabledescr-&gt;get_table_line_type( ).
      CATCH cx_sy_move_cast_error INTO rf_root.
        me-&gt;handle_error( EXPORTING rf_oref = rf_root ).
      CATCH cx_root INTO rf_root.
        me-&gt;handle_error( EXPORTING rf_oref = rf_root ).
    ENDTRY.
*   First line contains the name of the fields
*   Now modify the lines of the main list to a tab delimited list
    READ TABLE im_tab_delimited INDEX 1
                                INTO  lp_record.
*   Build list of fields, in order of uploaded file
    DO.
      SPLIT lp_record AT tp_tab INTO ls_upl_line-field lp_record.
      IF lp_record IS INITIAL.
        EXIT.
      ENDIF.
      APPEND ls_upl_line TO lt_upl_line.
    ENDDO.
    LOOP AT im_tab_delimited FROM 2                &quot;Skip the header line
                             INTO lp_record.
      CLEAR: ls_upl_line.
*     First put all values for this record in the value table
*     Build list of fields, in order of uploaded file
      DO.
*       Get the corresponding line from the table containing
*       the fields and values (to be updated with the value)
        READ TABLE lt_upl_line INDEX sy-index
                               INTO  ls_upl_line.
        SPLIT lp_record AT tp_tab INTO ls_upl_line-value lp_record.
        IF lp_record IS INITIAL.
          EXIT.
        ELSE.
          MODIFY lt_upl_line FROM  ls_upl_line
                             INDEX sy-tabix
                             TRANSPORTING value.
        ENDIF.
      ENDDO.
*     Map the fields from the uploaded line to the correct component
*     of the main list
      DO.
*       Get corresponding fieldname for file column
        READ TABLE lt_upl_line INTO  ls_upl_line
                               INDEX sy-index.
        IF sy-subrc &lt;&gt; 0.
          EXIT.
        ENDIF.
*       Get information about where the column is in the structure
*       Get the lenght and position from the structure definition:
        READ TABLE l_o_structdescr-&gt;components
                   INTO ls_component
                   WITH KEY name = ls_upl_line-field.
        IF sy-subrc = 0.
          TRY.
              ASSIGN COMPONENT ls_component-name OF STRUCTURE ls_main_line_upl TO &lt;l_fs&gt;.
            CATCH cx_root INTO rf_root.
          ENDTRY.
          IF sy-subrc &lt;&gt; 0.
            EXIT.
          ELSE.
            DESCRIBE FIELD &lt;l_fs&gt; TYPE lp_type COMPONENTS lp_com.
            IF lp_type NA co_non_charlike.
              TRY .
                  &lt;l_fs&gt; = ls_upl_line-value.
                CATCH cx_root INTO rf_root.
              ENDTRY.
            ENDIF.
          ENDIF.
        ENDIF.
      ENDDO.
      APPEND ls_main_line_upl TO lt_main_upl.
      CLEAR: ls_main_line_upl.
    ENDLOOP.

*   Now move the lines of the uploaded list to the main list and
*   if another file is added to the main list (&amp;ADD_FILE), then
*   Automatically RE-Check the objects in the existing main list
    DESCRIBE TABLE lt_main_upl LINES me-&gt;total.

    LOOP AT lt_main_upl INTO ls_main.
      me-&gt;progress_indicator( EXPORTING im_counter = sy-tabix
                                        im_object  = &apos;&apos;
                                        im_total   = me-&gt;total
                                        im_text    = &apos;records read and added.&apos;(022)
                                        im_flag    = abap_true ).
*     Check if the record is already in the main list:
      READ TABLE main_list WITH KEY trkorr     = ls_main-trkorr
                                    object     = ls_main-object
                                    obj_name   = ls_main-obj_name
                                    keyobject  = ls_main-keyobject
                                    keyobjname = ls_main-keyobjname
                                    tabkey     = ls_main-tabkey
                           TRANSPORTING NO FIELDS.
      IF sy-subrc &lt;&gt; 0.
*       If a file is uploaded to be merged (&amp;ADD_FILE), then we need to
*       check all the records that are going to be added to the main list,
*       as well as all the records in the main list that contain an object
*       also in the loaded list:
        IF sy-ucomm  = &apos;&amp;ADD_FILE&apos;.
          ls_main-flag = abap_true.
          LOOP AT main_list INTO  me-&gt;main_list_line
                            WHERE object     = ls_main-object
                            AND   obj_name   = ls_main-obj_name
                            AND   keyobject  = ls_main-keyobject
                            AND   keyobjname = ls_main-keyobjname
                            AND   tabkey     = ls_main-tabkey. &quot;#EC CI_NESTED
            me-&gt;main_list_line-flag = abap_true.
            MODIFY main_list FROM me-&gt;main_list_line.
          ENDLOOP.
        ENDIF.
        APPEND ls_main TO main_list.
      ELSE.
        CHECK 1 = 1.
      ENDIF.
    ENDLOOP.
    me-&gt;sort_main_list( ).
  ENDMETHOD.                    &quot;tab_delimited_to_main

  METHOD gui_upload.
    DATA: lt_tab_delimited TYPE table_of_strings.
    DATA: lt_temp_table     TYPE table_of_strings.
    CALL METHOD cl_gui_frontend_services=&gt;gui_upload
      EXPORTING
        filename                = im_filename
        filetype                = &apos;ASC&apos;
      CHANGING
        data_tab                = lt_temp_table
      EXCEPTIONS
        file_open_error         = 1
        file_read_error         = 2
        no_batch                = 3
        gui_refuse_filetransfer = 4
        invalid_type            = 5
        no_authority            = 6
        unknown_error           = 7
        bad_data_format         = 8
        header_not_allowed      = 9
        separator_not_allowed   = 10
        header_too_long         = 11
        unknown_dp_error        = 12
        access_denied           = 13
        dp_out_of_memory        = 14
        disk_full               = 15
        dp_timeout              = 16
        not_supported_by_gui    = 17
        error_no_gui            = 18
        OTHERS                  = 19.
    IF sy-subrc &lt;&gt; 0.
      ex_cancelled = abap_true.
      CASE sy-subrc.
        WHEN 1.
          IF im_filename IS INITIAL.
            MESSAGE i000(db) WITH &apos;Cancelled by user&apos;(031).
          ELSE.
            MESSAGE e000(db) WITH &apos;Error occurred&apos;(029).
          ENDIF.
        WHEN OTHERS.
          MESSAGE e000(db) WITH &apos;Error occurred&apos;(029).
      ENDCASE.
    ELSE.
      lt_tab_delimited[] = lt_temp_table[].
*     Now convert the tab delimited file to the main list field order:
      me-&gt;tab_delimited_to_main( EXPORTING im_tab_delimited = lt_tab_delimited
                                 IMPORTING ex_main_list     = me-&gt;main_list ).
      DESCRIBE TABLE me-&gt;main_list LINES me-&gt;total.
      LOOP AT me-&gt;main_list INTO me-&gt;main_list_line.
        me-&gt;progress_indicator( EXPORTING im_counter = sy-tabix
                                          im_object  = me-&gt;main_list_line-obj_name
                                          im_total   = me-&gt;total
                                          im_text    = &apos;records checked (documentation)&apos;(023)
                                          im_flag    = abap_true ).
        me-&gt;check_documentation( EXPORTING im_trkorr = me-&gt;main_list_line-trkorr
                                 CHANGING  ch_table  = me-&gt;main_list ).
      ENDLOOP.
    ENDIF.
*   A simple check on the internal table. If a warning is found, then
*   we assume that the check parameter needs to be switched ON.
    LOOP AT me-&gt;main_list INTO me-&gt;main_list_line
                          WHERE NOT warning_lvl IS INITIAL.
      me-&gt;set_check_flag( ).
      EXIT.
    ENDLOOP.
*   Check if the Checked icon needs to be cleared:
    IF me-&gt;clear_checked = abap_true.
      LOOP AT me-&gt;main_list INTO  me-&gt;main_list_line
                            WHERE checked = co_checked.
        CLEAR: me-&gt;main_list_line-checked.
        MODIFY me-&gt;main_list FROM  me-&gt;main_list_line
                             INDEX sy-tabix.
      ENDLOOP.
    ENDIF.
  ENDMETHOD.                    &quot;gui_upload

  METHOD check_if_in_list.
    DATA: lp_tabix   TYPE i.
    CLEAR: ex_line.
* This subroutine checks if the conflicting transport/object is found
* further down in the list (in a later transport):
    lp_tabix = im_tabix + 1.
    LOOP AT me-&gt;main_list INTO  ex_line FROM lp_tabix
                          WHERE trkorr     =  im_line-trkorr
                          AND   object     =  im_line-object
                          AND   obj_name   =  im_line-obj_name
                          AND   keyobject  =  im_line-keyobject
                          AND   keyobjname =  im_line-keyobjname
                          AND   tabkey     =  im_line-tabkey
                          AND   prd        &lt;&gt; co_okay.
      EXIT.
    ENDLOOP.
  ENDMETHOD.                    &quot;check_if_in_list

  METHOD check_if_same_object.
*   Although there is already a warning (older transport not moved or
*   newer transport was moved), it must be the exact same object. If it&apos;s
*   an entry in a table, it should not be checked if the table was
*   changed, but if it&apos;s the same entry that was changed... This perform
*   check the key entries.
    DATA:  ls_e071k TYPE e071k.
    CLEAR: ex_tabkey,
           ex_return.
*   The check on object (if the same) can either be done on key level (for
*   tables) or just on object level... Depends on the OBJFUNC field.

    CASE im_line-objfunc.
      WHEN &apos;K&apos;. &quot;Key fields available
        SELECT * FROM e071k
                 INTO ls_e071k UP TO 1 ROWS
                 WHERE trkorr = im_newer_older-trkorr
                 AND   tabkey = im_line-tabkey.
        ENDSELECT.
*       Now check if in both transports, an object exists with the
*       same key:
        IF ls_e071k IS INITIAL.
*         No key found. Treat as if it&apos;s the same object...
          IF im_newer_older-object   = im_line-object AND
             im_newer_older-obj_name = im_line-obj_name.
            ex_return = abap_true.
          ENDIF.
        ELSE.
*         There are records to be compared, only if the record is for the
*         same key, accept the warning as true (return = &apos;X&apos;).
          ex_return = abap_true.
          CONCATENATE ls_e071k-tabkey &apos; (&apos;
                      ls_e071k-objname &apos;)&apos;
                      INTO ex_tabkey.
        ENDIF.
      WHEN OTHERS.
        IF im_newer_older-object   = im_line-object AND
           im_newer_older-obj_name = im_line-obj_name.
          ex_return = abap_true.
        ENDIF.
    ENDCASE.
  ENDMETHOD.                    &quot;check_if_same_object

  METHOD check_documentation.
    DATA: ls_doktl  TYPE doktl.      &quot;Documentation - text lines
    MOVE: im_trkorr TO tp_dokl_object.
    SELECT * FROM  doktl
             UP TO 1 ROWS
             INTO  ls_doktl
             WHERE id        =  &apos;TA&apos;
             AND   object    =  tp_dokl_object
             AND   typ       =  &apos;T&apos;
             AND   dokformat &lt;&gt; &apos;L&apos;
             AND   doktext   &lt;&gt; &apos;&apos;.
    ENDSELECT.
    IF ls_doktl IS NOT INITIAL.
*     There is documentation: Display Doc Icon
      me-&gt;main_list_line-info = co_docu.
    ELSE.
*     There is no documentation: Remove Doc Icon
      CLEAR me-&gt;main_list_line-info.
    ENDIF.
    MODIFY ch_table FROM me-&gt;main_list_line
                    TRANSPORTING info
                    WHERE trkorr = im_trkorr.
  ENDMETHOD.                    &quot;check_documentation

  METHOD alv_init.
    CLEAR : rf_table.
    TRY.
        CALL METHOD cl_salv_table=&gt;factory
          EXPORTING
            list_display = if_salv_c_bool_sap=&gt;false
          IMPORTING
            r_salv_table = rf_table
          CHANGING
            t_table      = me-&gt;main_list.
      CATCH cx_salv_msg INTO rf_root.
        me-&gt;handle_error( EXPORTING rf_oref = rf_root ).
    ENDTRY.
    IF rf_table IS INITIAL.
      MESSAGE &apos;Error Creating ALV Grid&apos;(t03) TYPE &apos;A&apos; DISPLAY LIKE &apos;E&apos;.
    ENDIF.
  ENDMETHOD.                    &quot;alv_init

  METHOD alv_xls_init.
    TRY.
        CALL METHOD cl_salv_table=&gt;factory
          EXPORTING
            list_display = if_salv_c_bool_sap=&gt;false
          IMPORTING
            r_salv_table = ex_rf_table
          CHANGING
            t_table      = ch_table.
      CATCH cx_salv_msg INTO rf_root.
        me-&gt;handle_error( EXPORTING rf_oref = rf_root ).
    ENDTRY.
    IF rf_table_xls IS INITIAL.
      MESSAGE &apos;Error Creating ALV Grid&apos;(t03) TYPE &apos;A&apos; DISPLAY LIKE &apos;E&apos;.
    ENDIF.
  ENDMETHOD.                    &quot;alv_init

  METHOD set_color.
*   Color Structure of columns
    DATA: ta_scol                     TYPE lvc_t_scol.
    DATA: st_scol                     TYPE lvc_s_scol.
    FIELD-SYMBOLS: &lt;fs_main&gt; TYPE ty_request_details.
    LOOP AT me-&gt;main_list ASSIGNING &lt;fs_main&gt;.
*     Init
      REFRESH: ta_scol.
      CLEAR  : st_scol.
      MOVE ta_scol TO &lt;fs_main&gt;-t_color.
*     Add color
      IF &lt;fs_main&gt;-warning_rank &gt;= co_info_rank.
        REFRESH: ta_scol.
        CLEAR  : st_scol.
        MOVE 3             TO st_scol-color-col.
        MOVE 0             TO st_scol-color-int.
        MOVE 0             TO st_scol-color-inv.
        MOVE &apos;WARNING_TXT&apos; TO st_scol-fname.
        APPEND st_scol     TO ta_scol.
        MOVE &apos;WARNING_LVL&apos; TO st_scol-fname.
        APPEND st_scol     TO ta_scol.
        MOVE ta_scol       TO &lt;fs_main&gt;-t_color.
      ENDIF.
      IF &lt;fs_main&gt;-warning_rank &gt;= co_warn_rank.
        REFRESH: ta_scol.
        CLEAR  : st_scol.
        MOVE 7             TO st_scol-color-col.
        MOVE 0             TO st_scol-color-int.
        MOVE 0             TO st_scol-color-inv.
        MOVE &apos;WARNING_TXT&apos; TO st_scol-fname.
        APPEND st_scol     TO ta_scol.
        MOVE &apos;WARNING_LVL&apos; TO st_scol-fname.
        APPEND st_scol     TO ta_scol.
        MOVE ta_scol       TO &lt;fs_main&gt;-t_color.
      ENDIF.
      IF &lt;fs_main&gt;-warning_rank &gt;= co_error_rank.
        REFRESH: ta_scol.
        CLEAR  : st_scol.
        MOVE 6             TO st_scol-color-col.
        MOVE 0             TO st_scol-color-int.
        MOVE 0             TO st_scol-color-inv.
        MOVE &apos;WARNING_TXT&apos; TO st_scol-fname.
        APPEND st_scol     TO ta_scol.
        MOVE &apos;WARNING_LVL&apos; TO st_scol-fname.
        APPEND st_scol     TO ta_scol.
        MOVE ta_scol       TO &lt;fs_main&gt;-t_color.
      ENDIF.
    ENDLOOP.
  ENDMETHOD.                    &quot;set_color

  METHOD set_check_flag.
    IF im_check_flag IS SUPPLIED.
      me-&gt;check_flag = im_check_flag.
    ELSE.
      me-&gt;check_flag = abap_true.
    ENDIF.
  ENDMETHOD.                    &quot;set_check_flag

  METHOD set_check_ddic.
    IF im_check_ddic IS SUPPLIED.
      me-&gt;check_ddic = im_check_ddic.
    ELSE.
      me-&gt;check_ddic = abap_true.
    ENDIF.
  ENDMETHOD.                    &quot;set_ddic_check

  METHOD set_check_tabkeys.
    IF im_check_tabkeys IS SUPPLIED.
      me-&gt;check_tabkeys = im_check_tabkeys.
    ELSE.
      me-&gt;check_tabkeys = abap_true.
    ENDIF.
  ENDMETHOD.                    &quot;set_check_tabkeys

  METHOD set_clear_checked.
    IF im_clear_checked IS SUPPLIED.
      me-&gt;clear_checked = im_clear_checked.
    ELSE.
      me-&gt;clear_checked = abap_true.
    ENDIF.
  ENDMETHOD.                    &quot;set_clear_checked

  METHOD set_skip_buffer_chk.
    IF im_skip_buffer_chk IS SUPPLIED.
      me-&gt;skip_buffer_chk = im_skip_buffer_chk.
    ELSE.
      me-&gt;skip_buffer_chk = abap_true.
    ENDIF.
  ENDMETHOD.                    &quot;set_skip_buffer_chk

  METHOD set_trkorr_range.
    me-&gt;trkorr_range = im_trkorr_range.
  ENDMETHOD.                    &quot;set_trkorr_range

  METHOD set_project_range.
    me-&gt;project_range = im_project_range.
  ENDMETHOD.                    &quot;set_trkorr_range

  METHOD set_date_range.
    me-&gt;date_range = im_date_range.
  ENDMETHOD.                    &quot;set_trkorr_range

  METHOD set_excluded_objects.
    me-&gt;excluded_objects = im_excluded_objects.
  ENDMETHOD.                    &quot;set_trkorr_range

  METHOD set_search_string.
    me-&gt;search_string = im_search_string.
  ENDMETHOD.                    &quot;set_search_string

  METHOD set_user_layout.
    me-&gt;user_layout = im_user_layout.
  ENDMETHOD.                    &quot;set_user_layout

  METHOD set_process_type.
    me-&gt;process_type = im_process_type.
  ENDMETHOD.                    &quot;set_process_type

  METHOD  set_skiplive.
    IF im_skiplive IS SUPPLIED.
      me-&gt;skiplive = im_skiplive.
    ELSE.
      me-&gt;skiplive = abap_true.
    ENDIF.
  ENDMETHOD.                    &quot;set_skiplive

  METHOD set_filename.
    me-&gt;filename = im_filename.
  ENDMETHOD.                    &quot;set_filename

  METHOD set_systems.
    me-&gt;dev_system = im_dev_system.
    me-&gt;qas_system = im_qas_system.
    me-&gt;prd_system = im_prd_system.
  ENDMETHOD.                    &quot;set_systems

  METHOD set_building_conflict_popup.
    IF im_building_conflict_popup IS SUPPLIED.
      me-&gt;building_conflict_popup = im_building_conflict_popup.
    ELSE.
      me-&gt;building_conflict_popup = abap_true.
    ENDIF.
  ENDMETHOD.                    &quot;set_building_conflict_popup

  METHOD alv_set_properties.
*   Declaration for ALV Columns
    DATA: lr_columns_table       TYPE REF TO cl_salv_columns_table.
    DATA: lt_t_column_ref        TYPE salv_t_column_ref.
    DATA: lr_functions_list      TYPE REF TO cl_salv_functions_list.
*   Declaration for Top of List settings
    DATA: lr_form_element        TYPE REF TO cl_salv_form_element.
*   Declaration for Layout Settings
    DATA: lr_layout              TYPE REF TO cl_salv_layout.
    DATA: ls_layout_key          TYPE salv_s_layout_key.
*   Declaration for Aggregate Function Settings
    DATA: lr_aggregations        TYPE REF TO cl_salv_aggregations.
*   Declaration for Sort Function Settings
    DATA: lr_sorts               TYPE REF TO cl_salv_sorts.
*   Declaration for Table Selection settings
    DATA: lr_selections          TYPE REF TO cl_salv_selections.
*   Declaration for Global Display Settings
    DATA: lr_display_settings    TYPE REF TO cl_salv_display_settings.
    DATA: lp_version             TYPE char10.
    DATA: lp_title               TYPE lvc_title.
    DATA: lp_class               TYPE xuclass.

    FIELD-SYMBOLS: &lt;table&gt;       TYPE REF TO cl_salv_table.
    ASSIGN im_table TO &lt;table&gt;.

*   Set status
*   Copy the status from program SAPLSLVC_FULLSCREEN and delete the
*   buttons you do not need. Add extra buttons for use in USER_COMMAND
    &lt;table&gt;-&gt;set_screen_status( pfstatus = &apos;STANDARD_FULLSCREEN&apos;
                                report   = sy-repid ).
*   Get functions details
    lr_functions_list = &lt;table&gt;-&gt;get_functions( ).
*   Activate All Buttons in Tool Bar
    lr_functions_list-&gt;set_all( if_salv_c_bool_sap=&gt;true ).
*   If necessary, deactivate functions
    IF check_flag = abap_false.
      TRY.
          lr_functions_list-&gt;set_function( name    = &apos;RECHECK&apos;
                                           boolean = if_salv_c_bool_sap=&gt;false ).
        CATCH cx_root INTO rf_root.
          me-&gt;handle_error( EXPORTING rf_oref = rf_root ).
      ENDTRY.
    ENDIF.
*   Layout Settings
    CLEAR : lr_layout,
            ls_layout_key.
*   Set Report ID as Layout Key
    MOVE sy-repid TO ls_layout_key-report.
*   Get Layout of Table
    lr_layout = &lt;table&gt;-&gt;get_layout( ).
*   To allow DEFAULT layout
    lr_layout-&gt;set_default( if_salv_c_bool_sap=&gt;true ).
*   Set Report Id to Layout
    lr_layout-&gt;set_key( ls_layout_key ).
*   If the user is part of a specific class, then the user can
*   maintain all layouts. Otherwise only the user specific layout.
    SELECT SINGLE class FROM  usr02
                        INTO  lp_class
                        WHERE bname = sy-uname.
*   Changed to specific users...
    IF lp_class = &apos;SB&apos;.
      lp_save_restriction = if_salv_c_layout=&gt;restrict_none.
    ELSE.
      lp_save_restriction = if_salv_c_layout=&gt;restrict_user_dependant.
    ENDIF.
*   If the flag is set the default layout will be the default user
*   specific layout
    IF me-&gt;user_layout = abap_false.
      lr_layout-&gt;set_initial_layout( &apos;/DEFAULT&apos; ).
    ENDIF.

    lr_layout-&gt;set_save_restriction( lp_save_restriction ).
*   Global Display Settings
    CLEAR : lr_display_settings.
*   Build title:
*   Get version to display in title:
    SELECT datum FROM  vrsd
                 INTO  vrsd-datum UP TO 1 ROWS
                 WHERE objtype = &apos;REPS&apos;
                 AND   objname = sy-repid.
      WRITE vrsd-datum TO lp_version.
    ENDSELECT.
    IF lp_version IS NOT INITIAL.
      SELECT SINGLE text FROM  d347t INTO lp_title
                         WHERE progname = sy-repid
                         AND   sprsl    = sy-langu
                         AND   obj_code = &apos;001&apos;.
      IF sy-subrc &lt;&gt; 0.
        SELECT SINGLE text FROM  d347t INTO lp_title
                           WHERE progname = sy-repid
                           AND   sprsl    = &apos;EN&apos;
                           AND   obj_code = &apos;001&apos;.
      ENDIF.
    ENDIF.
*   Set title
    IF lp_title IS INITIAL.
      lp_title = sy-title.
    ELSE.
      REPLACE &apos;&amp;1&apos; WITH lp_version INTO lp_title.
    ENDIF.
*   Global display settings
    lr_display_settings = &lt;table&gt;-&gt;get_display_settings( ).
*   Activate Striped Pattern
    lr_display_settings-&gt;set_striped_pattern( if_salv_c_bool_sap=&gt;true ).
*   Report header
    lr_display_settings-&gt;set_list_header( lp_title ).
*   Aggregate Function Settings
    lr_aggregations = &lt;table&gt;-&gt;get_aggregations( ).
*   Sort Functions
    lr_sorts = &lt;table&gt;-&gt;get_sorts( ).
    IF lr_sorts IS NOT INITIAL.
      TRY.
          lr_sorts-&gt;add_sort( columnname = &apos;AS4DATE&apos;
                              position = 1
                              sequence   = if_salv_c_sort=&gt;sort_up
                              subtotal   = if_salv_c_bool_sap=&gt;false
                              obligatory = if_salv_c_bool_sap=&gt;false ).
        CATCH cx_salv_not_found INTO rf_root.
          me-&gt;handle_error( EXPORTING rf_oref = rf_root ).
        CATCH cx_salv_existing INTO rf_root.
          me-&gt;handle_error( EXPORTING rf_oref = rf_root ).
        CATCH cx_salv_data_error INTO rf_root.
          me-&gt;handle_error( EXPORTING rf_oref = rf_root ).
      ENDTRY.
      TRY.
          lr_sorts-&gt;add_sort( columnname = &apos;AS4TIME&apos;
                              position = 2
                              sequence   = if_salv_c_sort=&gt;sort_up
                              subtotal   = if_salv_c_bool_sap=&gt;false
                              group      = if_salv_c_sort=&gt;group_none
                              obligatory = if_salv_c_bool_sap=&gt;false ).
        CATCH cx_salv_not_found INTO rf_root.
          me-&gt;handle_error( EXPORTING rf_oref = rf_root ).
        CATCH cx_salv_existing INTO rf_root.
          me-&gt;handle_error( EXPORTING rf_oref = rf_root ).
        CATCH cx_salv_data_error INTO rf_root.
          me-&gt;handle_error( EXPORTING rf_oref = rf_root ).
      ENDTRY.
    ENDIF.
*   Table Selection Settings
    lr_selections = &lt;table&gt;-&gt;get_selections( ).
    IF lr_selections IS NOT INITIAL.
*   Allow row Selection
      lr_selections-&gt;set_selection_mode(
                     if_salv_c_selection_mode=&gt;row_column ).
    ENDIF.
*   Event Register settings
    rf_events_table = &lt;table&gt;-&gt;get_event( ).
    CREATE OBJECT rf_handle_events.
    SET HANDLER rf_handle_events-&gt;on_function_click FOR rf_events_table.
    SET HANDLER rf_handle_events-&gt;on_double_click   FOR rf_events_table.
    SET HANDLER rf_handle_events-&gt;on_link_click     FOR rf_events_table.
*   Get the columns from ALV Table
    lr_columns_table = &lt;table&gt;-&gt;get_columns( ).
    IF lr_columns_table IS NOT INITIAL.
      REFRESH : lt_t_column_ref.
      lt_t_column_ref = lr_columns_table-&gt;get( ).
*     Get columns properties
      lr_columns_table-&gt;set_optimize( if_salv_c_bool_sap=&gt;true ).
      lr_columns_table-&gt;set_key_fixation( if_salv_c_bool_sap=&gt;true ).
      TRY.
          lr_columns_table-&gt;set_color_column( &apos;T_COLOR&apos; ).
        CATCH cx_salv_data_error INTO rf_root.
          me-&gt;handle_error( EXPORTING rf_oref = rf_root ).
      ENDTRY.
*     Individual Column Properties.
      me-&gt;column_settings( EXPORTING im_column_ref         = lt_t_column_ref
                                     im_rf_columns_table   = lr_columns_table
                                     im_table              = &lt;table&gt; ).
    ENDIF.
*   Skip the following code for the conflicts popups
    IF &lt;table&gt; &lt;&gt; rf_conflicts.
*     Top of List settings
      me-&gt;top_of_page( IMPORTING ex_form_element = lr_form_element ).
      &lt;table&gt;-&gt;set_top_of_list( lr_form_element ).
    ENDIF.
  ENDMETHOD.                    &quot;alv_set_properties

  METHOD alv_set_tooltips.
*   Fill the symbols, colors in to table and set tooltips
    DATA: tooltips TYPE REF TO cl_salv_tooltips.
    DATA: settings TYPE REF TO cl_salv_functional_settings.
    DATA: value    TYPE char128.
    DATA: lp_text  TYPE lvc_tip.
    FIELD-SYMBOLS: &lt;outtab&gt; TYPE ty_request_details.
    FREE settings.
    FREE tooltips.
    settings = im_table-&gt;get_functional_settings( ).
    tooltips = settings-&gt;get_tooltips( ).
    TRY.
        lp_text = &apos;Newer version in Acceptance&apos;(w23).
        tooltips-&gt;add_tooltip( type    = cl_salv_tooltip=&gt;c_type_symbol
                               value   = &apos;@0S@&apos;
                               tooltip = lp_text ).
      CATCH cx_salv_existing INTO rf_root.
    ENDTRY.
    TRY.
        lp_text = &apos;Previous transport not transported&apos;(w17).
        tooltips-&gt;add_tooltip( type    = cl_salv_tooltip=&gt;c_type_symbol
                               value   = &apos;@5D@&apos;
                               tooltip = lp_text ).
      CATCH cx_salv_existing INTO rf_root.
    ENDTRY.
    TRY.
        lp_text = &apos;All conflicts are dealt with by the list&apos;(w04).
        tooltips-&gt;add_tooltip( type    = cl_salv_tooltip=&gt;c_type_symbol
                               value   = &apos;@AI@&apos;
                               tooltip = lp_text ).
      CATCH cx_salv_existing INTO rf_root.
    ENDTRY.
    TRY.
        lp_text = &apos;Marked for re-import to Production&apos;(w18).
        tooltips-&gt;add_tooltip( type    = cl_salv_tooltip=&gt;c_type_symbol
                               value   = &apos;@K3@&apos;
                               tooltip = lp_text ).
      CATCH cx_salv_existing INTO rf_root.
    ENDTRY.
    TRY.
        lp_text = &apos;Newer version in production!&apos;(w01).
        tooltips-&gt;add_tooltip( type    = cl_salv_tooltip=&gt;c_type_symbol
                               value   = &apos;@F1@&apos;
                               tooltip = lp_text ).
      CATCH cx_salv_existing INTO rf_root.
    ENDTRY.
    TRY.
        lp_text = &apos;Object missing in List and Production!&apos;(w05).
        tooltips-&gt;add_tooltip( type    = cl_salv_tooltip=&gt;c_type_symbol
                               value   = &apos;@CY@&apos;
                               tooltip = lp_text ).
      CATCH cx_salv_existing INTO rf_root.
    ENDTRY.
  ENDMETHOD.                    &quot;alv_set_tooltips

  METHOD alv_output.
*   Display the ALV output
    CALL METHOD rf_table-&gt;display.
  ENDMETHOD.                    &quot;alv_output

  METHOD alv_xls_output.
*   Display the ALV output
    CALL METHOD rf_table_xls-&gt;display.
  ENDMETHOD.                    &quot;alv_output

  METHOD column_settings.
    TYPES: BEGIN OF lty_field_ran,
             sign   TYPE c LENGTH 1,
             option TYPE c LENGTH 2,
             low    TYPE fieldname,
             high   TYPE fieldname,
           END OF lty_field_ran.

    DATA: ls_reference        TYPE salv_s_ddic_reference.
    DATA: ls_s_column_ref     TYPE salv_s_column_ref.
    DATA: lr_column_table     TYPE REF TO cl_salv_column_table.
    DATA: st_colo             TYPE lvc_s_colo.
*   Declaration for Aggregate Function Settings
    DATA: lr_aggregations     TYPE REF TO cl_salv_aggregations.
*   Remove some columns for the XLS output
    DATA: lra_fieldname       TYPE RANGE OF lty_field_ran.
    DATA: ls_fieldname        TYPE lty_field_ran.
    DATA: lp_return           TYPE abap_bool.
*   Hide columns when empty
    DATA: lra_hide_when_empty TYPE RANGE OF lty_field_ran.
    DATA: ls_hide_when_empty  TYPE lty_field_ran.
*   Texts
    DATA: lp_short_text       TYPE char10.
    DATA: lp_medium_text      TYPE char20.
    DATA: lp_long_text        TYPE char40.
*   Build range for all unwanted columns:
    CASE im_table.
      WHEN rf_table_xls.
        ls_fieldname-option = &apos;EQ&apos;.
        ls_fieldname-sign = &apos;I&apos;.
        ls_fieldname-low = &apos;CHECKED&apos;.
        APPEND ls_fieldname TO lra_fieldname.
        ls_fieldname-low = &apos;OBJECT&apos;.
        APPEND ls_fieldname TO lra_fieldname.
        ls_fieldname-low = &apos;OBJ_NAME&apos;.
        APPEND ls_fieldname TO lra_fieldname.
        ls_fieldname-low = &apos;OBJKEY&apos;.
        APPEND ls_fieldname TO lra_fieldname.
        ls_fieldname-low = &apos;KEYOBJECT&apos;.
        APPEND ls_fieldname TO lra_fieldname.
        ls_fieldname-low = &apos;KEYOBJNAME&apos;.
        APPEND ls_fieldname TO lra_fieldname.
        ls_fieldname-low = &apos;TABKEY&apos;.
        APPEND ls_fieldname TO lra_fieldname.
        ls_fieldname-low = &apos;DEV&apos;.
        APPEND ls_fieldname TO lra_fieldname.
        ls_fieldname-low = &apos;QAS&apos;.
        APPEND ls_fieldname TO lra_fieldname.
        ls_fieldname-low = &apos;PRD&apos;.
        APPEND ls_fieldname TO lra_fieldname.
        ls_fieldname-low = &apos;STATUS_TEXT&apos;.
        APPEND ls_fieldname TO lra_fieldname.
      WHEN rf_table.
    ENDCASE.
*   Always remove the following colums, regardless of which table is used
    ls_fieldname-option = &apos;EQ&apos;.
    ls_fieldname-sign = &apos;I&apos;.
    ls_fieldname-low = &apos;TRSTATUS&apos;.
    APPEND ls_fieldname TO lra_fieldname.
    ls_fieldname-low = &apos;TRFUNCTION&apos;.
    APPEND ls_fieldname TO lra_fieldname.
    ls_fieldname-low = &apos;TROBJ_NAME  &apos;.
    APPEND ls_fieldname TO lra_fieldname.
    ls_fieldname-low = &apos;FLAG&apos;.
    APPEND ls_fieldname TO lra_fieldname.
    ls_fieldname-low = &apos;OBJFUNC&apos;.
    APPEND ls_fieldname TO lra_fieldname.
    ls_fieldname-low = &apos;CHECKED_BY&apos;.
    APPEND ls_fieldname TO lra_fieldname.
    ls_fieldname-low = &apos;WARNING_RANK&apos;.
    APPEND ls_fieldname TO lra_fieldname.

*   Hide when empty
    ls_hide_when_empty-option = &apos;EQ&apos;.
    ls_hide_when_empty-sign   = &apos;I&apos;.
    ls_hide_when_empty-low    = &apos;OBJKEY&apos;.
    APPEND ls_hide_when_empty TO lra_hide_when_empty.
    ls_hide_when_empty-low    = &apos;KEYOBJECT&apos;.
    APPEND ls_hide_when_empty TO lra_hide_when_empty.
    ls_hide_when_empty-low    = &apos;KEYOBJNAME&apos;.
    APPEND ls_hide_when_empty TO lra_hide_when_empty.
    ls_hide_when_empty-low    = &apos;TABKEY&apos;.
    APPEND ls_hide_when_empty TO lra_hide_when_empty.
    ls_hide_when_empty-low    = &apos;PROJECT&apos;.
    APPEND ls_hide_when_empty TO lra_hide_when_empty.
    ls_hide_when_empty-low    = &apos;PROJECT_DESCR&apos;.
    APPEND ls_hide_when_empty TO lra_hide_when_empty.

    LOOP AT im_column_ref INTO ls_s_column_ref.
      TRY.
          lr_column_table ?=
            im_rf_columns_table-&gt;get_column( ls_s_column_ref-columnname ).
        CATCH cx_salv_not_found INTO rf_root.
          me-&gt;handle_error( EXPORTING rf_oref = rf_root ).
      ENDTRY.
      IF lr_column_table IS NOT INITIAL.
*       Make Mandt column invisible
        IF lr_column_table-&gt;get_ddic_datatype( ) = &apos;CLNT&apos;.
          lr_column_table-&gt;set_technical( if_salv_c_bool_sap=&gt;true ).
        ENDIF.
*       Create Aggregate function total for All Numeric/Currency Fields
        IF lr_column_table-&gt;get_ddic_inttype( ) EQ &apos;P&apos; OR
           lr_column_table-&gt;get_ddic_datatype( ) EQ &apos;CURR&apos;.
          IF lr_aggregations IS NOT INITIAL.
            TRY.
                lr_aggregations-&gt;add_aggregation(
                                  columnname = ls_s_column_ref-columnname
                                  aggregation = if_salv_c_aggregation=&gt;total ).
              CATCH cx_salv_data_error INTO rf_root.
                me-&gt;handle_error( EXPORTING rf_oref = rf_root ).
              CATCH cx_salv_not_found INTO rf_root.
                me-&gt;handle_error( EXPORTING rf_oref = rf_root ).
              CATCH cx_salv_existing INTO rf_root.
                me-&gt;handle_error( EXPORTING rf_oref = rf_root ).
            ENDTRY.
          ENDIF.
        ENDIF.
*       Create Check box for fields with domain &quot;XFELD&quot;
        IF lr_column_table-&gt;get_ddic_domain( ) EQ &apos;XFELD&apos;.
          lr_column_table-&gt;set_cell_type( if_salv_c_cell_type=&gt;checkbox ).
        ENDIF.
*       Set color to Date Columns
        IF lr_column_table-&gt;get_ddic_datatype( ) EQ &apos;DATS&apos; OR
           lr_column_table-&gt;get_ddic_datatype( ) EQ &apos;TIMS&apos;.
          CLEAR : st_colo.
          MOVE 2 TO st_colo-col.
          MOVE 1 TO st_colo-int.
          MOVE 1 TO st_colo-inv.
          lr_column_table-&gt;set_color( st_colo ).
        ENDIF.
*       Remove columns that are not required
        IF lr_column_table-&gt;get_columnname( ) IN lra_fieldname.
          lr_column_table-&gt;set_technical( if_salv_c_bool_sap=&gt;true ).
        ENDIF.
*       Remove columns that are not required when empty
        IF lr_column_table-&gt;get_columnname( ) IN lra_hide_when_empty.
          lp_return = me-&gt;is_empty_column( im_column = ls_s_column_ref-columnname
                                                im_table  = main_list ).
          IF lp_return = abap_true.
            lr_column_table-&gt;set_technical( if_salv_c_bool_sap=&gt;true ).
          ENDIF.
        ENDIF.
        CASE lr_column_table-&gt;get_columnname( ).
          WHEN &apos;TRKORR&apos;.
*           Add Hotspot &amp; Hyper Link
            lr_column_table-&gt;set_cell_type( if_salv_c_cell_type=&gt;hotspot ).
            lr_column_table-&gt;set_key( if_salv_c_bool_sap=&gt;true ).
          WHEN &apos;CHECKED&apos;.
            IF check_flag = abap_true.
              ls_reference-table = &apos;KGALK&apos;.
              ls_reference-field = &apos;CHECKED&apos;.
              lr_column_table-&gt;set_ddic_reference( ls_reference ).
              lr_column_table-&gt;set_alignment( if_salv_c_alignment=&gt;centered ).
            ELSE.
              lr_column_table-&gt;set_technical( ).
            ENDIF.
          WHEN &apos;INFO&apos;.
            ls_reference-table = &apos;RSPRINT&apos;.
            ls_reference-field = &apos;DOKU&apos;.
            lr_column_table-&gt;set_ddic_reference( ls_reference ).
            lr_column_table-&gt;set_alignment( if_salv_c_alignment=&gt;centered ).
            lr_column_table-&gt;set_icon( ).
          WHEN &apos;CHECKED_BY&apos;.
            IF check_flag = &apos;&apos;.
              lr_column_table-&gt;set_technical( ).
            ENDIF.
          WHEN &apos;RETCODE&apos;.
            lp_short_text = &apos;RC&apos;(015).
            lp_long_text = lp_medium_text = &apos;Return Code&apos;(016).
            lr_column_table-&gt;set_short_text( lp_short_text ).
            lr_column_table-&gt;set_medium_text( lp_medium_text ).
            lr_column_table-&gt;set_long_text( lp_long_text ).
          WHEN &apos;STATUS_TEXT&apos;.
            lp_short_text = &apos;Descript.&apos;(017).
            lp_long_text = lp_medium_text = &apos;Description&apos;(018).
            lr_column_table-&gt;set_short_text( lp_short_text ).
            lr_column_table-&gt;set_medium_text( lp_medium_text ).
            lr_column_table-&gt;set_long_text( lp_long_text ).
          WHEN &apos;WARNING_LVL&apos;.
            IF check_flag = abap_true.
              ls_reference-table = &apos;FCALV_S_RMLIFO20&apos;.
              ls_reference-field = &apos;WARNING&apos;.
              lr_column_table-&gt;set_ddic_reference( ls_reference ).
              lr_column_table-&gt;set_icon( ).
            ELSE.
              lr_column_table-&gt;set_technical( ).
            ENDIF.
          WHEN &apos;WARNING_TXT&apos;.
            IF check_flag = abap_true.
              ls_reference-table = &apos;CSIM_ST_EXPL&apos;.
              ls_reference-field = &apos;TEXT_WARNING&apos;.
              lr_column_table-&gt;set_ddic_reference( ls_reference ).
            ELSE.
              lr_column_table-&gt;set_technical( ).
            ENDIF.
          WHEN &apos;PROJECT&apos;.
            ls_reference-table = &apos;LOG_HEADER&apos;.
            ls_reference-field = &apos;PRONR&apos;.
            lr_column_table-&gt;set_ddic_reference( ls_reference ).
          WHEN &apos;STATUS&apos;.
            ls_reference-table = &apos;TRHEADER&apos;.
            ls_reference-field = &apos;TRSTATUS&apos;.
            lr_column_table-&gt;set_ddic_reference( ls_reference ).
            lr_column_table-&gt;set_key( ).
          WHEN &apos;DEV&apos;.
            lr_column_table-&gt;set_short_text( &apos;DEV&apos; ).
            lr_column_table-&gt;set_medium_text( &apos;DEV&apos; ).
            lr_column_table-&gt;set_long_text( &apos;DEV&apos; ).
            lr_column_table-&gt;set_icon( ).
          WHEN &apos;QAS&apos;.
            lr_column_table-&gt;set_short_text( &apos;QAS&apos; ).
            lr_column_table-&gt;set_medium_text( &apos;QAS&apos; ).
            lr_column_table-&gt;set_long_text( &apos;QAS&apos; ).
            lr_column_table-&gt;set_icon( ).
          WHEN &apos;PRD&apos;.
            lr_column_table-&gt;set_short_text( &apos;PRD&apos; ).
            lr_column_table-&gt;set_medium_text( &apos;PRD&apos; ).
            lr_column_table-&gt;set_long_text( &apos;PRD&apos; ).
            lr_column_table-&gt;set_icon( ).
        ENDCASE.
      ENDIF.
    ENDLOOP.
  ENDMETHOD.                    &quot;column_settings

  METHOD is_empty_column.
    DATA: ls_line TYPE ty_request_details.
    FIELD-SYMBOLS: &lt;column&gt; TYPE any.
    re_is_empty = abap_true.
    LOOP AT im_table INTO ls_line.
      ASSIGN COMPONENT im_column OF STRUCTURE ls_line TO &lt;column&gt;.
      IF &lt;column&gt; IS NOT INITIAL.
        re_is_empty = abap_false.
        EXIT.
      ENDIF.
    ENDLOOP.
  ENDMETHOD.                    &quot;is_empty_culomn

  METHOD docu_call.
    CALL FUNCTION &apos;DOCU_CALL&apos;
      EXPORTING
        id         = &apos;TA&apos;
        langu      = &apos;E&apos;
        object     = im_object
      EXCEPTIONS
        wrong_name = 1
        OTHERS     = 2.
    IF sy-subrc &lt;&gt; 0.
      MESSAGE ID sy-msgid TYPE sy-msgty NUMBER sy-msgno
              WITH sy-msgv1 sy-msgv2 sy-msgv3 sy-msgv4.
    ENDIF.
  ENDMETHOD.                    &quot;docu_call

  METHOD determine_col_width.
* This method determines the width of a column in the detailed output
* lists (for conflicts or no-checks overviews). The length of the
* largest value is used as column width. This column width is then used
* in the fielddif table for function &quot;STC1_POPUP_WITH_TABLE_CONTROL&quot;.
* This is done to downsize the width of the column as much as possible.
    DATA: lp_value TYPE i.

    CLEAR: ex_colwidth.
    IF NOT im_field IS INITIAL.
      lp_value = strlen( im_field ).
      IF lp_value &gt; ex_colwidth.
        ex_colwidth = lp_value.
      ENDIF.
    ENDIF.
  ENDMETHOD.                    &quot;determine_col_width

  METHOD determine_warning_text.
    CASE im_highest_rank.
      WHEN 0.  &quot;ICON_LED_GREEN
      WHEN 5.  &quot;ICON_FAILURE
        ex_highest_text = lp_alert0_text.
      WHEN 6.  &quot;ICON_FAILURE
        ex_highest_text = lp_alert1_text.
      WHEN 7.  &quot;ICON_FAILURE
        ex_highest_text = lp_alert2_text.
      WHEN 8.  &quot;ICON_FAILURE
        ex_highest_text  = lp_alert3_text.
      WHEN 10. &quot;ICON_HINT
        ex_highest_text = lp_hint1_text.
      WHEN 12. &quot;ICON_HINT
        ex_highest_text = lp_hint2_text.
      WHEN 14. &quot;ICON_HINT
        ex_highest_text = lp_hint3_text.
      WHEN 16. &quot;ICON_HINT
        ex_highest_text = lp_hint4_text.
      WHEN 20. &quot;ICON_INFORMATION
        ex_highest_text = lp_info_text.
      WHEN 50. &quot;ICON_LED_YELLOW
        ex_highest_text = lp_warn_text.
      WHEN 98. &quot;ICON_INCOMPLETE
        ex_highest_text = lp_ddic_text.
      WHEN 99. &quot;ICON_LED_RED
        ex_highest_text = lp_error_text.
    ENDCASE.
  ENDMETHOD.                    &quot;determine_warning_text

  METHOD get_tps_for_same_object.

    DATA: lt_aggr_tp_list_of_objects TYPE tt_request_details.
    DATA: ls_tp_same_object          TYPE ty_request_details.
    DATA: lp_index                   TYPE sytabix.
    DATA: lp_return                  TYPE sysubrc.

    REFRESH: ex_newer,
             ex_older.
    CLEAR:   ex_newer,
             ex_older.

*   First check if the transports for the object have already been read
*   and stored in the table. If so, then we do not need to retrieve all
*   the transports again (to speed things up a bit).
    SORT me-&gt;aggr_tp_list_of_objects BY object
                                        obj_name
                                        keyobject
                                        keyobjname
                                        tabkey.
    READ TABLE me-&gt;aggr_tp_list_of_objects
               WITH KEY object     = im_line-object
                        obj_name   = im_line-obj_name
                        keyobject  = im_line-keyobject
                        keyobjname = im_line-keyobjname
                        tabkey     = im_line-tabkey
               TRANSPORTING NO FIELDS
               BINARY SEARCH.
    IF sy-subrc &lt;&gt; 0.
*     The transports for this object have not been retrieved yet, so we
*     do that now:
      SELECT a~trkorr b~object  b~obj_name b~objfunc
             a~as4user a~as4date a~as4time
             FROM e070 AS a JOIN e071 AS b                  &quot;v_e071eu
                       ON a~trkorr = b~trkorr
             INTO (ls_tp_same_object-trkorr,
                   ls_tp_same_object-object,
                   ls_tp_same_object-obj_name,
                   ls_tp_same_object-objfunc,
                   ls_tp_same_object-as4user,
                   ls_tp_same_object-as4date,
                   ls_tp_same_object-as4time)
             WHERE NOT a~trkorr IN  me-&gt;project_trkorrs
             AND   b~obj_name   IN excluded_objects
             AND   a~strkorr    = &apos;&apos;
             AND   a~trkorr     LIKE me-&gt;prefix
             AND   b~object     = im_line-object
             AND   b~obj_name   = im_line-obj_name.
        APPEND ls_tp_same_object TO lt_aggr_tp_list_of_objects.
      ENDSELECT.

*   Also read from version table, because in some case, the object can
*   be part of a &apos;bigger&apos; group.
*   Example 1: - a Function Module (FUNC) is transported in one
*                transport, but the entire functiongroup (FUGR) in
*                another (this also transports the FM)
*   Example 2: - A table (TABL) is part of a table definition (TABD), so
*                should also be treated as the same object.
      SELECT korrnum objtype objname
             author
             FROM  vrsd
             INTO (ls_tp_same_object-trkorr,
                   ls_tp_same_object-object,
                   ls_tp_same_object-obj_name,
                   ls_tp_same_object-as4user)
             WHERE NOT korrnum IN  me-&gt;project_trkorrs
             AND   objname     IN excluded_objects
             AND   korrnum     &lt;&gt; im_line-trkorr
             AND   korrnum     LIKE me-&gt;prefix
             AND   korrnum     &lt;&gt; &apos;&apos;
             AND   objtype     =  im_line-object
             AND   objname     =  im_line-obj_name.     &quot;#EC CI_NOFIELD

        APPEND ls_tp_same_object TO lt_aggr_tp_list_of_objects.
      ENDSELECT.

*     Remove duplicates:
      SORT lt_aggr_tp_list_of_objects[] BY trkorr object obj_name.
      DELETE ADJACENT DUPLICATES FROM lt_aggr_tp_list_of_objects
                                 COMPARING trkorr object obj_name.

*     If the object is a table, we need to be able to check the keys.
*     Replace the entry with all entries containing the keys.
      IF im_line-objfunc = &apos;K&apos;.
        me-&gt;add_table_keys_to_list( IMPORTING table = lt_aggr_tp_list_of_objects ).
      ENDIF.

*     Now get the last date the object was imported:
      LOOP AT lt_aggr_tp_list_of_objects INTO ls_tp_same_object.
        lp_index = sy-tabix.
*       Remove all transports from a source system not known (usually an
*       SAP system, not one of our systems).
        IF NOT ls_tp_same_object-trkorr(3) IN ra_systems.
          DELETE lt_aggr_tp_list_of_objects INDEX sy-tabix.
          CONTINUE.
        ENDIF.
*       Now get the global information on the transport:
*       Get the last date the object was imported
        me-&gt;get_import_datetime_qas( EXPORTING im_trkorr  = ls_tp_same_object-trkorr
                                     IMPORTING ex_as4time = ls_tp_same_object-as4time
                                               ex_as4date = ls_tp_same_object-as4date
                                               ex_return  = lp_return ).
        IF lp_return = 0.
          MODIFY lt_aggr_tp_list_of_objects FROM ls_tp_same_object.
        ELSE.
          DELETE lt_aggr_tp_list_of_objects INDEX lp_index.
        ENDIF.
      ENDLOOP.
*     Add the newly retrieved lines to the internal table:
      APPEND LINES OF lt_aggr_tp_list_of_objects TO me-&gt;aggr_tp_list_of_objects.
    ELSE.
*     Already retrieved and stored in the list
      CHECK 1 = 1.
    ENDIF.

*   Remove duplicates:
    SORT me-&gt;aggr_tp_list_of_objects[] BY trkorr object obj_name.
    DELETE ADJACENT DUPLICATES FROM me-&gt;aggr_tp_list_of_objects
                               COMPARING trkorr object obj_name.

*   Move newer transports for this object to the relevant internal table:
    LOOP AT me-&gt;aggr_tp_list_of_objects INTO ls_tp_same_object
                                        WHERE object     =  im_line-object
                                        AND   obj_name   =  im_line-obj_name
                                        AND   keyobject  =  im_line-keyobject
                                        AND   keyobjname =  im_line-keyobjname
                                        AND   tabkey     =  im_line-tabkey
                                        AND   trkorr     &lt;&gt; im_line-trkorr.
*     If on the same date, check if the time is later
      IF ls_tp_same_object-as4date = im_line-as4date.
        IF ls_tp_same_object-as4time &gt;= im_line-as4time.
          APPEND ls_tp_same_object TO ex_newer.
        ELSE.
          APPEND ls_tp_same_object TO ex_older.
        ENDIF.
      ELSE.
        IF ls_tp_same_object-as4date  &gt; im_line-as4date.
          APPEND ls_tp_same_object TO ex_newer.
        ELSE.
          APPEND ls_tp_same_object TO ex_older.
        ENDIF.
      ENDIF.
    ENDLOOP.

    SORT ex_newer BY as4date DESCENDING as4time DESCENDING.
    SORT ex_older BY as4date DESCENDING as4time DESCENDING.

  ENDMETHOD.                    &quot;get_tps_for_same_object

  METHOD handle_error.
    DATA: lp_msg TYPE string.
    lp_msg = rf_oref-&gt;get_text( ).
    CONCATENATE &apos;ERROR:&apos;(038) lp_msg INTO lp_msg SEPARATED BY space.
    MESSAGE lp_msg TYPE &apos;E&apos;.
  ENDMETHOD.                    &quot;handle_error

  METHOD check_colwidth.
    DATA: ls_component TYPE abap_compdescr.
    DATA: lp_as4text   TYPE as4text.
    DATA: lp_len       TYPE i.
    SELECT SINGLE scrtext_s
                  FROM dd04t INTO lp_as4text
                  WHERE rollname   = im_name
                  AND   ddlanguage = sy-langu.
    IF lp_as4text IS INITIAL.
      SELECT SINGLE scrtext_m
                    FROM dd04t INTO lp_as4text
                    WHERE rollname   = im_name
                    AND   ddlanguage = sy-langu.
      IF lp_as4text IS INITIAL.
        SELECT SINGLE scrtext_l
                      FROM dd04t INTO lp_as4text
                      WHERE rollname   = im_name
                      AND   ddlanguage = sy-langu.
      ENDIF.
    ENDIF.
    lp_len = strlen( lp_as4text ).
    IF lp_len &gt; im_colwidth.
      re_colwidth = lp_len.
    ELSE.
      re_colwidth = im_colwidth.
    ENDIF.
  ENDMETHOD.                    &quot;check_colwidth

  METHOD remove_tp_in_prd.
    LOOP AT me-&gt;main_list TRANSPORTING NO FIELDS WHERE prd = co_okay.
      DELETE me-&gt;main_list INDEX sy-tabix.
    ENDLOOP.
  ENDMETHOD.                    &quot;remove_tp_in_prd

  METHOD sort_main_list.
    SORT me-&gt;main_list BY as4date   ASCENDING
                          as4time    ASCENDING
                          trkorr     ASCENDING
                          object     ASCENDING
                          obj_name   ASCENDING
                          objkey     ASCENDING
                          keyobject  ASCENDING
                          keyobjname ASCENDING
                          tabkey     ASCENDING.
    DELETE ADJACENT DUPLICATES FROM me-&gt;main_list.
  ENDMETHOD.                    &quot;sort_main_list

  METHOD top_of_page.
    DATA: lr_logo             TYPE REF TO cl_salv_form_layout_logo.
    DATA: lp_head             TYPE char50.
    DATA: lp_file_in          TYPE localfile.               &quot;#EC NEEDED
    DATA: lp_file_out         TYPE localfile.
    DATA: lp_records_found(5) TYPE n.
    DATA: lp_picture          TYPE bds_typeid VALUE &apos;XXXXXXXXXXXXXX&apos;.
    DATA: lr_rows             TYPE REF TO cl_salv_form_layout_grid.
    DATA: lr_rows_flow        TYPE REF TO cl_salv_form_layout_flow.
    DATA: lr_row              TYPE REF TO cl_salv_form_layout_flow.
    CREATE OBJECT lr_rows_flow.
    lr_rows = lr_rows_flow-&gt;create_grid( ).
    lr_rows-&gt;create_grid( row     = 0
                          column  = 0
                          rowspan = 1
                          colspan = 100 ).
*   Header of Top of Page
    lp_head = &apos;Information&apos;(t05).
    lr_row = lr_rows-&gt;add_row( ).
    lr_row-&gt;create_header_information(
            text = lp_head
            ).
*   Split filename from path
    IF NOT me-&gt;filename IS INITIAL.
      lp_file_out = me-&gt;filename.
      DO.
        IF lp_file_out CS &apos;\&apos;.
          SPLIT lp_file_out AT &apos;\&apos; INTO lp_file_in lp_file_out.
        ELSE.
          EXIT.
        ENDIF.
      ENDDO.
      lr_row = lr_rows-&gt;add_row( ).
      lr_row = lr_rows-&gt;add_row( ).
      lr_row-&gt;create_label(
        text    = &apos;File uploaded:&apos;(049) ).
      lr_row-&gt;create_text(
        text   = lp_file_out(50) ).
    ENDIF.
    lr_row = lr_rows-&gt;add_row( ).
    lr_row-&gt;create_text(
            text    = &apos;If there is a warning icon in column `Warning`, &apos; &amp;
                      &apos;double-clicking on the icon will display a list &apos; &amp;
                      &apos;of objects that should be checked&apos;(h01)
            ).
    lr_row = lr_rows-&gt;add_row( ).
    lr_row-&gt;create_text(
            text    = &apos;You can add these conflicts by means of the &apos; &amp;
                      &apos;button &apos;&apos;Add Conflicts&apos;&apos; in the application toolbar &apos; &amp;
                      &apos;or doubleclicking the warning&apos;(h02)
            ).
    lr_row = lr_rows-&gt;add_row( ).
    lr_row-&gt;create_label(
            text    = &apos;No of Records found:&apos;(t04)
            ).
    CASE sy-ucomm.
      WHEN &apos;&amp;PREP_XLS&apos;.
        DESCRIBE TABLE me-&gt;main_list_xls LINES lp_records_found.
      WHEN OTHERS.
        DESCRIBE TABLE me-&gt;main_list LINES lp_records_found.
    ENDCASE.
    lr_row-&gt;create_text(
            text    = lp_records_found
            tooltip = lp_records_found
            ).
    lr_row = lr_rows-&gt;add_row( ).
*   Create logo layout, set grid content on left and logo image on right
    CREATE OBJECT lr_logo.
    lr_logo-&gt;set_left_content( lr_rows_flow ).
    lr_logo-&gt;set_right_logo( lp_picture ).
    ex_form_element = lr_logo.


  ENDMETHOD.                    &quot;top_of_page

  METHOD version_check.
    DATA: lversno_list      TYPE STANDARD TABLE OF  vrsn,
          version_list      TYPE STANDARD TABLE OF  vrsd,
          ls_version_list  TYPE vrsd,
          lp_destination   TYPE rfcdest.
    FIELD-SYMBOLS: &lt;l_main_list&gt; TYPE ty_request_details.
    DELETE ADJACENT DUPLICATES FROM me-&gt;main_list COMPARING object obj_name.
*   Delete tables
    DELETE me-&gt;main_list WHERE objfunc = &apos;K&apos;.
    LOOP AT me-&gt;main_list ASSIGNING &lt;l_main_list&gt;.
      REFRESH: lversno_list,
               version_list.
      CLEAR:   ls_version_list.
      ls_version_list-objname = &lt;l_main_list&gt;-obj_name.
      ls_version_list-objtype = &lt;l_main_list&gt;-object.
*     Check local
      CALL FUNCTION &apos;SVRS_GET_VERSION_DIRECTORY_46&apos;
        EXPORTING
          destination            = &apos;NONE&apos;
          objname                = ls_version_list-objname
          objtype                = ls_version_list-objtype
        TABLES
          lversno_list           = lversno_list
          version_list           = version_list
        EXCEPTIONS
          no_entry               = 1
          communication_failure_ = 2
          system_failure         = 3
          OTHERS                 = 4.
      FIELD-SYMBOLS &lt;version_list&gt; TYPE vrsd.
      LOOP AT version_list ASSIGNING &lt;version_list&gt;.     &quot;#EC CI_NESTED
        IF &lt;version_list&gt;-versno &gt; ls_version_list-versno.
*       Latest version.
          ls_version_list = &lt;version_list&gt;.
        ENDIF.
      ENDLOOP.
      REFRESH: lversno_list,
               version_list.
      lp_destination = me-&gt;qas_system.
*     Check system
      CALL FUNCTION &apos;SVRS_GET_VERSION_DIRECTORY_46&apos;
        EXPORTING
          destination            = lp_destination
          objname                = ls_version_list-objname
          objtype                = ls_version_list-objtype
        TABLES
          lversno_list           = lversno_list
          version_list           = version_list
        EXCEPTIONS
          no_entry               = 1
          communication_failure_ = 2
          system_failure         = 3
          OTHERS                 = 4.
      IF sy-subrc &lt;&gt; 0.
        APPEND INITIAL LINE TO version_list ASSIGNING &lt;version_list&gt;.
        &lt;l_main_list&gt;-warning_txt = &apos;No version found to compare&apos;(w02).
      ENDIF.
      LOOP AT version_list ASSIGNING &lt;version_list&gt;.     &quot;#EC CI_NESTED
        IF &lt;version_list&gt;-korrnum &lt;&gt; ls_version_list-korrnum.
          &lt;l_main_list&gt;-warning_lvl  = co_error.
          &lt;l_main_list&gt;-warning_rank = co_error_rank.
        ELSEIF &lt;version_list&gt;-korrnum IS INITIAL.
          &lt;l_main_list&gt;-warning_lvl  = co_warn.
          &lt;l_main_list&gt;-warning_rank = co_warn_rank.
        ELSE.
          &lt;l_main_list&gt;-warning_lvl  = co_okay.
          &lt;l_main_list&gt;-warning_rank = co_okay_rank.
        ENDIF.
      ENDLOOP.
    ENDLOOP.
  ENDMETHOD.                    &quot;version_check

  METHOD display_excel.
    DATA: ls_main_list_xls TYPE me-&gt;ty_request_details.
    DATA: lt_main_list_xls TYPE me-&gt;tt_request_details.
    DATA: lp_variant       TYPE disvariant.
    DATA: lp_return        TYPE c.
    DATA: lp_highest_lvl   TYPE icon_d.
    DATA: lp_highest_rank  TYPE numc4.
    DATA: lp_highest_text  TYPE text74.
    DATA: lp_highest_col   TYPE lvc_t_scol.
*   Only when called from the Main Screen (Object Level). Do not build again
*   when the XLS list has been build already.
    CHECK: me-&gt;main_list_xls IS INITIAL.
*   Remove duplicate transport numbers (only need single lines):
    me-&gt;main_list_xls[] = im_table[].
    SORT me-&gt;main_list_xls BY trkorr ASCENDING.
    DELETE ADJACENT DUPLICATES FROM      me-&gt;main_list_xls
                               COMPARING trkorr.
*   Extra actions:
*   - Make sure to keep the highest warning level
*   - rename Icons to text
*   - remove transports not in QAS
    CLEAR: lp_return.
    LOOP AT me-&gt;main_list_xls INTO me-&gt;main_list_line_xls.
*     Remove transports not in QAS and transports in prd that do not
*     need to be re-transported:
      IF me-&gt;main_list_line_xls-qas &lt;&gt; me-&gt;co_okay OR
         me-&gt;main_list_line_xls-prd =  me-&gt;co_okay.
        lp_return = abap_true.
*        EXIT.
      ENDIF.
*     Rename Documentation Icon to text
      IF me-&gt;main_list_line_xls-info = me-&gt;co_docu.
        me-&gt;main_list_line_xls-info = &apos;Yes&apos;(037).
      ENDIF.
*     Make sure to find and keep the highest warning level for the
*     transport
      CLEAR: lp_highest_lvl,
             lp_highest_rank,
             lp_highest_text,
             lp_highest_col.
      LOOP AT me-&gt;main_list INTO  main_list_line         &quot;#EC CI_NESTED
                            WHERE trkorr = me-&gt;main_list_line_xls-trkorr.
        IF main_list_line-warning_rank &gt; lp_highest_rank.
          lp_highest_rank = main_list_line-warning_rank.
          lp_highest_lvl  = main_list_line-warning_lvl.
          lp_highest_text = main_list_line-warning_txt.
          lp_highest_col  = main_list_line-t_color.
        ENDIF.
      ENDLOOP.
*     Add correct warning and change Warning Lvl Icon to text:
      IF sy-subrc = 0.
        me-&gt;main_list_line_xls-warning_lvl  = lp_highest_lvl.
        me-&gt;main_list_line_xls-warning_rank = lp_highest_rank.
        me-&gt;main_list_line_xls-warning_txt  = lp_highest_text.
        me-&gt;main_list_line_xls-t_color      = lp_highest_col.
        CASE lp_highest_lvl.
          WHEN me-&gt;co_info OR me-&gt;co_hint.
            me-&gt;main_list_line_xls-warning_lvl = &apos;Info&apos;(024).
          WHEN me-&gt;co_error.
            me-&gt;main_list_line_xls-warning_lvl = &apos;ERR.&apos;(033).
          WHEN me-&gt;co_ddic.
            me-&gt;main_list_line_xls-warning_lvl = &apos;ERR.&apos;(033).
          WHEN me-&gt;co_warn.
            me-&gt;main_list_line_xls-warning_lvl = &apos;Warn&apos;(034).
        ENDCASE.
      ENDIF.
*     Apply the changes
      TRY.
          MODIFY me-&gt;main_list_xls FROM me-&gt;main_list_line_xls.
        CATCH cx_root INTO rf_root.
          me-&gt;handle_error( EXPORTING rf_oref = rf_root ).
      ENDTRY.
    ENDLOOP.
*   Message if entries were deleted because they were not in QAS:
    IF lp_return = abap_true.
      MESSAGE i000(db)
         WITH &apos;Some transports were deleted from the list because&apos;(m02)
              &apos;they are missing in Acceptance or are already in&apos;(m03)
              &apos;Production but not marked for re-import.&apos;(m04)
              &apos;Please check the main list.&apos;(m05).
      EXIT.
    ENDIF.
*   Display short list for copy to Excel transport list:
    me-&gt;alv_xls_init( IMPORTING ex_rf_table = rf_table_xls
                      CHANGING  ch_table = main_list_xls ).
    me-&gt;alv_set_properties( EXPORTING im_table = rf_table_xls ).
    me-&gt;alv_xls_output( ).
    FREE rf_table_xls.
    REFRESH: main_list_xls.
  ENDMETHOD.                    &quot;display_excel

  METHOD set_properties_conflicts.
    TYPES: BEGIN OF lty_field_ran,
             sign   TYPE c LENGTH 1,
             option TYPE c LENGTH 2,
             low    TYPE fieldname,
             high   TYPE fieldname,
           END OF lty_field_ran.
    DATA: ls_reference      TYPE salv_s_ddic_reference.
    DATA: ls_s_column_ref   TYPE salv_s_column_ref.
    DATA: lr_column_table   TYPE REF TO cl_salv_column_table.
*   Declaration for Aggregate Function Settings
    DATA: lr_aggregations   TYPE REF TO cl_salv_aggregations.
    DATA: ls_table          TYPE me-&gt;ty_request_details.
    DATA: lp_popup_width    TYPE lvc_outlen.  &quot;Length
    DATA: lp_cw_columns     TYPE lvc_outlen.  &quot;Length
    DATA: lp_cw_korrnum     TYPE lvc_outlen.  &quot;Length
    DATA: lp_cw_tr_descr    TYPE lvc_outlen.  &quot;Length
    DATA: lp_cw_object      TYPE lvc_outlen.  &quot;Length
    DATA: lp_cw_obj_name    TYPE lvc_outlen.  &quot;Length
    DATA: lp_cw_tabkey      TYPE lvc_outlen.  &quot;Length
    DATA: lp_cw_author      TYPE lvc_outlen.  &quot;Length
    DATA: lp_cw_warning_lvl TYPE lvc_outlen.  &quot;Length
    DATA: lp_cw_date        TYPE lvc_outlen.  &quot;Length
    DATA: lp_cw_time        TYPE lvc_outlen.  &quot;Length
    DATA: lp_cw_keyobject   TYPE lvc_outlen.  &quot;Length
    DATA: lp_cw_keyobjname  TYPE lvc_outlen.  &quot;Length
    DATA: lr_table_des      TYPE REF TO cl_abap_structdescr.
    DATA: lr_type_des       TYPE REF TO cl_abap_typedescr.
    DATA: lt_details        TYPE abap_compdescr_tab.
    DATA: ls_details        TYPE abap_compdescr.
    DATA: lp_field          TYPE string.
    DATA: lp_length         TYPE i.
    DATA: lp_data_type      TYPE string.
    DATA: lp_bool           TYPE abap_bool.
*   Declaration for ALV Columns
    DATA: lr_columns_table    TYPE REF TO cl_salv_columns_table.
    DATA: lt_t_column_ref     TYPE salv_t_column_ref.
*   Declaration for Sort Function Settings
    DATA: lr_sorts            TYPE REF TO cl_salv_sorts.
*   Declaration for Table Selection settings
    DATA: lr_selections       TYPE REF TO cl_salv_selections.
*   Declaration for Global Display Settings
    DATA: lr_display_settings TYPE REF TO cl_salv_display_settings.
*   Declarations for Title
    DATA: lp_version          TYPE char10.
    DATA: lp_title            TYPE lvc_title.
    DATA: l_o_tabledescr         TYPE REF TO cl_abap_tabledescr,
          l_o_typedescr          TYPE REF TO cl_abap_typedescr,
          l_o_structdescr        TYPE REF TO cl_abap_structdescr,
          l_s_abap_compdescr_tab TYPE abap_compdescr.
    FIELD-SYMBOLS: &lt;l_type&gt; TYPE any.
*   To remove some columns from the output
    DATA: lra_fieldname TYPE RANGE OF lty_field_ran.
    DATA: ls_fieldname  TYPE lty_field_ran.
*   Individual Column Properties.
*   Build range for all columns to be removed
    ls_fieldname-option = &apos;EQ&apos;.
    ls_fieldname-sign = &apos;I&apos;.
    ls_fieldname-low = &apos;INFO&apos;.
    APPEND ls_fieldname TO lra_fieldname.
    ls_fieldname-low = &apos;TR_DESCR&apos;.
    APPEND ls_fieldname TO lra_fieldname.
    ls_fieldname-low = &apos;RETCODE&apos;.
    APPEND ls_fieldname TO lra_fieldname.
    ls_fieldname-low = &apos;TRSTATUS&apos;.
    APPEND ls_fieldname TO lra_fieldname.
    ls_fieldname-low = &apos;STATUS_TEXT&apos;.
    APPEND ls_fieldname TO lra_fieldname.
    ls_fieldname-low = &apos;TRFUNCTION&apos;.
    APPEND ls_fieldname TO lra_fieldname.
    ls_fieldname-low = &apos;TRFUNCTION_TXT&apos;.
    APPEND ls_fieldname TO lra_fieldname.
    ls_fieldname-low = &apos;OBJKEY&apos;.
    APPEND ls_fieldname TO lra_fieldname.
    ls_fieldname-low = &apos;OBJFUNC&apos;.
    APPEND ls_fieldname TO lra_fieldname.
    ls_fieldname-low = &apos;CHECKED_BY&apos;.
    APPEND ls_fieldname TO lra_fieldname.
    ls_fieldname-low = &apos;PROJECT&apos;.
    APPEND ls_fieldname TO lra_fieldname.
    ls_fieldname-low = &apos;PROJECT_DESCR&apos;.
    APPEND ls_fieldname TO lra_fieldname.
    ls_fieldname-low = &apos;WARNING_TXT&apos;.
    APPEND ls_fieldname TO lra_fieldname.
    ls_fieldname-low = &apos;WARNING_RANK&apos;.
    APPEND ls_fieldname TO lra_fieldname.
    ls_fieldname-low = &apos;SYSTEMID&apos;.
    APPEND ls_fieldname TO lra_fieldname.
    ls_fieldname-low = &apos;STEPID&apos;.
    APPEND ls_fieldname TO lra_fieldname.
    ls_fieldname-low = &apos;DEV&apos;.
    APPEND ls_fieldname TO lra_fieldname.
    ls_fieldname-low = &apos;QAS&apos;.
    APPEND ls_fieldname TO lra_fieldname.
    ls_fieldname-low = &apos;PRD&apos;.
    APPEND ls_fieldname TO lra_fieldname.
    ls_fieldname-low = &apos;FLAG&apos;.
    APPEND ls_fieldname TO lra_fieldname.
    ls_fieldname-low = &apos;CHECKED&apos;.
    APPEND ls_fieldname TO lra_fieldname.
*   Create the standard output fields.
*   Get the structure of the table.
    lr_table_des ?=
      cl_abap_typedescr=&gt;describe_by_data( me-&gt;main_list_line ).
    lt_details[] = lr_table_des-&gt;components[].
    LOOP AT lt_details INTO ls_details.
      CONCATENATE &apos;ME-&gt;MAIN_LIST_LINE&apos; &apos;-&apos;
                  ls_details-name INTO lp_field.
      ASSIGN (lp_field) TO &lt;l_type&gt;.
      CHECK &lt;l_type&gt; IS ASSIGNED.
      lr_type_des = cl_abap_typedescr=&gt;describe_by_data( &lt;l_type&gt; ).
      lp_length = strlen( lr_type_des-&gt;absolute_name ).
      lp_data_type = lr_type_des-&gt;absolute_name+6(lp_length).
    ENDLOOP.
*   Determine the number of fields in the structure
    FIELD-SYMBOLS:  &lt;l_fs_field1&gt; TYPE any.
    TRY.
        l_o_typedescr = cl_abap_tabledescr=&gt;describe_by_data( p_data = im_table ).
        l_o_tabledescr ?= l_o_typedescr.
        l_o_structdescr ?= l_o_tabledescr-&gt;get_table_line_type( ).
      CATCH cx_sy_move_cast_error INTO rf_root.
        rf_ztct-&gt;handle_error( EXPORTING rf_oref = rf_root ).
      CATCH cx_root INTO rf_root.
        rf_ztct-&gt;handle_error( EXPORTING rf_oref = rf_root ).
    ENDTRY.

*   Determine total width
    LOOP AT im_table INTO ls_table.
      me-&gt;determine_col_width( EXPORTING im_field    = ls_table-trkorr
                               IMPORTING ex_colwidth = lp_cw_korrnum ).
      me-&gt;determine_col_width( EXPORTING im_field    = ls_table-tr_descr
                               IMPORTING ex_colwidth = lp_cw_tr_descr ).
      me-&gt;determine_col_width( EXPORTING im_field    = ls_table-warning_lvl
                               IMPORTING ex_colwidth = lp_cw_warning_lvl ).
      me-&gt;determine_col_width( EXPORTING im_field    = ls_table-object
                               IMPORTING ex_colwidth = lp_cw_object ).
      me-&gt;determine_col_width( EXPORTING im_field    = ls_table-obj_name
                               IMPORTING ex_colwidth = lp_cw_obj_name ).
      lp_cw_obj_name = lp_cw_obj_name + 10.
      me-&gt;determine_col_width( EXPORTING im_field    = ls_table-tabkey
                               IMPORTING ex_colwidth = lp_cw_tabkey ).
      me-&gt;determine_col_width( EXPORTING im_field    = ls_table-keyobject
                               IMPORTING ex_colwidth = lp_cw_keyobject ).
      me-&gt;determine_col_width( EXPORTING im_field    = ls_table-keyobjname
                               IMPORTING ex_colwidth = lp_cw_keyobjname ).
      me-&gt;determine_col_width( EXPORTING im_field    = ls_table-as4date
                               IMPORTING ex_colwidth = lp_cw_date ).
      me-&gt;determine_col_width( EXPORTING im_field    = ls_table-as4time
                               IMPORTING ex_colwidth = lp_cw_time ).
      me-&gt;determine_col_width( EXPORTING im_field    = ls_table-as4user
                               IMPORTING ex_colwidth = lp_cw_author ).
    ENDLOOP.
*   Global Display Settings
    CLEAR : lr_display_settings.
*   Build title:
*   Get version to display in title:
    SELECT datum FROM  vrsd
                 INTO  vrsd-datum UP TO 1 ROWS
                 WHERE objtype = &apos;REPS&apos;
                 AND   objname = sy-repid.
      WRITE vrsd-datum TO lp_version.
    ENDSELECT.
    IF lp_version IS NOT INITIAL.
      SELECT SINGLE text FROM  d347t INTO lp_title
                         WHERE progname = sy-repid
                         AND   sprsl    = sy-langu
                         AND   obj_code = &apos;001&apos;.
      IF sy-subrc &lt;&gt; 0.
        SELECT SINGLE text FROM  d347t INTO lp_title
                           WHERE progname = sy-repid
                           AND   sprsl    = &apos;EN&apos;
                           AND   obj_code = &apos;001&apos;.
      ENDIF.
    ENDIF.
*   Set title
    IF lp_title IS INITIAL.
      lp_title = sy-title.
    ELSE.
      REPLACE &apos;&amp;1&apos; WITH lp_version INTO lp_title.
    ENDIF.
*   Global display settings
    lr_display_settings = rf_conflicts-&gt;get_display_settings( ).
*   Activate Striped Pattern
    lr_display_settings-&gt;set_striped_pattern( if_salv_c_bool_sap=&gt;true ).
*   Report header
    lr_display_settings-&gt;set_list_header( lp_title ).
*   Aggregate Function Settings
    lr_aggregations = rf_conflicts-&gt;get_aggregations( ).
*   Sort Functions
    lr_sorts = rf_conflicts-&gt;get_sorts( ).
    IF lr_sorts IS NOT INITIAL.
      TRY.
          lr_sorts-&gt;add_sort( columnname = &apos;AS4DATE&apos;
                               position = 1
                               sequence   = if_salv_c_sort=&gt;sort_up
                               subtotal   = if_salv_c_bool_sap=&gt;false
                               obligatory = if_salv_c_bool_sap=&gt;false ).
        CATCH cx_salv_not_found INTO rf_root.
          me-&gt;handle_error( EXPORTING rf_oref = rf_root ).
        CATCH cx_salv_existing INTO rf_root.
*          me-&gt;handle_error( EXPORTING rf_oref = rf_root ).
        CATCH cx_salv_data_error INTO rf_root.
          me-&gt;handle_error( EXPORTING rf_oref = rf_root ).
      ENDTRY.
      TRY.
          lr_sorts-&gt;add_sort( columnname = &apos;AS4TIME&apos;
                               position = 2
                               sequence   = if_salv_c_sort=&gt;sort_up
                               subtotal   = if_salv_c_bool_sap=&gt;false
                               group      = if_salv_c_sort=&gt;group_none
                               obligatory = if_salv_c_bool_sap=&gt;false ).
        CATCH cx_salv_not_found INTO rf_root.
          me-&gt;handle_error( EXPORTING rf_oref = rf_root ).
        CATCH cx_salv_existing INTO rf_root.
*          rf_ztct-&gt;handle_error( EXPORTING rf_oref = rf_root ).
        CATCH cx_salv_data_error INTO rf_root.
          me-&gt;handle_error( EXPORTING rf_oref = rf_root ).
      ENDTRY.
    ENDIF.
*   Table Selection Settings
    lr_selections = rf_conflicts-&gt;get_selections( ).
    IF lr_selections IS NOT INITIAL.
*     Allow row Selection
      lr_selections-&gt;set_selection_mode(
                      if_salv_c_selection_mode=&gt;row_column ).
    ENDIF.
*   Event Register settings
    rf_events_table = rf_conflicts-&gt;get_event( ).
    CREATE OBJECT rf_handle_events.
    SET HANDLER rf_handle_events-&gt;on_function_click     FOR rf_events_table.
    SET HANDLER rf_handle_events-&gt;on_double_click_popup FOR rf_events_table.
    SET HANDLER rf_handle_events-&gt;on_link_click_popup   FOR rf_events_table.
*   Get the columns from ALV Table
    lr_columns_table = rf_conflicts-&gt;get_columns( ).
    IF lr_columns_table IS NOT INITIAL.
      REFRESH : lt_t_column_ref.
      lt_t_column_ref = lr_columns_table-&gt;get( ).
*     Get columns properties
      lr_columns_table-&gt;set_optimize( if_salv_c_bool_sap=&gt;true ).
      lr_columns_table-&gt;set_key_fixation( if_salv_c_bool_sap=&gt;true ).
      TRY.
          lr_columns_table-&gt;set_color_column( &apos;T_COLOR&apos; ).
        CATCH cx_salv_data_error INTO rf_root.
          me-&gt;handle_error( EXPORTING rf_oref = rf_root ).
      ENDTRY.

      LOOP AT lt_t_column_ref INTO ls_s_column_ref.
        TRY.
            lr_column_table ?=
              lr_columns_table-&gt;get_column( ls_s_column_ref-columnname ).
          CATCH cx_salv_not_found INTO rf_root.
            me-&gt;handle_error( EXPORTING rf_oref = rf_root ).
        ENDTRY.
        IF lr_column_table IS NOT INITIAL.
*         Make Mandt column invisible
          IF lr_column_table-&gt;get_ddic_datatype( ) = &apos;CLNT&apos;.
            lr_column_table-&gt;set_technical( if_salv_c_bool_sap=&gt;true ).
          ENDIF.
*         Create Aggregate function total for All Numeric/Currency Fields
          IF lr_column_table-&gt;get_ddic_inttype( ) EQ &apos;P&apos; OR
             lr_column_table-&gt;get_ddic_datatype( ) EQ &apos;CURR&apos;.
            IF lr_aggregations IS NOT INITIAL.
              TRY.
                  lr_aggregations-&gt;add_aggregation(
                                    columnname = ls_s_column_ref-columnname
                                    aggregation = if_salv_c_aggregation=&gt;total ).
                CATCH cx_salv_data_error INTO rf_root.
                  me-&gt;handle_error( EXPORTING rf_oref = rf_root ).
                CATCH cx_salv_not_found INTO rf_root.
                  me-&gt;handle_error( EXPORTING rf_oref = rf_root ).
                CATCH cx_salv_existing INTO rf_root.
                  me-&gt;handle_error( EXPORTING rf_oref = rf_root ).
              ENDTRY.
            ENDIF.
          ENDIF.
*         Create Check box for fields with domain &quot;XFELD&quot;
          IF lr_column_table-&gt;get_ddic_domain( ) EQ &apos;XFELD&apos;.
            lr_column_table-&gt;set_cell_type( if_salv_c_cell_type=&gt;checkbox ).
          ENDIF.
*         Add Hotspot&amp;Hyper Link to the column vbeln
          IF ls_s_column_ref-columnname EQ &apos;TRKORR&apos;.
            lr_column_table-&gt;set_cell_type( if_salv_c_cell_type=&gt;hotspot ).
            lr_column_table-&gt;set_key( if_salv_c_bool_sap=&gt;true ).
          ENDIF.
*         Remove columns that are not required
          IF lr_column_table-&gt;get_columnname( ) IN lra_fieldname.
            lr_column_table-&gt;set_technical( if_salv_c_bool_sap=&gt;true ).
            CONTINUE.
          ENDIF.
          CASE lr_column_table-&gt;get_columnname( ).
            WHEN &apos;TRKORR&apos;.
              lr_column_table-&gt;set_key( if_salv_c_bool_sap=&gt;false ).
              lp_cw_korrnum = me-&gt;check_colwidth( im_name     = &apos;TRKORR&apos;
                                                  im_colwidth = lp_cw_korrnum ).
              lr_column_table-&gt;set_output_length( lp_cw_korrnum ).
            WHEN &apos;TR_DESCR&apos;.
              lr_column_table-&gt;set_key( if_salv_c_bool_sap=&gt;false ).
              lp_cw_tr_descr = me-&gt;check_colwidth( im_name     = &apos;TR_DESCR&apos;
                                                   im_colwidth = lp_cw_tr_descr ).
              lr_column_table-&gt;set_output_length( lp_cw_tr_descr ).
            WHEN &apos;WARNING_LVL&apos;.
              IF check_flag = abap_true.
                ls_reference-table = &apos;FCALV_S_RMLIFO20&apos;.
                ls_reference-field = &apos;WARNING&apos;.
                lr_column_table-&gt;set_ddic_reference( ls_reference ).
                lr_column_table-&gt;set_icon( ).
                lr_column_table-&gt;set_output_length( lp_cw_warning_lvl ).
              ELSE.
                lr_column_table-&gt;set_technical( ).
              ENDIF.
            WHEN &apos;OBJECT&apos;.
              lr_column_table-&gt;set_key( if_salv_c_bool_sap=&gt;false ).
              lp_cw_object = me-&gt;check_colwidth( im_name     = &apos;OBJECT&apos;
                                                 im_colwidth = lp_cw_object ).
              lr_column_table-&gt;set_output_length( lp_cw_object ).
            WHEN &apos;OBJ_NAME&apos;.
              lr_column_table-&gt;set_key( if_salv_c_bool_sap=&gt;false ).
              lp_cw_obj_name = me-&gt;check_colwidth( im_name     = &apos;OBJ_NAME&apos;
                                                   im_colwidth = lp_cw_obj_name ).
              lr_column_table-&gt;set_output_length( lp_cw_obj_name ).
            WHEN &apos;TABKEY&apos;.
              lr_column_table-&gt;set_key( if_salv_c_bool_sap=&gt;false ).
              IF lp_cw_tabkey IS INITIAL.
                lr_column_table-&gt;set_technical( ).
              ELSE.
                lp_cw_tabkey = me-&gt;check_colwidth( im_name     = &apos;TABKEY&apos;
                                                   im_colwidth = lp_cw_tabkey ).
                lr_column_table-&gt;set_output_length( lp_cw_tabkey ).
              ENDIF.
            WHEN &apos;KEYOBJECT&apos;.
              lr_column_table-&gt;set_key( if_salv_c_bool_sap=&gt;false ).
              IF lp_cw_keyobject IS INITIAL.
                lr_column_table-&gt;set_technical( ).
              ELSE.
                lp_cw_keyobject = me-&gt;check_colwidth( im_name     = &apos;KEYOBJECT&apos;
                                                      im_colwidth = lp_cw_keyobject ).
                lr_column_table-&gt;set_output_length( lp_cw_keyobject ).
              ENDIF.
            WHEN &apos;KEYOBJNAME&apos;.
              lr_column_table-&gt;set_key( if_salv_c_bool_sap=&gt;false ).
              IF lp_cw_keyobjname IS INITIAL.
                lr_column_table-&gt;set_technical( ).
              ELSE.
                lp_cw_keyobjname = me-&gt;check_colwidth( im_name     = &apos;KEYOBJNAME&apos;
                                                       im_colwidth = lp_cw_keyobjname ).
                lr_column_table-&gt;set_output_length( lp_cw_keyobjname ).
              ENDIF.
            WHEN &apos;AS4DATE&apos;.
              lr_column_table-&gt;set_key( if_salv_c_bool_sap=&gt;false ).
              lp_cw_date = me-&gt;check_colwidth( im_name     = &apos;AS4DATE&apos;
                                               im_colwidth = lp_cw_date ).
              lr_column_table-&gt;set_output_length( lp_cw_date ).
            WHEN &apos;AS4TIME&apos;.
              lr_column_table-&gt;set_key( if_salv_c_bool_sap=&gt;false ).
              lp_cw_time = me-&gt;check_colwidth( im_name     = &apos;AS4TIME&apos;
                                               im_colwidth = lp_cw_time ).
              lr_column_table-&gt;set_output_length( lp_cw_time ).
            WHEN &apos;AS4USER&apos;.
              lr_column_table-&gt;set_key( if_salv_c_bool_sap=&gt;false ).
              lp_cw_author = me-&gt;check_colwidth( im_name     = &apos;AS4USER&apos;
                                                 im_colwidth = lp_cw_author ).
              lr_column_table-&gt;set_output_length( lp_cw_author ).
          ENDCASE.
*         Count the number of columns that are visible
          lp_bool = lr_column_table-&gt;is_technical( ).
          IF lp_bool = abap_false.
            lp_cw_columns = lp_cw_columns + 1.
          ENDIF.
        ENDIF.
      ENDLOOP.
    ENDIF.


    ex_xend = lp_cw_korrnum     + lp_cw_tr_descr   +
              lp_cw_warning_lvl + lp_cw_object     +
              lp_cw_obj_name    + lp_cw_tabkey     +
              lp_cw_keyobject   + lp_cw_keyobjname +
              lp_cw_date        + lp_cw_time       +
              lp_cw_author      + lp_cw_columns.
  ENDMETHOD.                    &quot;set_properties_conflicts

  METHOD prepare_ddic_check.
    me-&gt;set_ddic_objects( ).
    me-&gt;set_where_used( ).
  ENDMETHOD.                    &quot;prepare_ddic_check

  METHOD set_ddic_objects.
    REFRESH: ddic_objects.
*   DD01L (Domains)
    SELECT domname FROM dd01l APPENDING TABLE ddic_objects
                   WHERE domname LIKE &apos;Z%&apos;.
*                   AND as4date IN date_range.
*   DD02L (SAP-tables)
    SELECT tabname FROM dd02l APPENDING TABLE ddic_objects
                   WHERE tabname LIKE &apos;Z%&apos;.
*                   AND as4date IN date_range.
*   DD04L (Data elements)
    SELECT rollname FROM dd04l APPENDING TABLE ddic_objects
                    WHERE rollname LIKE &apos;Z%&apos;.
*                    AND as4date IN date_range.
  ENDMETHOD.   &quot;set_ddic_objects

  METHOD do_ddic_check.
    DATA: ls_ddic_conflict_info TYPE ty_request_details.
    DATA: ls_main              TYPE ty_request_details.
    DATA: lp_obj_name          TYPE trobj_name.
*  Check if the object exists in the where_used list for data
*  dictionary elements that do not yet exist in production.
*  If it is found in the where_used list, then the object MUST
*  also be in the main transport list. If it is not, it is an ERROR,
*  because transporting to production will cause DUMPS.
*  Check is independent of Flags. (Re)Check all objects in the list!
*  Message: &quot;Contains an object that does not exist in prod. and
*            is not in the list&quot;
    LOOP AT ch_main_list INTO ls_main.
      LOOP AT where_used INTO  where_used_line
                         WHERE object = ls_main-obj_name. &quot;#EC CI_NESTED
*       If the used object (i.e. element, domain etc) is in the DDIC_E071 list,
*       it means that the used object is NOT in production yet. Transporting
*       the object that uses this used object will cause dumps in production.
        READ TABLE ddic_e071 INTO ddic_e071_line
                             WITH KEY obj_name = where_used_line-used_obj.
*       The object in this transport contains a DDIC object that is not yet in
*       Production. This will cause dumps, unless the DDIC object can be found
*       as an object in the transport list!
        IF sy-subrc = 0.
*         Check if the used object can be found in the main list
          READ TABLE ch_main_list WITH KEY obj_name = where_used_line-used_obj
                                  TRANSPORTING NO FIELDS.
          IF sy-subrc &lt;&gt; 0.
            IF ls_main-flag = abap_true.
              lp_obj_name = where_used_line-used_obj.
              ls_ddic_conflict_info = me-&gt;get_tp_info( im_trkorr   = ddic_e071_line-trkorr
                                                       im_obj_name = lp_obj_name ).
              MOVE-CORRESPONDING ls_ddic_conflict_info TO me-&gt;conflict_line.
              me-&gt;conflict_line-warning_lvl  = co_ddic.
              me-&gt;conflict_line-warning_rank = co_ddic_rank.
              me-&gt;conflict_line-warning_txt  = lp_ddic_text.
              APPEND: me-&gt;conflict_line TO me-&gt;conflicts.
              CLEAR:  me-&gt;conflict_line.
            ENDIF.
            ls_main-warning_lvl  = co_ddic.
            ls_main-warning_rank = co_ddic_rank.
            ls_main-warning_txt  = lp_ddic_text.
            MODIFY: ch_main_list FROM ls_main TRANSPORTING warning_lvl
                                                           warning_rank
                                                           warning_txt
                                                           t_color.
            me-&gt;total = me-&gt;total + 1.
          ELSE.
            IF ls_main-warning_rank = co_ddic_rank.
              ls_main-flag         = abap_true.
              MODIFY: ch_main_list FROM ls_main TRANSPORTING flag.
            ENDIF.
          ENDIF.
        ENDIF.
      ENDLOOP.
    ENDLOOP.
  ENDMETHOD.                    &quot;do_ddic_check

  METHOD set_where_used.
    DATA: ta_stms_wbo_requests TYPE TABLE OF stms_wbo_request,
          st_stms_wbo_requests TYPE stms_wbo_request.
    DATA: st_systems           TYPE ctslg_system.
    DATA: lp_scope             TYPE seu_obj.
    DATA: lp_answer            TYPE char1.
    DATA: lt_trkorrs           TYPE trkorrs.
    DATA: lp_ddic_object       TYPE string.
    DATA: ls_ddic_object       TYPE string.
    DATA: lp_index             TYPE syindex.
    DATA: lp_counter           TYPE i.
    DATA: lp_total(10)         TYPE n.
    DATA: lp_deleted           TYPE abap_bool.
    DATA: lp_obj_name          TYPE trobj_name.

    REFRESH: ddic_e071.
* Get all object types
*--select values for pgmid/object/text from database--------------------
    DATA: lt_object_table  TYPE tr_object_texts.
    DATA: ls_object        TYPE ko100.
    DATA: lt_objrangtab    TYPE objrangtab.
    DATA: ls_objtyprang    TYPE objtyprang.
    DATA: lt_objtype       TYPE TABLE OF versobjtyp.
    DATA: ls_objtype       TYPE versobjtyp.
    DATA: lp_chars         TYPE string VALUE &apos;1234567890ABCDEFGHIJKLMNOPQRSTUVWXYZ&apos;.

* Get all object types that have been transported before
    SELECT DISTINCT object FROM e071 INTO TABLE lt_objtype.
    ls_objtyprang-sign   = &apos;I&apos;.
    ls_objtyprang-option = &apos;EQ&apos;.
    LOOP AT lt_objtype INTO ls_objtyprang-low.
      IF ls_objtyprang-low CN lp_chars.
        CONTINUE.
      ENDIF.
      APPEND ls_objtyprang TO lt_objrangtab.
    ENDLOOP.

* Now find ALL transports for the DDIC objects with Program ID R3TR,
* for the object types found
    CLEAR: lp_counter.
    DESCRIBE TABLE ddic_objects LINES lp_total.
    LOOP AT ddic_objects INTO ls_ddic_object.
      lp_counter = lp_counter + 1.
      lp_obj_name = ls_ddic_object.
      me-&gt;progress_indicator( EXPORTING im_counter = lp_counter
                                        im_object  = lp_obj_name
                                        im_total   = lp_total
                                        im_text    = &apos;Collecting DDIC Info&apos;(053)
                                        im_flag    = &apos; &apos; ).
      SELECT trkorr pgmid object obj_name
             FROM e071 APPENDING CORRESPONDING FIELDS OF TABLE ddic_e071
             WHERE   pgmid    = &apos;R3TR&apos;
             AND     object   IN lt_objrangtab
             AND     obj_name = ls_ddic_object.      &quot;#EC CI_SEL_NESTED
    ENDLOOP.

*   Check if the transport is in production, if it is, then the
*   DDIC object is existing and &apos;should&apos; not cause problems.
    CLEAR: lp_counter.
    LOOP AT ddic_e071 INTO ddic_e071_line.
      lp_index = sy-tabix.
      lp_deleted = abap_false.
      IF ddic_e071_line-trkorr(3) NS me-&gt;dev_system.
*       Not a Development transport, check not required
        DELETE ddic_e071 INDEX lp_index.
        CONTINUE.
      ENDIF.
      REFRESH: ta_stms_wbo_requests.
      CLEAR:   ta_stms_wbo_requests.
      CALL FUNCTION &apos;TMS_MGR_READ_TRANSPORT_REQUEST&apos;
        EXPORTING
          iv_request                 = ddic_e071_line-trkorr
          iv_target_system           = me-&gt;dev_system
          iv_header_only             = &apos;X&apos;
          iv_monitor                 = &apos; &apos;
        IMPORTING
          et_request_infos           = ta_stms_wbo_requests
        EXCEPTIONS
          read_config_failed         = 1
          table_of_requests_is_empty = 2
          system_not_available       = 3
          OTHERS                     = 4.
      IF sy-subrc &lt;&gt; 0.
        MESSAGE ID sy-msgid TYPE sy-msgty NUMBER sy-msgno
                WITH sy-msgv1 sy-msgv2 sy-msgv3 sy-msgv4.
      ENDIF.
      READ TABLE ta_stms_wbo_requests INDEX 1
                                      INTO st_stms_wbo_requests.
      IF st_stms_wbo_requests-e070-trstatus NA &apos;NR&apos;.
*       Transport not released, check not required
        DELETE ddic_e071 INDEX lp_index.
        lp_deleted = abap_true.
      ELSEIF st_stms_wbo_requests-e070-trstatus = &apos;O&apos;.
      ELSE.
*       Retrieve the environments where the transport can be found.
*       Read the info of the request (transport log) to determine the
*       highest environment the transport has been moved to.
        CALL FUNCTION &apos;TR_READ_GLOBAL_INFO_OF_REQUEST&apos;
          EXPORTING
            iv_trkorr = ddic_e071_line-trkorr
          IMPORTING
            es_cofile = st_request-cofile.
        IF st_request-cofile-systems IS INITIAL.
*         Transport log does not exist: not released or log deleted
          DELETE ddic_e071 INDEX lp_index.
          lp_deleted = abap_true.
        ELSE.
*         Now check in which environments the transport can be found
          LOOP AT st_request-cofile-systems INTO st_systems. &quot;#EC CI_NESTED
*           For each environment, set the status icon:
            CASE st_systems-systemid.
              WHEN me-&gt;prd_system.
                DESCRIBE TABLE st_systems-steps LINES tp_lines.
                READ TABLE st_systems-steps INTO st_steps
                                            INDEX tp_lines.
                CHECK st_steps-stepid &lt;&gt; &apos;&lt;&apos;.
*               Transported to production, check not required on this
*               object. Delete all records for this object (not only
*               for this transport but for all transports)
                DELETE ddic_e071 INDEX lp_index.
                lp_deleted = abap_true.
              WHEN OTHERS.
            ENDCASE.
          ENDLOOP.
        ENDIF.
      ENDIF.
*     Show the progress indicator
      IF lp_deleted = abap_false.
*       Only add counter if the line was not deleted...
        lp_counter = lp_counter + 1.
      ENDIF.
      DESCRIBE TABLE ddic_e071 LINES lp_total.
      me-&gt;progress_indicator( EXPORTING im_counter = lp_counter
                                        im_object  = ddic_e071_line-obj_name
                                        im_total   = lp_total
                                        im_text    = &apos;DDIC not transported...&apos;(051)
                                        im_flag    = &apos; &apos; ).
    ENDLOOP.
*   Rebuild ddic_objects list
    REFRESH: ddic_objects.
    LOOP AT ddic_e071 INTO ddic_e071_line.
      APPEND ddic_e071_line-obj_name TO ddic_objects.
    ENDLOOP.
    SORT ddic_objects.
    DELETE ADJACENT DUPLICATES FROM ddic_objects.
*   Show the progress indicator
    CALL FUNCTION &apos;SAPGUI_PROGRESS_INDICATOR&apos;
      EXPORTING
        text = &apos;Retrieving Where Used list&apos;(052).
* Build the WHERE_USED list for all remaining objects
    CALL FUNCTION &apos;RS_EU_CROSSREF&apos;
      EXPORTING
        i_find_obj_cls           = &apos;DT&apos;
        no_dialog                = &apos;X&apos;
      IMPORTING
        o_scope_obj_cls          = lp_scope
        o_answer                 = lp_answer
      TABLES
        i_findstrings            = ddic_objects
        o_founds                 = where_used
      EXCEPTIONS
        not_executed             = 0
        not_found                = 0
        illegal_object           = 0
        no_cross_for_this_object = 0
        batch                    = 0
        batchjob_error           = 0
        wrong_type               = 0
        object_not_exist         = 0
        OTHERS                   = 0.
* Remove all entries from the where used list that are not existing
* in tables DD01L, DD02L or DD04L
    DATA: lp_string TYPE string.
    LOOP AT where_used INTO where_used_line.
* DD01L (Domains)
      SELECT SINGLE domname
                    FROM dd01l INTO lp_string
                    WHERE domname = where_used_line-used_obj. &quot;#EC CI_SEL_NESTED
      IF sy-subrc &lt;&gt; 0.
* DD02L (SAP-tables)
        SELECT SINGLE tabname
                      FROM dd02l INTO lp_string
                      WHERE tabname = where_used_line-used_obj. &quot;#EC CI_SEL_NESTED
        IF sy-subrc &lt;&gt; 0.
* DD04L (Data elements)
          SELECT SINGLE rollname
                        FROM dd04l INTO lp_string
                        WHERE rollname = where_used_line-used_obj. &quot;#EC CI_SEL_NESTED
        ENDIF.
      ENDIF.
      IF sy-subrc &lt;&gt; 0.
        DELETE where_used INDEX sy-tabix.
      ENDIF.
    ENDLOOP.
  ENDMETHOD.                    &quot;set_where_used

  METHOD get_import_datetime_qas.
    DATA: ta_stms_wbo_requests TYPE TABLE OF stms_wbo_request,
          st_stms_wbo_requests TYPE stms_wbo_request.
    DATA: st_systems           TYPE ctslg_system.
*   Get the last date the object was imported
    CALL FUNCTION &apos;TR_READ_GLOBAL_INFO_OF_REQUEST&apos;
      EXPORTING
        iv_trkorr = im_trkorr
      IMPORTING
        es_cofile = st_request-cofile.
    LOOP AT st_request-cofile-systems INTO  st_systems
                                      WHERE systemid = me-&gt;qas_system.
*               Get the latest import date:
      DESCRIBE TABLE st_systems-steps LINES tp_lines.
      READ TABLE st_systems-steps INTO st_steps
                                  INDEX tp_lines.
      DESCRIBE TABLE st_steps-actions LINES tp_lines.
      READ TABLE st_steps-actions INTO st_actions
                                  INDEX tp_lines.
      MOVE st_actions-time TO ex_as4time.
      MOVE st_actions-date TO ex_as4date.
    ENDLOOP.
    ex_return = sy-subrc.
  ENDMETHOD.                    &quot;get_import_datetime_qas

  METHOD go_back_months.
    DATA: BEGIN OF dat,
            jjjj(4) ,
            mm(2) ,
            tt(2) ,
          END OF dat,

          BEGIN OF hdat,
            jjjj(4) ,
            mm(2) ,
            tt(2) ,
          END OF hdat,
          newmm TYPE p,
          diffjjjj TYPE p.

    WRITE:  im_currdate+0(4) TO dat-jjjj,
            im_currdate+4(2) TO  dat-mm,
            im_currdate+6(2) TO  dat-tt.
    diffjjjj =   ( dat-mm + ( - im_backmonths ) - 1 ) DIV 12.
    newmm    =   ( dat-mm + ( - im_backmonths ) - 1 ) MOD 12 + 1.
    dat-jjjj = dat-jjjj +  diffjjjj.

    IF newmm &lt; 10.
      WRITE &apos;0&apos; TO  dat-mm+0(1).
      WRITE newmm TO  dat-mm+1(1).
    ELSE.
      WRITE newmm TO  dat-mm.
    ENDIF.
    IF dat-tt &gt; &apos;28&apos;.
      hdat-tt = &apos;01&apos;.
      newmm   = ( dat-mm  )  MOD 12 + 1.
      hdat-jjjj = dat-jjjj + ( (  dat-mm ) DIV 12 ).

      IF newmm &lt; 10.
        WRITE &apos;0&apos; TO hdat-mm+0(1).
        WRITE newmm TO hdat-mm+1(1).
      ELSE.
        WRITE newmm TO hdat-mm.
      ENDIF.

      IF dat-tt = &apos;31&apos;.
        re_date = hdat.
        re_date = re_date - 1.
      ELSE.
        IF dat-mm = &apos;02&apos;.
          re_date = hdat.
          re_date = re_date - 1.
        ELSE.
          re_date = dat.
        ENDIF.
      ENDIF.
    ELSE.
      re_date = dat.
    ENDIF.
  ENDMETHOD.                    &quot;go_back_months

ENDCLASS.                    &quot;lcl_ztct IMPLEMENTATION

*--------------------------------------------------------------------*
*       DATA SELECT
*--------------------------------------------------------------------*
START-OF-SELECTION.

  IF rf_ztct IS NOT BOUND.
    TRY .
        CREATE OBJECT rf_ztct.
      CATCH cx_root INTO rf_root.
        rf_ztct-&gt;handle_error( EXPORTING rf_oref = rf_root ).
    ENDTRY.
  ENDIF.

  tp_prefix = rf_ztct-&gt;get_tp_prefix( im_dev = pa_dev ).

  IF pa_sel = abap_true.
    tp_process_type = 1.
  ELSE.
    tp_process_type = 3.
  ENDIF.

  IF tp_process_type = 1.
*   Get transports
    CALL FUNCTION &apos;SAPGUI_PROGRESS_INDICATOR&apos;
      EXPORTING
        text = &apos;Selecting data...&apos;(014).
*   Join over E070, E071:
*   Description is read later to prevent complicated join and
*   increased runtime
    st_trkorr_range-sign   = &apos;I&apos;.
    st_trkorr_range-option = &apos;EQ&apos;.
    SELECT a~trkorr
           INTO st_trkorr_range-low
           FROM  e070 AS a JOIN e071 AS b
             ON  a~trkorr = b~trkorr
           WHERE a~trkorr     IN so_korr
           AND   a~as4user    IN so_user
           AND   a~as4date    IN so_date
           AND   b~obj_name   IN so_exobj
           AND   strkorr      = &apos;&apos;
           AND   a~trkorr     LIKE tp_prefix
           AND   NOT a~trkorr IN ra_project_trkorrs
           AND   ( pgmid = &apos;LIMU&apos; OR
                   pgmid = &apos;R3TR&apos; ).
      APPEND st_trkorr_range TO ta_trkorr_range.
    ENDSELECT.
*   Read transport description:
    IF ta_trkorr_range[] IS NOT INITIAL.
      LOOP AT ta_trkorr_range INTO st_trkorr_range.
*       Check if the description contains the search string
        SELECT SINGLE as4text
                      FROM e07t INTO tp_transport_descr
                      WHERE  trkorr = st_trkorr_range-low
                      AND    langu  = sy-langu.      &quot;#EC CI_SEL_NESTED
        IF pa_str CS &apos;*&apos;.
          IF tp_transport_descr NP pa_str.
            DELETE ta_trkorr_range INDEX sy-tabix.
            CONTINUE.
          ENDIF.
        ELSE.
          IF tp_transport_descr NS pa_str.
            DELETE ta_trkorr_range INDEX sy-tabix.
            CONTINUE.
          ENDIF.
        ENDIF.
*       Check if the project is in the selection range
        SELECT reference
               FROM e070a
               UP TO 1 ROWS
               INTO  tp_project_reference
               WHERE trkorr = st_trkorr_range-low
               AND   attribute = &apos;SAP_CTS_PROJECT&apos;.  &quot;#EC CI_SEL_NESTED
          IF NOT tp_project_reference IN so_proj.
            DELETE ta_trkorr_range INDEX sy-tabix.
          ENDIF.
        ENDSELECT.
      ENDLOOP.
      SORT ta_trkorr_range.
      DELETE ADJACENT DUPLICATES FROM ta_trkorr_range.
    ENDIF.
  ENDIF.

  ta_project_range[]    = so_proj[].
  ta_excluded_objects[] = so_exobj[].
  ta_date_range[]       = so_date[].

END-OF-SELECTION.

*--------------------------------------------------------------------*
*       Main program
*--------------------------------------------------------------------*
  IF ta_trkorr_range IS INITIAL AND
     tp_process_type = 1.
    MESSAGE i000(db) DISPLAY LIKE &apos;E&apos;
                     WITH &apos;No transports found...&apos;(m13).
  ELSE.
    PERFORM init_ztct.
    rf_ztct-&gt;execute( ).
  ENDIF.

*&amp;---------------------------------------------------------------------*
*&amp;      Form  INIT_ZTCT
*&amp;---------------------------------------------------------------------*
FORM init_ztct.
  rf_ztct-&gt;set_check_flag( pa_check ).
  rf_ztct-&gt;set_check_tabkeys( pa_chkky ).
  rf_ztct-&gt;set_clear_checked( pa_chd ).
  rf_ztct-&gt;set_skip_buffer_chk( pa_buff ).
  rf_ztct-&gt;set_skiplive( pa_noprd ).
  rf_ztct-&gt;set_user_layout( pa_user ).
  rf_ztct-&gt;set_trkorr_range( ta_trkorr_range ).
  rf_ztct-&gt;set_project_range( ta_project_range ).
  rf_ztct-&gt;set_date_range( ta_date_range ).
  rf_ztct-&gt;set_excluded_objects( ta_excluded_objects ).
  rf_ztct-&gt;set_search_string( pa_str ).
  rf_ztct-&gt;set_process_type( tp_process_type ).
  rf_ztct-&gt;set_filename( pa_file ).
  rf_ztct-&gt;set_systems( EXPORTING im_dev_system = pa_dev
                                  im_qas_system = pa_qas
                                  im_prd_system = pa_prd ).
ENDFORM.                    &quot; INIT_ZTCT</source>
 </PROG>
</nugget>
